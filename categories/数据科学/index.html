<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 数据科学 - Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">数据科学</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-04-simple-eda/"><img class="fill" src="/images/simple-eda/cover.png" alt="探索性数据分析入门"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.093Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.094Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></span><span class="level-item">24 分钟读完 (大约3537个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-04-simple-eda/">探索性数据分析入门</a></h1><div class="content"><p>在数据科学领域里，最具挑战的问题之一便是如何确定数据对特定问题带来价值。在使用机器学习或者深度学习之前，确定数据或者特征是否利于特定问题，是数据科学后续工作的重中之重。</p>
<p>因此，在进行数据科学问题之前，通常会对数据进行分析，洞察数据中所涵盖的深层特性是否利于特定问题，以及是否适用于所选用的机器学习算法等，而这一步被称为<strong>探索性数据分析（Exploratory Data Analysis， EDA）</strong>。</p>
<p><strong>探索性数据分析（Exploratory Data Analysis，EDA）</strong> 是指对已有数据在尽量少的先验假设下通过作图、制表、方程拟合、计算特征量等手段探索数据的结构和规律的一种数据分析方法，该方法在上世纪70年代由美国统计学家J.K.Tukey提出。传统的统计分析方法常常先假设数据符合一种统计模型，然后依据数据样本来估计模型的一些参数及统计量，以此了解数据的特征，但实际中往往有很多数据并不符合假设的统计模型分布，这导致数据分析结果不理想。EDA则是一种更加贴合实际情况的分析方法，它强调让数据自身“说话”，通过EDA我们可以最真实、直接的观察到数据的结构及特征。</p>
<blockquote>
<p><strong>探索性数据分析（EDA）是一种数据分析方法，它采用多种技术来最大化对数据集的洞察力。揭示底层结构；提取重要变量；检测异常值和异常；建立简约模型；并确定最佳因子设置。</strong></p>
</blockquote>
<p><img src="/images/simple-eda/banner.png"></p>
<h2 id="从实战中学习EDA"><a href="#从实战中学习EDA" class="headerlink" title="从实战中学习EDA"></a>从实战中学习EDA</h2><p><strong>实践是检验整理的唯一途径。</strong> 为了能够更好更快的理解EDA，这里将直接从**<a target="_blank" rel="noopener" href="https://archive.ics.uci.edu/ml/datasets/Iris">鸢尾花数据集(UCI Machine Learning Repository)</a>**的探索性分析中学习EDA的方法。</p>
<p><strong>目标：</strong> 从给定4个维度特征的鸢尾花数据集中学习，已确定新的鸢尾花属于3个鸢尾花类别中的哪一个类别。</p>
<blockquote>
<p><strong>在进行EDA的过程中，需要始终牢记最初确立的目标，否则EDA可能偏离目标！</strong></p>
</blockquote>
<h3 id="导入所需类库"><a href="#导入所需类库" class="headerlink" title="导入所需类库"></a>导入所需类库</h3><p>显而易见，进行Python语言相关的开发时，第一步基本上都是导入所需的类库（前提是类库已经被安装在当前坏境）。在进行EDA时，所需的类库可能并不是很多，满足需求即可，在这里，将导入像<em>Pandas、Matplotlib、numpy</em>等类库，对应类库的作用，可自行搜索学习。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<h3 id="下载数据并加载"><a href="#下载数据并加载" class="headerlink" title="下载数据并加载"></a>下载数据并加载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;downlaod iris.csv from https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#Load Iris.csv into a pandas dataFrame.</span></span><br><span class="line">iris = pd.read_csv(<span class="string">&quot;./iris.csv&quot;</span>)</span><br><span class="line">iris.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>*.head()<em>函数是Pandas中的标准函数，用于观察数据集的数据详情，默认情况下返回数据集的前5个样本点。同时，</em>.tail()*函数返回数据集的后5个样本点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Data-points and features</span></span><br><span class="line">iris.shape</span><br></pre></td></tr></table></figure>




<pre><code>(150, 5)
</code></pre>
<p><em>.shape</em>参数可以查看数据集的形状（行数、列数）。</p>
<ul>
<li>此处使用的鸢尾花数据集是一个150行和5列的数据集。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 150 entries, 0 to 149
Data columns (total 5 columns):
sepal_length    150 non-null float64
sepal_width     150 non-null float64
petal_length    150 non-null float64
petal_width     150 non-null float64
species         150 non-null object
dtypes: float64(4), object(1)
memory usage: 6.0+ KB
</code></pre>
<p>*.info()*函数用于展示数据集列数据的数据类型情况。</p>
<ul>
<li>此处，数据只有float类型和object类型两种值类型数据；</li>
<li>无变量或列包含null值或者缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.columns</span><br></pre></td></tr></table></figure>




<pre><code>Index([&#39;sepal_length&#39;, &#39;sepal_width&#39;, &#39;petal_length&#39;, &#39;petal_width&#39;,
       &#39;species&#39;],
      dtype=&#39;object&#39;)
</code></pre>
<ul>
<li><em>.columns</em> 用来查看数据集的列或特征的名称。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris[<span class="string">&#x27;species&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>versicolor    50
setosa        50
virginica     50
Name: species, dtype: int64
</code></pre>
<ul>
<li>*.value_counts()*是对数据集上特定列进行降序后，获取该列的每个值的计数值；</li>
<li>此处，每一个种类（Versicolor, Setosa, Virginica）各有50个观察对象，因此该数据集应该是<strong>均匀分布</strong>的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>150.000000</td>
      <td>150.000000</td>
      <td>150.000000</td>
      <td>150.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>5.843333</td>
      <td>3.054000</td>
      <td>3.758667</td>
      <td>1.198667</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.828066</td>
      <td>0.433594</td>
      <td>1.764420</td>
      <td>0.763161</td>
    </tr>
    <tr>
      <th>min</th>
      <td>4.300000</td>
      <td>2.000000</td>
      <td>1.000000</td>
      <td>0.100000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>5.100000</td>
      <td>2.800000</td>
      <td>1.600000</td>
      <td>0.300000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>5.800000</td>
      <td>3.000000</td>
      <td>4.350000</td>
      <td>1.300000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>6.400000</td>
      <td>3.300000</td>
      <td>5.100000</td>
      <td>1.800000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>7.900000</td>
      <td>4.400000</td>
      <td>6.900000</td>
      <td>2.500000</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>*.describe()*函数用于获取数据集的各种汇总统计信息。该函数返回计数值、均值、标准差、最小值和最大值、以及数据的分位数。</li>
</ul>
<p>至此，对数据集来说已经有了一个基础的了解，对于数据的探索性分析来说，这才刚刚开始，往往通过对数据的图形化描述能够更加详细的了解数据特征之间的关系等，包括单变量和多变量分析等。</p>
<h2 id="二维散点图"><a href="#二维散点图" class="headerlink" title="二维散点图"></a>二维散点图</h2><p>散点图是一种将数据显示为点集合的图。点的位置取决于其二维值，每个值都是水平或者垂直维度上的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2-D Scatter plot with color-coding for each flower type/class.</span></span><br><span class="line"><span class="comment"># Here &#x27;sns&#x27; corresponds to seaborn</span></span><br><span class="line">sns.set_style(<span class="string">&#x27;whitegrid&#x27;</span>)</span><br><span class="line">sns.FacetGrid(iris, hue=<span class="string">&#x27;species&#x27;</span>, height=<span class="number">8</span>) \</span><br><span class="line">    .<span class="built_in">map</span>(plt.scatter, <span class="string">&#x27;sepal_length&#x27;</span>, <span class="string">&#x27;sepal_width&#x27;</span>) \</span><br><span class="line">    .add_legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_21_0.png" alt="png"></p>
<p>Seaborn中的<em>FacetGrid</em>类有助于使用多个面板在数据集的子集中可视化一个变量的分布以及多个变量之间的关系。参数<em>hue</em>根据与每个参数相关的颜色将数据点分开。</p>
<p>三个类别的数据点根据<em>sepal_length</em>分散。</p>
<ul>
<li>使用<em>sepal_length</em>和<em>sepal_width</em>特征，可以区分Setosa同其他类别（线性可分）；</li>
<li>区分Versicolor和Virginica相对困难一点，因为它们之间有大量的重叠部分。</li>
</ul>
<h2 id="对图"><a href="#对图" class="headerlink" title="对图"></a>对图</h2><p>对图有助于查看数据中单个变量的分布以及多个变量之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pairwise scatter plot: Pair-Plot</span></span><br><span class="line"><span class="comment"># Dis-advantages: Cannot visualize higher dimensional patterns in 3-D and 4-D.</span></span><br><span class="line"><span class="comment"># Only possible to view 2D patterns.</span></span><br><span class="line">plt.close()</span><br><span class="line">sns.pairplot(iris, hue=<span class="string">&#x27;species&#x27;</span>, size=<span class="number">3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_24_0.png" alt="png"></p>
<ul>
<li><em>petal_length</em>和<em>petal_width</em>是区分各种类型鸢尾花的重要特征；</li>
<li>Setosa类型的鸢尾花很容易被识别（线性可分），Virginica和Versicolor的特征有一些重叠（接近于线性可分）；</li>
<li>可以找到“分割线”或者“if-else”条件来建立一个简单的模型，对鸢尾花的类型进行分类。</li>
</ul>
<h2 id="直方图和PDF（概率密度函数）"><a href="#直方图和PDF（概率密度函数）" class="headerlink" title="直方图和PDF（概率密度函数）"></a>直方图和PDF（概率密度函数）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.FacetGrid(iris, hue=<span class="string">&#x27;species&#x27;</span>, height=<span class="number">8</span>) \</span><br><span class="line">    .<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;petal_length&#x27;</span>) \</span><br><span class="line">    .add_legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_27_0.png" alt="png"></p>
<p><em>distplot()</em> 函数绘制了各种鸢尾花类型的<em>petal_length</em>的分布。图中蓝色代表Setosa类型鸢尾花的<em>petal_length</em>的直方图，黄色、绿色类似。y轴代表x轴上一个小窗口或者一个间隔中存在的数据点的数量，意味着在x轴上给定一个点或者区域，该点或者区域上直方图的高度代表x轴上该点或者区域有多少数据点。在上图中小窗口定义为<em>petal_length</em>。</p>
<p>直方图的高度越高，即在给定的区域内密度越大，则找到的种类和花瓣的长度值之间的对应越多。因此上图也称为<strong>概率密度图</strong>，通过对直方图进行平滑处理（KDE）制成的图像曲线为PDF，即概率密度函数曲线。</p>
<p><strong>结论：</strong></p>
<ul>
<li>如果 <code>petal_length ≤ 2</code>，种类为 Setosa；</li>
<li>如果 <code>petal_length ＞ 2</code>，并且 <code>petal_length ≤ 4.7</code>，种类为 Versicolor；</li>
<li>如果 <code>petal_length ≥ 4.7</code>，种类为 Virginica；</li>
<li>另一个结论是，通过 <code>petal_length</code> 单变量的分析，对于区分不同的鸢尾花种类很有帮助，仅仅使用这一个特征，可以构建一个使用if-else条件判定的简单模型。</li>
</ul>
<blockquote>
<p>在区分Versicolor的时候，使用了4.7作为分界点，而不是5的原因是， <code>petal_length ≤ 4.7</code>条件下，分类结果更多的可能性是Versicolor，而不是Virginica，这也和数据可视化的结果更为接近。</p>
</blockquote>
<p>当然，也可以使用<em>petal_width</em>、<em>sepal_length</em>、<em>sepal_width</em>进行单变量的分析，但是最终的结果可能并没有使用<em>petal_length</em>的结果好。</p>
<p>PDF的局限性在于，无法查看其直观的图标或者统计性数据。例如，无法根据<em>petal_length</em>单变量分析，看到<code>petal_length ＜ 5</code>的情况下，属于Versicolor类型数据的百分比等。</p>
<p>鉴于此，还需要使用CDF（累积分布函数）。</p>
<h2 id="CDF（累积分布函数）"><a href="#CDF（累积分布函数）" class="headerlink" title="CDF（累积分布函数）"></a>CDF（累积分布函数）</h2><p>累积分布函数计算给定x值的累积概率。可以使用CDF来确定从总体中抽取的随机观察值小于或者等于某个值的可能性。</p>
<p>CDF的优势在于可以通过可视化的方式查看，例如查看Setosa类型的鸢尾花，<em>petal_length</em> 小于1.6的百分比。PDF和直方图无法提供相同的确切的百分比，PDF只是分布图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need for Cumulative Distribution Function (CDF)</span></span><br><span class="line"><span class="comment"># We can visually see what percentage of setosa flowers have a</span></span><br><span class="line"><span class="comment"># petal_length of less than 1.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot CDF petal_length</span></span><br><span class="line">iris_setosa = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;setosa&#x27;</span>]</span><br><span class="line">iris_virginica = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;virginica&#x27;</span>]</span><br><span class="line">iris_versicolor = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;versicolor&#x27;</span>]</span><br><span class="line"></span><br><span class="line">counts, bin_edges = np.histogram(iris_setosa[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(pdf)</span><br><span class="line"><span class="built_in">print</span>(bin_edges)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute CDF</span></span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;PDF&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;CDF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>[0.02 0.02 0.04 0.14 0.24 0.28 0.14 0.08 0.   0.04]
[1.   1.09 1.18 1.27 1.36 1.45 1.54 1.63 1.72 1.81 1.9 ]
</code></pre>
<p><img src="/images/simple-eda/output_30_1.png" alt="png"></p>
<p>示例代码中构建了三个数据框对应三种不同的鸢尾花种类。图中x轴代表<em>petal_length</em>，y轴则是对应的累积分布概率。</p>
<p><code>cumsum()</code>函数是NumPy类库中通过PDF计算CDF的方法。</p>
<ul>
<li>假设<code>petal_length</code>的值我们关心的是1.6。对于1.6，数据中有接近82%的Setosa类型鸢尾花，<code>petal_length ≤ 1.6</code>。即意味着在总共50朵Setosa鸢尾花中，有41朵的<code>petal_length ≤ 1.6</code>；</li>
<li>根据CDF也可以得到所有Setosa鸢尾花的<code>petal_length ≤ 1.9</code>。</li>
</ul>
<h3 id="一张图中查看三种类型鸢尾花的单变量CDF"><a href="#一张图中查看三种类型鸢尾花的单变量CDF" class="headerlink" title="一张图中查看三种类型鸢尾花的单变量CDF"></a>一张图中查看三种类型鸢尾花的单变量CDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plots of CDF of petal_length for various types of flowers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Misclassification error if you use petal_length only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setosa</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_setosa[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setosa_pdf:&#x27;</span>, pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setosa_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;setosa_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;setosa_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># virginica</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_virginica[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;virginica_pdf:&#x27;</span>,pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;virginica_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;virginica_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;virginica_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># versicolor</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_versicolor[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;versicolor_pdf:&#x27;</span>,pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;versicolor_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;versicolor_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;versicolor_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>setosa_pdf: [0.02 0.02 0.04 0.14 0.24 0.28 0.14 0.08 0.   0.04]
setosa_bin_edges: [1.   1.09 1.18 1.27 1.36 1.45 1.54 1.63 1.72 1.81 1.9 ]
virginica_pdf: [0.02 0.1  0.24 0.08 0.18 0.16 0.1  0.04 0.02 0.06]
virginica_bin_edges: [4.5  4.74 4.98 5.22 5.46 5.7  5.94 6.18 6.42 6.66 6.9 ]
versicolor_pdf: [0.02 0.04 0.06 0.04 0.16 0.14 0.12 0.2  0.14 0.08]
versicolor_bin_edges: [3.   3.21 3.42 3.63 3.84 4.05 4.26 4.47 4.68 4.89 5.1 ]
</code></pre>
<p><img src="/images/simple-eda/output_32_1.png" alt="png"></p>
<p><strong>通过可视化，可以得到如下的结论：</strong></p>
<ul>
<li>如果 <code>petal_length ≤ 2</code>，则鸢尾花的类型为Setosa，并且正确率接近于100%；</li>
<li>如果 <code>petal_length ＞ 2</code>并且 <code>petal_length ≤ 5</code>：<ul>
<li><strong>鸢尾花种类为Virginica。</strong> 此结论的正确性可能只有10%，因为在<code>petal_length = 5</code>情况下，CDF的值为10，同理，再次区间判定结果有90%的错误可能；</li>
<li><strong>鸢尾花种类为Versicolor。</strong> 此结论的正确率为95%，因为在<code>petal_length = 5</code>时，Virginica的CDF值为95。</li>
</ul>
</li>
<li>当 <code>petal_length</code>位于5到7之间，并且如果在此处将一个鸢尾花的种类定为Virginica，则正确预测该种类的可能性为90%，10%的可能性为Versicolor。</li>
</ul>
<h2 id="箱须图（Box-and-Whisker-Plots）"><a href="#箱须图（Box-and-Whisker-Plots）" class="headerlink" title="箱须图（Box-and-Whisker Plots）"></a>箱须图（Box-and-Whisker Plots）</h2><p>箱形图（或箱须图）以有助于变量之间比较的方式显示定量数据的分布 Box显示数据集的四分位数，而Whisker显示其余分布。</p>
<p>箱须图是显示数据分布的一种标准化方法，该方法基于以下五个数据的摘要绘制：</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>中位数</li>
<li>第一个四分位数</li>
<li>第三个四分位数</li>
</ul>
<p>在一个简单的箱形图中，中心矩形跨越第一个四分位数到第三个四分位数（四分位数间距或IQR）。</p>
<p><strong>Box Plot</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Box-plot with whiskers: another method of visualizing the 1-D scatter plot more untuitivey.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> In the plot below, a technique call inter-quartile range is used in plotting the whiskers.</span></span><br><span class="line"><span class="comment"># Whiskers in the plot below donot correposnd to the min and max values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Box-plot can be visualized as a PDF on the side-ways.</span></span><br><span class="line"></span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;petal_length&#x27;</span>, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_35_0.png" alt="png"></p>
<p><strong>Whisker Plot</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A violin Plot combines the benefits of the previous two plots and simplifies them</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Denser regions of the data are fatter, and sparser ones thinner in a violin plot</span></span><br><span class="line"></span><br><span class="line">sns.violinplot(x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;petal_length&#x27;</span>, data=iris, size=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_37_0.png" alt="png"></p>
<h2 id="仓促的结语"><a href="#仓促的结语" class="headerlink" title="仓促的结语"></a>仓促的结语</h2><p>在本文中，粗略的对数据科学问题的前期工作—探索性数据分析，进行了简单的介绍，从中可以了解到如何进行数据的EDA，并从EDA中了解到数据的深层特性，对后续的特征抽取和建模具有非常大的意义。</p>
<blockquote>
<p>在文中，部分内容并没有深入进行介绍，与其说本文是介绍EDA，倒不如是针对EDA阶段如何一步一步的深入到数据内部的简单了解，希望对您有帮助。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.563Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.563Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></span><span class="level-item">1 小时读完 (大约10742个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2018-07-26-11-tips/">11条数据化运营不得不知的数据预处理经验（无码篇）</a></h1><div class="content"><p>数据预处理是数据化运营过程中重要的环节，直接影响着后期所有的数据工作质量和价值输出。从数据预处理的主要内容来看，包括<strong>数据清洗、转换、归约、聚合、抽样等</strong>。本文将摒弃理论和方法说教，直接介绍内容本身可能遇到的问题以及应对方法。</p>
<h2 id="3-1-数据清洗：缺失值、异常值和重复值的处理"><a href="#3-1-数据清洗：缺失值、异常值和重复值的处理" class="headerlink" title="3.1 数据清洗：缺失值、异常值和重复值的处理"></a>3.1 数据清洗：缺失值、异常值和重复值的处理</h2><ul>
<li><strong>清洗：</strong>是对数据集进行丢弃、填充、替换、去重等操作，实现去除异常、纠正错误、补足缺失的目的，实现去除数据中的异常、纠正错误、补足缺失的目的。</li>
</ul>
<h3 id="3-1-1-数据列缺失的4中处理方法"><a href="#3-1-1-数据列缺失的4中处理方法" class="headerlink" title="3.1.1 数据列缺失的4中处理方法"></a>3.1.1 数据列缺失的4中处理方法</h3><p>数据缺失分为两种：</p>
<ol>
<li>行记录的缺失，此种情况又称数据记录丢失；</li>
<li>数据列值缺失，即由于某种原因导致的数据记录中某些列的值空缺等。</li>
</ol>
<blockquote>
<p>某些少数情况下，会使用空字符串来代替缺失值，但是空字符串绝对不同于缺失值，从对象实体来看，空字符串是有实体的，实体为字符串类型，而缺失值其实是没有实体的，即没有数据类型。</p>
</blockquote>
<p>丢失的行记录通常是无法找回的，而对于列值来说，通常有四种方法或者思路来处理：</p>
<p><strong>1. 丢弃</strong></p>
<p>即直接删除带有缺失值的记录（整行删除）或者列字段（整列删除），以减少缺失记录对总体数据的影响。但是丢弃也意味着消减数据特征，在以下的场景中，不宜使用：</p>
<ul>
<li>数据集总体中存在大量的数据记录不完整情况且比例较大，例如超过数据集总体的10%，删除这些带有缺失值的记录意味着损失过多的有用信息；</li>
<li>带有缺失值的数据记录大量存在着明显的数据分布规律或特征，例如带有缺失值数据记录的目标标签主要集中在某一类或几类，如果删除这些数据记录将是对应分类的数据样本丢失大量的特征信息，导致模型过拟合或者分类不准确。</li>
</ul>
<p><strong>2. 补全</strong></p>
<p>即通过一定的方式方法将缺失的数据补上，从而形成完整的数据记录，对于后续的数据处理、分析和建模至关重要。常用的补全方法有：</p>
<ul>
<li><strong>统计法：</strong> 对于数值型的数据，通常使用均值、加权均值、中位数等方法补齐；对于分类型数据，使用类别众数最多的值补齐；</li>
<li><strong>模型法：</strong> 基于已有的其他数据，将缺失值作为目标变量进行预测，从而得到最有可能的补全值。如果带有缺失值的列是数值变量，则使用回归模型补齐，如果是分类变量，则使用分类模型补齐；</li>
<li><strong>专家法：</strong> 对于少数具有重要意义的数据记录，通过领域专家来对数据进行分析，从而进行缺失值补齐；</li>
<li><strong>其他方法：</strong> 例如随机法、特殊值法、多重填补法等。</li>
</ul>
<p><strong>3. 真值转换法</strong></p>
<p>核心思路是承认缺失值的存在，并且把数据缺失也作为数据分布规律的一部分，但是缺失值往往无法在后续的数据处理和模型中进行计算，此时需要将缺失值进行<strong>真值转换</strong>。例如用户的性别，很多数据库中无法对人员的性别进行补齐，但是此性别数据又非常的重要，因此将男、女、未知从一个变量的多值分布状态转换到多个变量的真值分布状态：</p>
<ul>
<li>转换前：性别（男、女、未知）</li>
<li>转换后：性别_男（值域1或0）、性别_女（值域1或0）、性别_未知（值域1或0）</li>
</ul>
<p>然后将这3列新的字段作为输入维度以替换原来的1个字段，参与后续的数据分析、建模计算等。</p>
<p><strong>4. 不处理</strong></p>
<p>即在数据预处理阶段，不对带有缺失值的数据记录进行任何处理。此种方式主要要看后续的数据分析和建模应用，对于缺失值的容忍度或灵活处理方式。常见的能够自动补齐缺失值的模型有：<strong>KNN、决策树、随机森林、神经网络、朴素贝叶斯和DBSCAN（基于密度的带有噪声的空间聚类模型）等</strong>，这些模型对于缺失值的处理思路是：</p>
<ul>
<li>忽略：即缺失值不参与计算（KNN）</li>
<li>将缺失值作为分布的一种状态，并参与到建模过程（决策树及其变体）</li>
<li>不基于距离做计算，因此基于值的距离做计算，本身的影响将消除（DBSCAN）</li>
</ul>
<blockquote>
<p>有时候在数据采集时，采集端针对各个字段设置了一个默认值。假设原本数据采集时没有采集到数据，字段的值将以默认值赋值，此时虽然让数据集看起来非常正常，但是本质上还是确实的，需要留心此类数据。</p>
</blockquote>
<h3 id="3-1-2-不要轻易抛弃异常数据"><a href="#3-1-2-不要轻易抛弃异常数据" class="headerlink" title="3.1.2 不要轻易抛弃异常数据"></a>3.1.2 不要轻易抛弃异常数据</h3><p>异常数据是数据分布的常态，处于特定分布区域或范围之外的数据通常被定义为异常或“噪声”。从数据异常的状态来看，所谓的数据异常分为两种：</p>
<ul>
<li><strong>伪异常：</strong> 由于业务的特定运营动作产生，是正常反应业务状态的数据，而不是数据本身的异常规律；</li>
<li><strong>真异常：</strong> 并非特定的运营动作产生，而是客观反映数据本身分布异常的个案。</li>
</ul>
<p>在实际进行数据处理的过程中，“异常数据”往往被当做噪声直接剔除，但是在以下几种情况中，无需对异常值做抛弃处理：</p>
<p><strong>1. 异常值正常反应了业务运营的结果</strong>：是特定业务动作导致的数据分布异常，如果抛弃将导致无法正确反应业务的结果；</p>
<p><strong>2. 异常检测模型</strong>：异常数据本身是目标数据，如果被处理掉，将损失关键性的信息；</p>
<p><strong>3. 包容异常值的数据建模</strong>：数据算法或建模方法对异常值不敏感，异常值对模型本身不会造成负面影响（决策树中，异常值本身可以作为一种分裂节点）。</p>
<blockquote>
<p>除了抛弃和保留，还有一种思路是对异常值使用其他的统计量、预测量进行替换，但是此类方法会将数据集中本身的关键分布特征消除，从而改变原始数据集的分布规律。</p>
</blockquote>
<h3 id="3-1-3-数据重复就需要去重吗"><a href="#3-1-3-数据重复就需要去重吗" class="headerlink" title="3.1.3 数据重复就需要去重吗"></a>3.1.3 数据重复就需要去重吗</h3><p>数据集中数据重复包含两种情况：</p>
<ol>
<li>数据值完全相同的多条数据记录；</li>
<li>数据主体相同但匹配到的唯一属性值不同</li>
</ol>
<p>去重的主要目标是保留显示特征的唯一特征记录，但是当遇到以下几种情况的时候，不建议或者慎重执行数据去重：</p>
<p><strong>1. 重复的记录用于分析演变规律</strong>：例如商品类别的归属变化，不同时间段，可能同一个商品的归属有所变化，这样在数据库中可能就有一个 <strong>变化维度表</strong>。表格的维度在不断的发生变化，而对于维度的变化，有3中不同的处理方式：</p>
<ul>
<li>直接覆盖原有值（无法保留历史信息）</li>
<li>添加新的维度行（统一ID的商品会有两条匹配记录）</li>
<li>增加新的属性列（不会改变数据行记录）</li>
</ul>
<blockquote>
<p><strong>变化维度表：</strong> 是数据仓库中的概念。维度表类似匹配表，用来存储静态的维度、属性等数据，而这些数据一般都不会发生改变。但是变与不变是一个相对的概念，随着企业的不断发展，很多的维度也会发生变化，因此在某个时间内的维度是不改变的，而整体来看维度是变化的。</p>
</blockquote>
<p><strong>2. 重复的记录用于样本不均衡处理</strong></p>
<p>样本的不均衡是影响分类模型效果的关键因素之一，解决的方法一般是对少数样本进行简单过采样，通过随机过采样采取简单复制样本的策略来增加少数类样本，而这样的处理会在数据记录中产生相同记录的多条数据，此时不能对其中的重复值执行去重操作。</p>
<p><strong>3. 重复的记录用于检测业务规则问题</strong></p>
<p>主要针对的是事务性的数据，重复数据可能意味着重大运营规则问题。此类重复的数据记录可能是由于数据采集、存储、验证和审核机制的不完善问题导致的，会直接影响到前台生产和运营系统。例如重复的订单、重复的充值、重复的预约等等。</p>
<h2 id="3-2-将分类数据和顺序数据转为标志变量"><a href="#3-2-将分类数据和顺序数据转为标志变量" class="headerlink" title="3.2 将分类数据和顺序数据转为标志变量"></a>3.2 将分类数据和顺序数据转为标志变量</h2><h3 id="3-2-1-分类数据和顺序数据是什么"><a href="#3-2-1-分类数据和顺序数据是什么" class="headerlink" title="3.2.1 分类数据和顺序数据是什么"></a>3.2.1 分类数据和顺序数据是什么</h3><p>非数值型变量通常在数据建模过程中无法处理，例如KMeans算法用于计算距离的相似度，而字符串则无法直接计算距离。此类无法直接使用的数据可以分为两大类：</p>
<ol>
<li><p>分类数据：指只能归于某一类别的非数值型数据。分类数据中的值没有明显的高低、大小等包含等级、顺序、排序、好坏等逻辑划分，只能用来区分两个或多个具有相同或者相当价值的属性。是在相同衡量维度上的不同属性而已。</p>
<ul>
<li>性别 — 男、女</li>
<li>颜色 — 红、黄、蓝</li>
</ul>
</li>
<li><p>顺序数据：指只能归于某一有序类别的非数值型数据。在顺序数据中，有明显的排序规律和逻辑层次的划分。</p>
<ul>
<li>用户价值等级 — 高、中、底</li>
<li>学历 — 学士、研究生、博士</li>
</ul>
</li>
</ol>
<h3 id="3-2-2-运用标志方法处理分类和顺序数据"><a href="#3-2-2-运用标志方法处理分类和顺序数据" class="headerlink" title="3.2.2 运用标志方法处理分类和顺序数据"></a>3.2.2 运用标志方法处理分类和顺序数据</h3><p>分类数据和顺序数据要参与建模，通常会转化为数值型数据。最佳的方法是：</p>
<p><strong>将所有分类或者顺序变量的值域从一列多值的形态转换为多列只包含真值的形态，其中真值可以使用True、False或者1、0来表示。</strong> 此类转换也被称为 <strong>真值转换</strong>。例如下表格中，第一列和第二列是原始的数据格式，性别由‘男’和‘女’来表示，第三列和第四列是经过转换后的表示。（这里为了演示，并没有在转换后去除原始的“性别”一列，在实际应用中需要在转换后去除原始列）</p>
<table>
<thead>
<tr>
<th>用户ID</th>
<th>性别</th>
<th>用户性别-男</th>
<th>用户性别-女</th>
</tr>
</thead>
<tbody><tr>
<td>35666841</td>
<td>男</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>65456567</td>
<td>女</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>65498932</td>
<td>女</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="3-3-大数据时代的数据降维"><a href="#3-3-大数据时代的数据降维" class="headerlink" title="3.3 大数据时代的数据降维"></a>3.3 大数据时代的数据降维</h2><p><strong>数据降维</strong>是降低数据的维度数量，是维度归约的一种重要课题。</p>
<h3 id="3-3-1-需要数据降维的情况"><a href="#3-3-1-需要数据降维的情况" class="headerlink" title="3.3.1 需要数据降维的情况"></a>3.3.1 需要数据降维的情况</h3><p>数据降维的主要目的是降低模型的计算量并减少模型运行事件、减低噪声变量信息对于模型结果的影响，便于通过可视化的方式展示归约后的维度信息并减少数据存储空间。是否需要进行降维主要需要考虑如下几个方面：</p>
<ol>
<li><strong>维度数量</strong>： 降维的基本前提是高维，如果只有几个维度，就不需要降维了，另外还需要衡量维度的重要性、共线性以及其他排除关系，而不是出于高维的考虑。</li>
<li><strong>建模输出是否必须保留原始维度</strong>： 当需要保留原始维度时，不能进行转换方式降维，只能选择特征筛选的方式降维。</li>
<li><strong>对模型的计算效率与建模时效性有要求</strong>： 高维数据建模时，模型的消耗将呈现几何倍数增长，造成运算效率低、耗时长。</li>
<li><strong>是否要保留完整数据特征</strong>： 当需要所有数据集的完整特征时，不需要进行降维。</li>
</ol>
<h3 id="3-3-2-基于特征选择的降维"><a href="#3-3-2-基于特征选择的降维" class="headerlink" title="3.3.2  基于特征选择的降维"></a>3.3.2  基于特征选择的降维</h3><p>基于特征选择的降维指的是根据一定规则和经验，直接选取原有维度的一部分参与到后续的计算和建模过程，用选择的维度代替所有维度，整个过程不产生新的维度。基于特征选择的降维方法有四种思路：</p>
<ul>
<li><strong>经验法</strong>： 通过领域专家的经验、对业务的理解等对特征进行选择；</li>
<li><strong>测算法</strong>： 不断测试多种维度组合的结果，最终选择最佳特征组合；</li>
<li><strong>基于统计分析的方法</strong>： 对维度之间进行相关性分析，进行人工去除或者筛选；</li>
<li><strong>机器学习算法</strong>： 通过机器学习算法得到不同特征的特征值和权重，根据权重选择特征。（例如CART决策树等）</li>
</ul>
<h3 id="3-3-3-基于维度转换的降维"><a href="#3-3-3-基于维度转换的降维" class="headerlink" title="3.3.3  基于维度转换的降维"></a>3.3.3  基于维度转换的降维</h3><p>按照一定的数据变换方法，把给定的一组相关变量（维度）通过数学模型将高维空间的数据点映射到低维空间，然后利用映射变量的特征来表示原有变量的总体特质。此种方法会产生一种新的维度，而转换后的维度并不是原始维度的本体，是综合多个维度转换或者映射后的表达式。</p>
<p>基于维度转换的降维方式，通常会使用主成分分析（PCA）来进行。而PCA主要的使用场景有：</p>
<ol>
<li><strong>非监督式的数据集</strong>： PCA是一种非监督式的降维方法，因此适用于不带有标签的数据集，对于带有标签的数据集则可以使用 <strong>LDA</strong>；</li>
<li><strong>根据方差自主控制特征数量</strong>： 最大的主成分分析的数量会小于或者等于特征的数量，也就是说PCA也可以输出完全相同数据的特征，主要取决于选择特征中解释的方差比例；</li>
<li><strong>更少的正则化处理</strong>： 选择较多的主成分分析将导致较少的平滑性，因为需要保留更多的数据特征，需要减少正则化；</li>
<li><strong>数据量较大的数据集</strong>： 包括数据记录多和数据维度多两种情况；</li>
<li><strong>数据分布是位于相同平面（非曲面），数据中存在线性结构。</strong></li>
</ol>
<h2 id="3-4-解决样本类别分布不均衡的问题"><a href="#3-4-解决样本类别分布不均衡的问题" class="headerlink" title="3.4 解决样本类别分布不均衡的问题"></a>3.4 解决样本类别分布不均衡的问题</h2><p>样本不均衡是指不同类别的样本量差异非常大。主要出现在分类问题上，从数据规模上可以分为：</p>
<ul>
<li>大数据分布不均衡：整体数据规模大，只是其中的小样本类的占比较少，但从每个特征的分布上看，小样本也覆盖了大部分或者全部的特征；</li>
<li>小数据分布不均衡：整体数据规模小，并且占据少量样本比例的分类数量也少，这会导致特征分布的严重不平衡。</li>
</ul>
<h3 id="3-4-1-哪些运营场景中容易出现样本不均衡"><a href="#3-4-1-哪些运营场景中容易出现样本不均衡" class="headerlink" title="3.4.1 哪些运营场景中容易出现样本不均衡"></a>3.4.1 哪些运营场景中容易出现样本不均衡</h3><ol>
<li><strong>异常检测场景</strong>：异常检测中，异常数据本身是少量的，例如恶意刷单、信用卡欺诈场景等；</li>
<li><strong>客户流失场景</strong>：流失客户一般相对于整体客户量而言是少量的，有其是在一些垄断行业里，例如石油、网络运营商等；</li>
<li><strong>罕见事件的分析</strong>：同样属于发生个案较少，但是不同点在于异常检测通常都有预先定义的规则和逻辑，而罕见事件则无法预判，并且通常会有明显的积极或者消极的影响；</li>
<li><strong>发生频率低的事件</strong>：属于能够预期或者计划性的时间，但是发生频率非常低，例如买彩票等。</li>
</ol>
<h3 id="3-4-2-通过过抽样和欠抽样解决样本不均衡"><a href="#3-4-2-通过过抽样和欠抽样解决样本不均衡" class="headerlink" title="3.4.2 通过过抽样和欠抽样解决样本不均衡"></a>3.4.2 通过过抽样和欠抽样解决样本不均衡</h3><p>重新抽样是解决样本不均衡相对简单的方法。</p>
<ul>
<li><strong>过采样</strong>：又称上采样（over-sampling），增加分类中少数类样本的数量来实现均衡，直接的方法是复制，高端点的方法通过少数类中加入随机造成、干扰数据或通过一定的规则产生新的合成样本，例如SMOTE算法；</li>
<li><strong>欠采样</strong>：又称下采样（under-sampling），减少分类中多数类样本的数量来实现均衡，直接的方法是随机剔除。</li>
</ul>
<h3 id="3-4-3-通过正负样本的惩罚权重解决样本不均衡"><a href="#3-4-3-通过正负样本的惩罚权重解决样本不均衡" class="headerlink" title="3.4.3 通过正负样本的惩罚权重解决样本不均衡"></a>3.4.3 通过正负样本的惩罚权重解决样本不均衡</h3><p>在算法实现的过程中，对于分类中不同样本数量的类别进行分别赋予不同的权重（一般思路分类中的小样本的类别权重较高），然后进行计算和建模。</p>
<p>现在绝大部分的算法模型库中都带有类似的权重设置参数，你可以轻松的进行权重的设置等。例如scikit-learn中的SVM，通过在<code>class_weight：&#123;dict, &#39;balanced&#39;&#125;</code>中针对不同类别设置权重来进行均衡处理。SVM中进行自动均衡的计算公式为：</p>
<p><code>n_samples  / (n_classes * np.bincount(y))</code></p>
<h3 id="3-4-4-通过组合-x2F-集成方法解决样本不均衡"><a href="#3-4-4-通过组合-x2F-集成方法解决样本不均衡" class="headerlink" title="3.4.4 通过组合&#x2F;集成方法解决样本不均衡"></a>3.4.4 通过组合&#x2F;集成方法解决样本不均衡</h3><p>在每次生成训练集时使用所有分类中的小样本量，同时从分类中的大样本量中随机抽取数据来与小样本量合并构成训练集，反复之后会得到很多训练集和训练模型，最后使用组合产生分类预测结果。</p>
<h3 id="3-4-5-通过特征选择解决样本不均衡"><a href="#3-4-5-通过特征选择解决样本不均衡" class="headerlink" title="3.4.5 通过特征选择解决样本不均衡"></a>3.4.5 通过特征选择解决样本不均衡</h3><p>一般情况下，样本不均衡也会导致特征分布不均衡，但是如果小类别样本量具有一定的规模，意味着其特征值的分布较为均衡，可通过选择具有显著性的特征配合参与解决样本不均衡问题，一定程度上能够提高模型的效果。</p>
<h2 id="3-5-如何解决运营数据源的冲突问题"><a href="#3-5-如何解决运营数据源的冲突问题" class="headerlink" title="3.5 如何解决运营数据源的冲突问题"></a>3.5 如何解决运营数据源的冲突问题</h2><ol>
<li><strong>数据类型冲突</strong>：同一数据对象的数据格式不同，常见的有时间戳、日期等；</li>
<li><strong>数据结构冲突</strong>：同一数据主体的描述结构有冲突，典型的代表是关联主键ID值由不同的逻辑结构，导致后期多源数据匹配和关联变的复杂；</li>
<li><strong>记录粒度不同</strong>：对于订单记录的粒度可以存在以订单ID为基础的一条数据中，此时多个商品同时存在商品项目列中；</li>
<li><strong>数据值域的定义不同</strong>：以订单来看，销售系统中可能包括提交订单、审核中、已审核通过、审核不通过四种状态；而库存系统中对于订单状态可能包括提交订单、审核通过、商品分拣、商品包装、商品出库、商品配送、配送成功。这些状态还仅是正常情况下的正向订单状态，即从商家发货到客户手中。几乎每个企业也都存在负向订单，通常产生于退换货的场景下，此时从会员发货到商家手中，这类的订单状态会更多；</li>
<li><strong>数据值不同</strong>：数据值的不同是数据冲突最重要也是最关键的问题所在，不同的数据源通过ETL过程大多可以解决，但若出现数据值不同的问题却难以判断到底哪份数据是正确的。</li>
</ol>
<h3 id="3-5-1-为什么会出现多数据源的冲突"><a href="#3-5-1-为什么会出现多数据源的冲突" class="headerlink" title="3.5.1 为什么会出现多数据源的冲突"></a>3.5.1 为什么会出现多数据源的冲突</h3><ol>
<li><strong>内部工具与第三方工具数据冲突</strong>：<ol>
<li>对比指标不同（广告媒体代理商与网站统计分析）</li>
<li>测量的时机不同</li>
<li>网络丢包的问题</li>
<li>去重机制的问题</li>
<li>用户中途退出问题</li>
<li>页面跟踪加载问题</li>
<li>动机导致的数据夸大</li>
<li>其他因素</li>
</ol>
</li>
<li><strong>内部同一个业务主体的同一类数据工具的数据测量冲突</strong><ol>
<li>指标定义不同</li>
<li>采集逻辑不同</li>
<li>系统过滤规则不同</li>
<li>更新时间不同</li>
<li>监测位置不同</li>
</ol>
</li>
<li><strong>内部同一个业务主体的不同数据工具的数据测量冲突</strong><ol>
<li>订单来源差异</li>
<li>特殊商品订单跟踪</li>
<li>订单状态差异</li>
<li>数据同步问题</li>
<li>内部系统拆单问题</li>
</ol>
</li>
</ol>
<h3 id="3-5-2-如何应对多数据源的冲突问题"><a href="#3-5-2-如何应对多数据源的冲突问题" class="headerlink" title="3.5.2 如何应对多数据源的冲突问题"></a>3.5.2 如何应对多数据源的冲突问题</h3><ol>
<li><strong>消除冲突并形成一份唯一数据</strong>：全量数据的汇总统计工作等；</li>
<li><strong>不消除冲突也不作任何处理</strong>：使用细粒度的数据进行数据建模等；</li>
<li><strong>不消除冲突但是使用全部冲突数据</strong>： 进行流程性统计分析等。</li>
</ol>
<blockquote>
<p>不消除冲突的情况下，也需要谨慎的对待这种情况，一般情况下，需要关注两方面内容：</p>
</blockquote>
<blockquote>
<ol>
<li><strong>差异性</strong>： 对于相同实体在相同逻辑下的数据冲突（差异）应该在5%以内，条件允许时可放宽到10%，超过则需要严格对待冲突问题；</li>
<li><strong>稳定性</strong>： 当冲突无法消除时，需要确保多数据源数据的差异性相对稳定，不能出现差异变更甚至相反分布的情况。</li>
</ol>
</blockquote>
<h2 id="3-6-数据化运营要抽样还是全量数据"><a href="#3-6-数据化运营要抽样还是全量数据" class="headerlink" title="3.6 数据化运营要抽样还是全量数据"></a>3.6 数据化运营要抽样还是全量数据</h2><p>抽样是从整体样本中通过一定的方法选择一部分样本，抽样是雏菊处理的基本步骤之一，也是科学实验、质量检测、社会调查等普遍使用的一种经济有效的工作方法。</p>
<h3 id="3-6-1-什么时候需要抽样"><a href="#3-6-1-什么时候需要抽样" class="headerlink" title="3.6.1 什么时候需要抽样"></a>3.6.1 什么时候需要抽样</h3><ol>
<li>数据计算资源不足</li>
<li>数据采集限制</li>
<li>时效性要求</li>
</ol>
<p>应该使用抽样的方法来解决具体问题的场景：</p>
<ul>
<li>通过抽样实现快速的概念验证</li>
<li>通过抽样来解决样本不平衡问题</li>
<li>无法实现对全部样本覆盖的数据化运营场景</li>
<li>定性分析的工作需要</li>
</ul>
<h3 id="3-6-2-如何进行抽样"><a href="#3-6-2-如何进行抽样" class="headerlink" title="3.6.2 如何进行抽样"></a>3.6.2 如何进行抽样</h3><p>抽样从整体上分为 <strong>非概率抽样</strong> 和 <strong>概率抽样</strong> 两种。非概率抽样不是按照等概率的原则进行抽样，而是根据人类的主观经验和状态进行判断；概率抽样则是以数学概率论为基础，按照随机的原则进行抽样，一般概率抽样分为如下几种：</p>
<ol>
<li>简单随机抽样：适用于个体分布均匀的场景</li>
<li>等距抽样：适用于个体分布均匀或呈现明显的均匀分布规律，无明显趋势或周期性规律的数据</li>
<li>分层抽样：适用于带有分类逻辑的属性、标签等特征的数据</li>
<li>整群抽样：适用于小群体集的特征差异较小，并且对划分小群体集有更高的要求</li>
</ol>
<h3 id="3-6-3-抽样需要注意的几个问题"><a href="#3-6-3-抽样需要注意的几个问题" class="headerlink" title="3.6.3 抽样需要注意的几个问题"></a>3.6.3 抽样需要注意的几个问题</h3><p><strong>1. 数据抽样要能反映运营背景</strong></p>
<p>数据能正确反映运营背景，但实际上此过程需要数据工作者对于运营环节和流程非常熟悉才可。</p>
<p>以下是常见的抽样不能反映运营背景的情况：</p>
<ul>
<li>数据时效性问题：使用合适时间段的数据，而非历史久远的数据</li>
<li>缺少关键因素数据：没有运营活动的关键性数据</li>
<li>不具备业务随机性：抽样后的数据只能反映某一种特定的数据场景</li>
<li>没有考虑业务增长性：企业在成长，数据也应该有所变化</li>
<li>没有考虑数据来源的多样性：不能只选择某一个来源的数据</li>
<li>业务数据可行性问题：根据运营实际情况调整数据工作</li>
</ul>
<p><strong>2. 数据抽样要能满足数据分析和建模要求</strong></p>
<p>数据抽样要注意一下几个方面：</p>
<ol>
<li>抽样样本量的问题<ul>
<li>以时间为维度分布的，至少要包含一个能满足预测的完整业务周期；</li>
<li>做预测（包含分类和回归）分析建模的，需要考虑特征数量和特征值域的分布，通常数据记录数要同时是特征数量和特征值域的100倍以上；</li>
<li>做关联规则分析建模的，根据关联前后项的数量（每个前项和后项可包含多个要关联的主体），每个主体需要至少1000条数据；</li>
<li>对于异常检测类分析建模的，无论是监督式还是无监督式建模，由于异常数据本来就是小概率分布的，因此异常数据记录一般越多越好。</li>
</ul>
</li>
<li>抽样样本在不同类别中的分布问题</li>
</ol>
<ul>
<li><p>抽样样本能准确代表全部整体特性：</p>
<ul>
<li>非数值型的特征值域（例如各值频数相对比例、值域范围等）分布需要和总体一致；</li>
<li>数值型特征的数据分布区间和各个统计值（如均值、方差、偏度等）需要与整体数据分布区间一致；</li>
<li>缺失值、异常值、重复值等特殊数据的分布要与整体数据分布一致。</li>
</ul>
</li>
<li><p>异常检测类数据的处理：</p>
<ul>
<li>对于异常检测类的应用要包含全部异常样本；</li>
<li>对于需要去除业务因素的数据异常，如果有类别特征需要跟类别特征分布一致；如果没有类别特征，属于无监督式学习，则需要和整体分布一致。</li>
</ul>
</li>
</ul>
<h2 id="3-7-解决运营数据的共线性问题"><a href="#3-7-解决运营数据的共线性问题" class="headerlink" title="3.7 解决运营数据的共线性问题"></a>3.7 解决运营数据的共线性问题</h2><p>所谓<strong>共线性</strong>（又称为多重共线性）问题是指输入的自变量之间存在较高的线性相关度。会导致回归模型的稳定性和准确性大大下降，过多共线性的维度参与计算会浪费计算资源和时间。</p>
<p>常见的具有明显的共线性的维度或者变量包括：</p>
<ul>
<li>访问量和页面浏览量</li>
<li>页面浏览量和访问时间</li>
<li>订单量和销售额</li>
<li>订单量和转化率</li>
<li>促销费用和销售额</li>
<li>网络展示广告费用和访客数</li>
</ul>
<p>导致出现变量之间共线性的原因包括：</p>
<ul>
<li>数据样本不够，可能导致共线性存在偶然性（数据不够）</li>
<li>多个变量都基于时间有共同或者相反的演变趋势（双11的网络销售额比平时有上升趋势）</li>
<li>多个变量间存在一定的推移关系，但是总体上变量间的趋势一致，只是发生在时间点不一致（广告曝光后才会出现销售额）</li>
<li>多个变量间存在近似线性关系（访客数y，广告费x，关系可能是 y &#x3D; 2 * x + b）</li>
</ul>
<h3 id="3-7-1-如何检测共线性"><a href="#3-7-1-如何检测共线性" class="headerlink" title="3.7.1 如何检测共线性"></a>3.7.1 如何检测共线性</h3><p>共线性一般通过容忍度、方差膨胀因子、特征值这几个特征数据来做判断：</p>
<ul>
<li>容忍度（Tolerance）：是每个自变量作为因变量对其他自变量进行回归建模时得到的残差比例，大小用1减得到的决定系数来表示。容忍度的值介于0.1和1之间，越小说明这个自变量与其他自变量间越可能存在共线性问题；</li>
<li>方差膨胀因子（Variance Inflation Factor, VIF）: VIF是容忍度的倒数，值越大则共线性问题越明显，通常以10作为判断边界。当VIF&lt;10，不存在多重共线性，当10≤VIF&lt;100，存在较强的多重共线性，VIF≥100，存在严重多重共线性；</li>
<li>特征值（Eigenvalue）：对自变量进行主成分分析，如果多个维度的特征值等于0，则可能有比较严重的共线性。</li>
</ul>
<h3 id="3-7-2-解决共线性的5中常用方法"><a href="#3-7-2-解决共线性的5中常用方法" class="headerlink" title="3.7.2 解决共线性的5中常用方法"></a>3.7.2 解决共线性的5中常用方法</h3><ol>
<li><strong>增大样本量（huge samples）</strong>：可以减低共线性问题，但是不一定会解决</li>
<li><strong>岭回归法（Ridge Regression）</strong>：放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价来获得更实际和可靠性更强的回归系数</li>
<li><strong>逐步回归法（Stepwise Regression）</strong>：每次引入一个自变量并进行统计检验，然后逐步引入其他变量，同时对所有变量的回归系数进行检验。如果改变不在显著，则剔除</li>
<li><strong>主成分回归（Principal Components Regression）</strong>：通过PCA将参与建模的变量转换为少数几个主成分，每个成分是原来变量的线性组合，再进行回归分析</li>
<li><strong>人工去除</strong>：直接结合人工经验，对参与回归模型的变量进行剔除</li>
</ol>
<h2 id="3-8-有关相关性分析的混沌"><a href="#3-8-有关相关性分析的混沌" class="headerlink" title="3.8 有关相关性分析的混沌"></a>3.8 有关相关性分析的混沌</h2><p>相关性分析是指对多个具备相关关系的变量进行分析，从而衡量变量间的相关程度或者密切程度。相关性用 <strong>R（相关系数）</strong> 表示，取值范围 <code>[-1, 1]</code>。</p>
<h3 id="3-8-1-相关和因果是一回事吗"><a href="#3-8-1-相关和因果是一回事吗" class="headerlink" title="3.8.1 相关和因果是一回事吗"></a>3.8.1 相关和因果是一回事吗</h3><p>相关性不等于因果，用 <code>x1</code> 和 <code>x2</code> 作为两个变量进行解释，相关意味着 <code>x1</code> 和 <code>x2</code> 是逻辑上的并列相关关系，而因果关系可解释为应为 <code>x1</code> 所以 <code>x2</code>的逻辑关系。相关性不是用来分析 “为什么”，而是知道 “是什么”。</p>
<h3 id="3-8-2-相关系数低就是不相关吗"><a href="#3-8-2-相关系数低就是不相关吗" class="headerlink" title="3.8.2 相关系数低就是不相关吗"></a>3.8.2 相关系数低就是不相关吗</h3><p><strong>R</strong> 的趋势是可以为负数的，但是负数并不代表相关性低，而是代表两个变量的增长趋势是相反的，因此要看 <strong>R</strong> 的绝对值来判断相关性的强弱的。</p>
<h2 id="3-9-标准化，让运营数据落入相同的范围"><a href="#3-9-标准化，让运营数据落入相同的范围" class="headerlink" title="3.9 标准化，让运营数据落入相同的范围"></a>3.9 标准化，让运营数据落入相同的范围</h2><p>标准化是一个常用的数据预处理操作，目的是处理不同规模和量纲的数据，使其缩放到相同的数据区间和范围，以减少规模、特征、分布差异等对模型的影响。</p>
<h3 id="3-9-1-实现中心化和整正态分布的Z-Score"><a href="#3-9-1-实现中心化和整正态分布的Z-Score" class="headerlink" title="3.9.1 实现中心化和整正态分布的Z-Score"></a>3.9.1 实现中心化和整正态分布的Z-Score</h3><p>Z-Score 标准化是基于原始数据的均值和标准差进行的标准化，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = （x - mean） / std</code>，其中mean和std是x所在列的均值和标准差。Z-Score方法是一种中心化方法，会改变原有数据的分布结构，不适合用于对稀疏数据做处理。</p>
<h3 id="3-9-2-实现归一化的Max-Min"><a href="#3-9-2-实现归一化的Max-Min" class="headerlink" title="3.9.2 实现归一化的Max-Min"></a>3.9.2 实现归一化的Max-Min</h3><p>Max-Min标准化是对原始数据进行线性变换，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = （x - min） / (max - min)</code>，其中min和max为x所在列的最小值和最大值。Max-Min方法能够使数据归一化而落入一定区间内，同时还能较好保持原有数据的结构。</p>
<h3 id="3-9-3-用于稀疏数据的MaxAbs"><a href="#3-9-3-用于稀疏数据的MaxAbs" class="headerlink" title="3.9.3 用于稀疏数据的MaxAbs"></a>3.9.3 用于稀疏数据的MaxAbs</h3><p>最大值绝对值标准化即根据最大值的绝对值进行标准化，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = x / \max\</code>，其中max为x所在列的最大值。MaxAbs的数据区间为[-1， 1]，不会破坏原有数据分布结构的特点，因此也可以用于稀疏数据、稀疏的CSR或CSC矩阵。</p>
<blockquote>
<p>CSR（Compressed Sparse Row, 行压缩）、CSC（Compressed Sparse Column，列压缩）</p>
</blockquote>
<h3 id="3-9-4-针对离群点的RobustScaler"><a href="#3-9-4-针对离群点的RobustScaler" class="headerlink" title="3.9.4 针对离群点的RobustScaler"></a>3.9.4 针对离群点的RobustScaler</h3><p>某些情况下，假设数据集中有离群点，可以使用Z-Score进行标准化，但是标准化后的数据不理想，因为异常点的特征往往在标准化之后容易失去离群特点，此时可以使用RobustScaler针对离群点做标准化处理。</p>
<h2 id="3-10-离散化，对运营数据做逻辑分层"><a href="#3-10-离散化，对运营数据做逻辑分层" class="headerlink" title="3.10 离散化，对运营数据做逻辑分层"></a>3.10 离散化，对运营数据做逻辑分层</h2><p>所谓离散化，就是把无限空间中有限的个体映射到有限的空间中。大多数是对连续性数据进行，处理后的数据值域分布将从连续属性变为离散属性。离散化处理的必要性有：</p>
<ul>
<li><strong>节约计算资源，提高计算效率</strong></li>
<li><strong>算法模型（尤其是分类模型）的计算需要</strong>（例如决策树模型本身支持输入连续性数据，但是会将连续性数据转化为离散化数据）</li>
<li><strong>增强模型的稳定性和准确度</strong>（离散化后，异常数据会被划分为一个子集中的一部分，对模型的影响大大降低，尤其是基于距离计算的模型，K均值、协同过滤等）</li>
<li><strong>特定数据处理和分析的必要步骤，尤其在图像处理方面应用广泛</strong>（二值化也是离散化的一种）</li>
<li><strong>模型结果应用和部署的需要</strong></li>
</ul>
<h3 id="3-10-1-针对时间数据的离散化"><a href="#3-10-1-针对时间数据的离散化" class="headerlink" title="3.10.1 针对时间数据的离散化"></a>3.10.1 针对时间数据的离散化</h3><p>主要用于以时间为主要特征的数据集和粒度转换，离散化处理后将分散的时间特征转换为更高层次的时间特征。常见的针对时间数据的离散化操作分为两类：</p>
<ol>
<li>针对一天中的时间离散化：一般是将时间戳转换为时、分、秒或者上午、下午、晚上等</li>
<li>针对日粒度以上数据的离散化：一般是将日期转换为周数、周几、月、工作日或者休息日、季度、年等</li>
</ol>
<p>针对时间数据的离散化可以将细粒度的时间序列数据离散化为粗粒度的三类数据：</p>
<ol>
<li><strong>离散化为分类数据</strong>：例如上午、下午</li>
<li><strong>离散化为顺序数据</strong>：例如周一、周二、周三</li>
<li><strong>离散化为数值型数据</strong>：例如一年有52周，周数就是数值型的数据</li>
</ol>
<h3 id="3-10-2-针对多值离散数据的离散化"><a href="#3-10-2-针对多值离散数据的离散化" class="headerlink" title="3.10.2 针对多值离散数据的离散化"></a>3.10.2 针对多值离散数据的离散化</h3><p>多值离散数据的离散化是指要进行离散化处理的数据本身不是数值型数据，而是分类或者顺序数据。</p>
<p>例如用户活跃度变量的值，原来为高、中、低三个类别，但是由于业务的变化，新的用户活跃度变量需要高、中、低、负四个类别，此时就需要对不同类别的数据进行统一规则的离散化处理。</p>
<h3 id="3-10-3-针对连续数据的离散化"><a href="#3-10-3-针对连续数据的离散化" class="headerlink" title="3.10.3 针对连续数据的离散化"></a>3.10.3 针对连续数据的离散化</h3><p>此类离散化是主要的离散化应用，在分类或者关联分析中应用广泛，此类算法的结果是以类别或者属性标识为基础，而非数值型标记。连续数据的离散化结果可以分为两类：</p>
<ol>
<li>将连续数据划分为特定区间的集合</li>
<li>将连续数据划分为特定类</li>
</ol>
<p>常用实现针对连续数据离散化的方法包括：</p>
<ul>
<li><strong>分位数法</strong>：使用四分位、五分位、十分位等分位数进行离散化处理</li>
<li><strong>距离区间法</strong>：等距区间或者自定义区间进行离散化</li>
<li><strong>频率区间法</strong>：按照不同数据的频率分布进行排序，再按照等频率或者指定频率离散化（会改变原有数据的分布状态）</li>
<li><strong>聚类法</strong>：使用K均值将样本集分为多个离散化的簇</li>
<li><strong>卡方</strong>：基于卡方的离散化方法，找出数据的最佳临近区间并合并，形成较大的区间。</li>
</ul>
<h3 id="3-10-4-针对连续数据的二值化"><a href="#3-10-4-针对连续数据的二值化" class="headerlink" title="3.10.4 针对连续数据的二值化"></a>3.10.4 针对连续数据的二值化</h3><p>二值化是指对每个数据点跟阈值进行比较，大于阈值设置为某一固定值，小于阈值设置为某一固定值，然后得到一个只拥有两个值域的二值化数据集。</p>
<p>二值化应用的前提是数据集中所有的属性值所代表的含义相同或类似。</p>
<h2 id="3-11-数据处理应该考虑哪些运营业务因素"><a href="#3-11-数据处理应该考虑哪些运营业务因素" class="headerlink" title="3.11 数据处理应该考虑哪些运营业务因素"></a>3.11 数据处理应该考虑哪些运营业务因素</h2><p>数据处理工作不仅依赖于数据工作者的经验，也需要考虑实际的运营业务因素。数据处理时应该考虑的运营业务因素包括固定和突发运营周期、运营需求的有效性、交付时要贴合运营落地场景、专家经验、业务需求等变动因素。</p>
<h3 id="3-11-1-考虑固定和突发运营周期"><a href="#3-11-1-考虑固定和突发运营周期" class="headerlink" title="3.11.1 考虑固定和突发运营周期"></a>3.11.1 考虑固定和突发运营周期</h3><p>运营周期的属性主要表现在两个方面：</p>
<ol>
<li><strong>有计划的周期性</strong></li>
<li><strong>临时或突发周期</strong></li>
</ol>
<p>运营业务的周期性对数据的影响：</p>
<ul>
<li>有计划的周期在数据的选取和分析过程中非常重要，尤其涉及对比时，选对具有相同属性的对比周期是形成结论的基础</li>
<li>有计划的运营周期对于时间序列特征明显的建模影响较大，包括时间序列、时序关联、隐马尔可夫模型等</li>
<li>不同周期下产生的数据可能有差异，尤其是对于高速发展的新型公司，不同周期下的数据可能带有明显的线性、指数、二项式以及其他变化特征，甚至可能带有业务因素导致的异常数据点</li>
<li>运营过程中可能产生突发的数据工作需求</li>
<li>数据工作的整个过程需要运营业务人员参与，而依赖于运营业务人员参与的时机以及对应的方式和切入点也很重要。</li>
</ul>
<h3 id="3-11-2-考虑运营需求的有效性"><a href="#3-11-2-考虑运营需求的有效性" class="headerlink" title="3.11.2 考虑运营需求的有效性"></a>3.11.2 考虑运营需求的有效性</h3><p>数据工作者可以对某些需求做拒绝或者延迟处理，主要原因如下：</p>
<ol>
<li><strong>缺少数据</strong></li>
<li><strong>需求不合理</strong></li>
<li><strong>条件限制</strong></li>
<li><strong>资源限制</strong></li>
<li><strong>低价值需求</strong></li>
</ol>
<h3 id="3-11-3-考虑交付时要贴合运营落地场景"><a href="#3-11-3-考虑交付时要贴合运营落地场景" class="headerlink" title="3.11.3 考虑交付时要贴合运营落地场景"></a>3.11.3 考虑交付时要贴合运营落地场景</h3><p>数据处理工作虽然只是中间过程，并没有到达数据分析、建模、部署和应用的阶段，但是该阶段的很多工作会直接影响后期的交付和运营落地，典型因素如下：</p>
<ol>
<li><strong>维持原有指标</strong></li>
<li><strong>更容易理解的算法限制</strong></li>
<li><strong>数据生产和应用环境</strong></li>
</ol>
<h3 id="3-11-4-不要忽视业务专家的经验"><a href="#3-11-4-不要忽视业务专家的经验" class="headerlink" title="3.11.4 不要忽视业务专家的经验"></a>3.11.4 不要忽视业务专家的经验</h3><p>业务专家经验在数据处理工作中的重要作用体现在一下两个方面：</p>
<ol>
<li><strong>数据工作方向</strong>：专家经验会决定需要做什么、产出是什么、中间的过程应该向哪个方向考虑，侧重于“是什么”。直接影响着：<ul>
<li>数据项目工作目标和需求</li>
<li>数据探索和摸底方向</li>
<li>数据交付物的形式和规格</li>
</ul>
</li>
<li><strong>数据工作逻辑</strong>：专家经验可以提出有价值的参考和工作建议，侧重于“怎么做”，直接影响着：<ul>
<li>总体数据周期、规则、条件等的选取</li>
<li>数据抽样规则，有其涉及到分层、整群抽样</li>
<li>多数据的整合、匹配和关联关系</li>
<li>不同数据源和数据间的清洗、转换逻辑</li>
<li>重复值、异常值和缺失值的处理逻辑</li>
<li>数据离散化的方法选择和区间定义</li>
<li>根据变量重要性进行数据变量的选取和降维</li>
<li>数据算法和模型选择</li>
<li>数据模型的调整、评估和优化</li>
</ul>
</li>
</ol>
<h3 id="3-11-5-考虑业务需求的变动因素"><a href="#3-11-5-考虑业务需求的变动因素" class="headerlink" title="3.11.5 考虑业务需求的变动因素"></a>3.11.5 考虑业务需求的变动因素</h3><p>为了最小程度的降低业务的变动给数据工作带来困惑，甚至失败，应该提前做好如下几个准备：</p>
<ol>
<li><strong>充分、有效的沟通</strong></li>
<li><strong>更完整、更原始的数据集</strong></li>
<li><strong>可理解性强、规则清晰的算法和模型</strong></li>
<li><strong>模块化工作方法</strong></li>
<li><strong>建立数据工作流程和机制</strong></li>
</ol>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T12:55:38.000Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2022-04-30-log-md/">2022-04-30</a></p><p class="categories"><a href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">每日随想</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.804Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2018-08-28-coreml-vs-mlkit/">Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.803Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2020-07-13-iOS-memory-manager/">Runtime剖析05 --- 再议iOS内存管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.802Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-09-07-machine-learning-feature/">机器学习与移动应用开发的未来</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.801Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-08-31-mind-flower/">思维的火花 --- 大数据与数据思维</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">Swift中的数据结构与算法</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"><span class="tag">开发知识 iOS</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">开发知识 技术人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">技术人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F-%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"><span class="tag">技术人生 读书计划</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-Python/"><span class="tag">数据科学 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"><span class="tag">机器学习 Keras MNIST</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-MFCC/"><span class="tag">机器学习 MFCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python/"><span class="tag">机器学习 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97-CoreML/"><span class="tag">端测计算 CoreML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>