<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: Data Structures &amp; Algorithms in Swift - Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Data Structures &amp; Algorithms in Swift</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/7/cover.jpeg" alt="\#7\ Stack &amp; Stack Simple Challenges"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1820个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/">\#7\ Stack &amp; Stack Simple Challenges</a></h1><div class="content"><p><strong>栈（Stack）</strong>是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属于一种受限的线性表结构。栈的操作特性通常被称为**后进先出(LIFO-last in first out)<strong>的方式，另一种数据结构队列的操作特性与栈有着不同，通常称为</strong>先进先出(FIFO-first in first out)**。</p>
<h2 id="栈的一般操作"><a href="#栈的一般操作" class="headerlink" title="栈的一般操作"></a>栈的一般操作</h2><p>栈是一种很有用，但是相对简单的数据结构。构建栈类型数据结构的主要目标是数据的访问权限和方式问题。相比于链表而言，栈并没有链表那个复杂和琐碎。</p>
<p>对于栈来说，主要的操作有两个，即上述所说的<strong>压栈</strong>和<strong>出栈</strong>的操作：</p>
<ul>
<li><strong>push：</strong>添加一个元素到栈顶；</li>
<li><strong>pop：</strong>从栈顶删除一个元素</li>
</ul>
<p>也就是说，对于栈而言，只能从栈的一边添加或者移除元素，也就是上述所说的**后进先出(LIFO-last in first out)**的方式。在计算机编程中，栈的身影无处不在，例如下面几个场景中，都是栈的理念和其应用的结果：</p>
<ul>
<li>在iOS中,导航控制器的作用是将视图控制器的视图弹出或者弹入，并且最新弹出的总是最后弹入的视图控制器视图；</li>
<li>内存分配在体系结构级别使用堆栈。局部变量的内存也使用堆栈进行管理；</li>
<li>Search和conquer算法，例如从迷宫中寻找路径，均使用堆栈来方便回溯。</li>
</ul>
<h2 id="栈数据结构实现"><a href="#栈数据结构实现" class="headerlink" title="栈数据结构实现"></a>栈数据结构实现</h2><p>首先定义栈的基础结构，对于栈而言，其核心就是一个列表，只是再具体的操作时有LIFO的限制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> topDivider <span class="operator">=</span> <span class="string">&quot;---- top ----<span class="subst">\n</span>&quot;</span></span><br><span class="line">        <span class="keyword">let</span> bottomDivider <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span> -----------&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> stackElements <span class="operator">=</span> storage</span><br><span class="line">            .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span> &#125;</span><br><span class="line">            .reversed()</span><br><span class="line">            .joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> topDivider <span class="operator">+</span> stackElements <span class="operator">+</span> bottomDivider</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在栈的数据结构中使用列表的方式进行数据存储，是因为对于列表来说，在其一端进行操作 — <strong>append</strong> 和<strong>popLast</strong>，都属于恒定时间的复杂度O(1)。也更是促进了栈的进栈和出栈特性的性能表现。</p>
<h2 id="push-amp-pop-操作"><a href="#push-amp-pop-操作" class="headerlink" title="push &amp; pop 操作"></a>push &amp; pop 操作</h2><p>在栈的数据结构定义中，增加基本的压栈和出栈操作，压栈操作直接使用列表的<strong>append</strong>，出栈使用<strong>popLast</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">    storage.append(element)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.popLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个基本操作来说，实现也非常直截了当。接下来对其进行实际测试，在主Playground中，进行测试代码编写。</p>
<blockquote>
<p>在进行测试前，可以将<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/03/Data-Structures-&-Algorithms-in-Swift-04.html">\#4\ Linked List 的Swift实现
</a>中的<strong>Helper.swift</strong>拷贝到当前工程中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;using a stack&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">4</span> <span class="operator">==</span> poppedElement)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">---Example of using a stack---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展性操作"><a href="#扩展性操作" class="headerlink" title="扩展性操作"></a>扩展性操作</h2><p>对于栈来说，除了常用的push和pop操作之外，还有一些额外的操作，能够提高对栈的使用等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.last</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// isEmpty</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> peek() <span class="operator">==</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>peek()：</strong>获取栈顶元素</li>
<li><strong>isEmpty：</strong>判断栈是否为空</li>
</ul>
<h2 id="Less-is-more"><a href="#Less-is-more" class="headerlink" title="Less is more"></a>Less is more</h2><p>在链表的实现中，我们使用了Swift标准库中的Collection协议，那么在栈的实现中是否也能够使用Collection协议呢？栈的目的是有限制的访问数据，通过迭代或者下标的方式即可实现该目标，但是对于Collection协议来说，并不止于此，因此在栈上使用Collection协议和栈的最初目标是相互制约的。在这种情况下，少即是多！</p>
<p>您可能希望采用现有数组并将其转换为栈，以便保证访问顺序，也可以循环遍历数组元素以及添加元素。对于栈来说，为了能够对栈的操作有一个统一的初始化存储方式，可以定义其初始化方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">elements</span>: [<span class="type">Element</span>]) &#123;</span><br><span class="line">    storage <span class="operator">=</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from a array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>(array)</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from a array---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述实现中，将一个数组转化为了栈，并且栈中元素的数据类型是String，也就意味着栈中可以放置多种类型的数据元素。</p>
<p>既然可以使用数组直接转化为栈，那么是否可以直接使用数组的方式初始化栈呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">ExpressibleByArrayLiteral</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">arrayLiteral</span> <span class="params">elements</span>: <span class="type">Element</span>...) &#123;</span><br><span class="line">        storage <span class="operator">=</span> elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from an array literal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack: <span class="type">Stack</span> <span class="operator">=</span> [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>]</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from an array literal---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4.0</span></span><br><span class="line"><span class="comment">3.0</span></span><br><span class="line"><span class="comment">2.0</span></span><br><span class="line"><span class="comment">1.0</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在搜索树和图的问题求解中，栈至关重要。例如在查找迷宫的路径方法中，每次叨叨左、右、前或后的决策点时，都可以将所有可能的决策点压入栈中，当栈顶的路径是一个死胡同时，只需要从栈中弹出并继续下一个判断，直到走出迷宫即可。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>栈的数据结构虽然非常简单，但栈是解决很多问题的关键性数据结构；</li>
<li>对于栈爱说，只有两个基本操作，分别是压栈<strong>push</strong>和出栈<strong>pop</strong>。</li>
</ul>
<h2 id="栈的挑战"><a href="#栈的挑战" class="headerlink" title="栈的挑战"></a>栈的挑战</h2><h2 id="Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。"><a href="#Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。" class="headerlink" title="Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。"></a>Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。</h2><blockquote>
<p>在<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/05/Data-Structures-&-Algorithms-in-Swift-06.html">\#6\ Linked List 挑战</a>中我们使用了递归的方式，反向打印了一个链表的节点。在这里将使用栈的结构进行，避免递归调用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverseNoRecursion</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> current &#123;</span><br><span class="line">        stack.push(node.value)</span><br><span class="line">        current <span class="operator">=</span> node.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> value <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Print Linkedlist reverse without recursion&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverseNoRecursion(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Print Linkedlist reverse without recursion---</span></span><br><span class="line"><span class="comment">Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">Printing in reverse: </span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如："><a href="#Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如：" class="headerlink" title="Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 （ 和 ） 字符，如果字符串中的括号是平衡的，则返回 true。例如："></a>Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 <code>（</code> 和 <code>）</code> 字符，如果字符串中的括号是平衡的，则返回 <code>true</code>。例如：</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1 h((e))llo(world)() // balanced parentheses</span><br><span class="line"></span><br><span class="line">// 2 (hello world // unbalanced parentheses</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkParentheses</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> string &#123;</span><br><span class="line">        <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;(&quot;</span> &#123;</span><br><span class="line">            stack.push(character)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;)&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> stack.isEmpty &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;check parentheses&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> <span class="string">&quot;h((e))llo(world)())&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> checkParentheses(string)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of check parentheses---</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-02-Data-Structures-&amp;-Algorithms-in-Swift-03/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/3/cover.jpg" alt="\#3\ 关于时间复杂度和大O符号"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">23 分钟读完 (大约3431个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-02-Data-Structures-&amp;-Algorithms-in-Swift-03/">\#3\ 关于时间复杂度和大O符号</a></h1><div class="content"><p>算法复杂度的衡量问题在软件开发的诞生早起就已经被提出来，并且有多个方面具体的问题。例如，从系统的架构来看，可伸缩性的架构设计和算法实现，应用程序是如何在数据特征增加的情况下被合理有效地激活的；从数据库的角度来看，数据库的处理能力是否能够应对越来越多的数据和用户行为等。</p>
<p>对于算法而言，可伸缩性指的是算法是否能够随着输入体量的变化，算法在执行时间和内存使用上的变现。</p>
<p>当你面对的是小体量的数据输入时，算法可能运行良好，执行快速，内存使用良好。但是随着数据输入体量的增加，算法的表现可能越来越糟糕，但是具体有多糟糕呢？掌握如何衡量一个算法的优劣是程序开发者的一项重要的技能。</p>
<p>在本篇内容中，我们将从两个角度 — 时间维度和内存使用维度 观察算法的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>问题。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>对于小体量的数据来说，大多数的既定算法能够即快速且高效地在目标设备环境中执行，但是随着数据量的增大、业务逻辑的变化，算法的表现可能会越来越差。<strong>时间复杂度（Time complexity）</strong>是衡量一个算法随着输入大小的改变，其运行耗时的衡量标准，时间复杂度本质上是一个函数，一个关于输入大小和耗时之间的相关性模型。</p>
<h3 id="恒定时间复杂度"><a href="#恒定时间复杂度" class="headerlink" title="恒定时间复杂度"></a>恒定时间复杂度</h3><p><strong>恒定时间</strong>复杂度指的是，算法的执行耗时并不会随着输入体量的改变而改变。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkFirst</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> first <span class="operator">=</span> names.first &#123;</span><br><span class="line">        <span class="built_in">print</span>(first)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no names&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述函数来说，输入<code>names</code>的大小并不会影响该函数的执行时间，无论<code>names</code>中有10个元素还是10万个元素，该函数仅仅检查数组中的第一个元素。对于恒定时间复杂度的算法来说，其时间复杂度可视化后如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/contant-time.png"></p>
<p>在程序员的时间，通常使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>来表示一个算法的时间复杂度，对于恒定时间复杂度的算法，表示为**O(1)**。</p>
<h3 id="线性时间复杂度"><a href="#线性时间复杂度" class="headerlink" title="线性时间复杂度"></a>线性时间复杂度</h3><p>假设有如下的一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printNames</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数打印字符串数组中的每一个元素。随着输入体量的增加，<code>for</code>循环的次数也随之增加，并且两者之间呈现线性的关系。线性时间复杂度的图像可表示为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/linear-time.png"></p>
<p>线性时间复杂度相对较为简单且易于理解。当输入的数据体量增大时，算法的执行耗时会同时增加，这也是其图像是一条直线的原因。对于线性时间复杂度的算法，大O符号表示为**O(n)**。</p>
<h3 id="二次时间复杂度"><a href="#二次时间复杂度" class="headerlink" title="二次时间复杂度"></a>二次时间复杂度</h3><p><strong>二次时间复杂度</strong>通常也被称为<strong>n平方时间复杂度</strong>，是指算法的执行耗时随着输入体量的增加而呈现二次方。例如下方示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printNames</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">            <span class="built_in">print</span>(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码的耗时是数组遍历中再次对数组进行全量遍历的时间总和。如果原始数组中有10个元素，则会打印10个元素10次，总共100次打印操作。</p>
<p>如果输入增加一个单位，则上述打印操作需要执行 11 * 11 次，即总共121次。可视化后的图像如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/quadratic-time.png"></p>
<p>使用大O符号表示为**O(n^2)**。</p>
<h3 id="对数时间复杂度"><a href="#对数时间复杂度" class="headerlink" title="对数时间复杂度"></a>对数时间复杂度</h3><p>到目前为止，已经了解了线性和二次时间复杂性，其中输入的每个元素至少检查一次。但是，在某些情况下，只需要检查输入的子集，从而加快运行速度。</p>
<p>属于此类别的时间复杂性的算法是可以通过对输入数据进行一些假设来利用一些快捷方式的算法。例如，如果您有一个已排序的整数数组，那么查找是否存在特定值的最快方法是什么？</p>
<p>一个普遍的解决方案是从头到尾检查数组，在得出结论之前检查每个元素，由于您检查每个元素一次，这将是一个 <strong>O（n）</strong> 算法，线性时间相当不错，但你可以做得更好，由于输入数组已排序，因此可以进行优化。例如以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">56</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">80</span>, <span class="number">99</span>, <span class="number">105</span>, <span class="number">450</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">naiveContains</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Int</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> element <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你检查458是否在上述数组中的时候，算法将会遍历数组中的每一个元素。假设数组是已经排序好的，你可以尝试使用二分查找的方式，提高算法的执行效率，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">naiveContains</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Int</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> middleIndex <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> value <span class="operator">&lt;=</span> array[middleIndex] &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> middleIndex &#123;</span><br><span class="line">            <span class="keyword">if</span> array[index] <span class="operator">==</span> value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> middleIndex <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">            <span class="keyword">if</span> array[index] <span class="operator">==</span> value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述算法仅仅是进行了一个小的优化，即可将耗时减小一半，说明该优化是有意义的。</p>
<p>该算法首先检查数组的中间值，如果中间值大于目标值，曾说明目标值在数组的前半部分，否则在后半部分。每次只需要检查原有数组的一半的位置即可，这样即节省了内存空间，而且从算法的执行效率或者算法的响应能力上来说，算是一个成功的算法优化。</p>
<p>该算法可以重复有效地丢弃一半的数据，从而提高算法执行效率。对数时间复杂度可视化可表示为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/logarithmic-time.png"></p>
<p>随着输入的增加，耗时的增加相对比较缓慢。如果仔细观察该图像，可以发现耗时呈现不温不火的现象，因为在算法的具体执行中，输入的一半已经被丢弃，算法并不关心他们。</p>
<p>如果你有100个元素，那么算法最终会压缩到50个元素进行检索，如果有100000个元素，最终执行时，算法只关心50000个元素而已。数据越多，丢弃的元素也就越多，最终的执行耗时和数据的输入大小之间便呈现了如上图所示的关系。对数时间复杂度使用大O符号表示为**O(log n)**。</p>
<h3 id="准线性时间复杂度"><a href="#准线性时间复杂度" class="headerlink" title="准线性时间复杂度"></a>准线性时间复杂度</h3><p>另一个常见时间复杂度是<strong>准线性时间复杂度</strong>。准线性时间算法的性能比线性时间差，但明显优于二次时间复杂度。在Swift中典型的算法是数组的<strong>sort</strong>算法。</p>
<p>准线性时间复杂度的大O表示是<strong>O（n log n）</strong>，它是线性和对数时间的乘积。因此，准线性拟合与对数时间与线性时间不相契合；它比线性时间差一个量级，但仍比接下来您将看到的许多其他复杂性要好。下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/quasilinear-time.png"></p>
<p>准线性时间复杂性与二次时间有着类似的曲线，但对大型数据集的弹性更大。</p>
<h3 id="其他时间复杂度"><a href="#其他时间复杂度" class="headerlink" title="其他时间复杂度"></a>其他时间复杂度</h3><p>上述五种时间复杂度是程序开发中经常遇到的，还有其他的一些时间复杂度，例如多项式时间、指数时间、因子时间等。但是需要说明的是，时间复杂度并不能判断算法的执行速度，两种算法可能具有相同的时间复杂度，但是其中一种可能仍比其他算法快得多，对于小型数据集，时间复杂度可能不是实际算法执行时间的准确衡量。</p>
<p>例如，如果数据集较小，则插入排序等二次算法可能比准线性算法（如合并排序）更快。这是因为插入排序不需要分配额外的内存来执行算法，而合并排序需要分配多个数组。对于小型数据集，相对于算法需要接触的元素数，内存分配可能会非更加昂贵。</p>
<h2 id="时间复杂度的比较"><a href="#时间复杂度的比较" class="headerlink" title="时间复杂度的比较"></a>时间复杂度的比较</h2><p>假设你编写了一个求从 1 到 n 和的算法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> <span class="operator">...</span> n &#123;</span><br><span class="line">        result <span class="operator">+=</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码中的循环将执行10000次，最终得到结果50005000。该算法是O(n)时间复杂度。但是如何改进一下该算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne2</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="operator">...</span> n).reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne2(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>解决同样的问题，但是该实现的执行上会比上面循环的代码快很多，但是这里的时间复杂度依然是O(n)。使用<code>reduce</code>时，系统内部会执行 <code>n</code>次加法，但是调用的是Swift标准库中已经编译的代码，因此省去了很大一部分代码的编译时间。</p>
<p>继续优化上述代码，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne3</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n <span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> n <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne3(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>整个版本的算法使用了弗雷德里克·高斯算法，可以使用简单的算术计算总和。该算法的最时间复杂度是<strong>O（1）</strong>，属于恒定时间算法。也是该特定问题在时间复杂度上的的最优算法。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的时间复杂度有助于预测算法的可伸缩性，但它并不是唯一的指标。<strong>空间复杂性是算法运行所需的资源的度量。</strong> 对于计算机而言，内存一直是昂贵而紧俏的资源。假设有以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printSorted</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> sorted <span class="operator">=</span> array.sorted()</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> sorted &#123;</span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个排序后的数组拷贝并遍历该数据，打印其中元素。为了计算其空闲复杂度，需要分析该函数的内存开辟情况。</p>
<p>**array.sorted()**方法的调用系统会新建一个和原数组同样大小和类型的新数组，因此<code>printSorted</code>函数的空间复杂度是 **O(n)**。当然对于在内存中开辟尽量小的空间而言，该函数是简单而轻量的。可以将上述函数修改为如下方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printSorted2</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">var</span> currentCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> minValue <span class="operator">=</span> <span class="type">Int</span>.min</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> minValue &#123;</span><br><span class="line">            <span class="built_in">print</span>(value)</span><br><span class="line">            currentCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> currentCount <span class="operator">&lt;</span> array.count &#123;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">var</span> currentValue <span class="operator">=</span> array.max()<span class="operator">!</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">            <span class="keyword">if</span> value <span class="operator">&lt;</span> currentValue <span class="operator">&amp;&amp;</span> value <span class="operator">&gt;</span> minValue &#123;</span><br><span class="line">                currentValue <span class="operator">=</span> value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">            <span class="keyword">if</span> value <span class="operator">==</span> currentValue &#123;</span><br><span class="line">                <span class="built_in">print</span>(value)</span><br><span class="line">                currentCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6</span></span><br><span class="line">        minValue <span class="operator">=</span> currentValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此实现尊重空间限制。总体目标是多次遍历迭代数组，为每个迭代打印下一个最小值。</p>
<ol>
<li><p>检查是否数组为空的情况。如果是，则不打印内容。</p>
</li>
<li><p><code>currentCount</code>跟踪打印语句的数量。<code>minValue</code> 存储最后一个打印值。</p>
</li>
<li><p>算法首先打印出与 <code>minValue</code>  匹配的所有值，并根据打印语句的数量更新当前计数。</p>
</li>
<li><p>使用 <code>while</code> 循环，算法查找大于 <code>minValue</code>  的最小值并将其存储在当前值中。</p>
</li>
<li><p>然后，该算法在更新<code>currentCount</code>的同时打印数组内所有<code>currentValue</code>的值。</p>
</li>
<li><p><code>minValue</code> 设置为<code>currentValue</code>，因此下一次迭代将尝试查找下一个最小值。</p>
</li>
</ol>
<p>上述算法仅分配内存以跟踪几个变量，因此空间复杂性为 **O(1)**。这与前面的函数不同，后者分配整个数组以创建源数组的排序表示形式。</p>
<blockquote>
<p>PS: 在实际开发中并不会为了追求类似的空间，而将代码写成上述样子，上述代码仅仅是为了说明代码的不同写法，会导致算法的空间复杂度有质的飞跃。</p>
</blockquote>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><strong>时间复杂度</strong>是对输入大小增加时，算法运行时间的衡量；</li>
<li><strong>空间复杂度</strong>是对算法运行时，对资源使用情况的衡量；</li>
<li><strong>大O符号表示法</strong>是用于表示时间和空间复杂性的一般形式；</li>
<li>时间和空间复杂性是可伸缩性的高级度量，它们不测量算法本身的实际速度；</li>
<li>对于小型数据集，时间复杂性通常无关紧要。准线性算法可能比线性算法慢。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-15-Data-Structures-&amp;-Algorithms-in-Swift-17/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/17/cover.jpg" alt="\#17\ 排序算法O(n^2)"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.096Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">17 分钟读完 (大约2492个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-15-Data-Structures-&amp;-Algorithms-in-Swift-17/">\#17\ 排序算法O(n^2)</a></h1><div class="content"><p>**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。</p>
<p>在本文中，将学习饿三种不同的、O(n^2)时间复杂度的排序算法：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
</ul>
<p>这些算法均是<strong>基于比较</strong>的方法，他们依赖比较的运算，比如小于或等于运算符等，对数据进行排序。比较操作的调用次数是衡量此类算法技术总体性能的一般方法。</p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是相对简单的一种排序方法，在排序的过程中，重复比较两个数据的大小，并进行数据交换。其中较大的数值会类似气泡上升一样上升到集合的尾部。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>例如上图所示的四张扑克，其顺序为*[9， 4， 10， 3]*，现在需要对其从小到大进行排序，需要如下几个步骤：</p>
<ul>
<li>从集合最前端开始，比较扑克牌9和扑克牌4，由于9比4大，因此需要进行位置交换，交换后，顺序变为*[4， 9， 10， 3]*；</li>
<li>完成了第一步后，比较的锚点移动到集合的下一个索引处，即此时的扑克牌9，比较9和10，符合小的在前，大的在后，顺序不变；</li>
<li>继续移动到下一个索引，扑克牌10，比较10和3，不符合从小到大的原则，进行位置交换，交换后，集合变为*[4， 9， 3， 10]*。</li>
</ul>
<p>集合遍历第一遍后，往往很难使得集合达到预期的目标，但是对于上述集合来说，最大的扑克牌10，已经冒泡移动到了集合的最末端。</p>
<p>接下来进行第二遍遍历，此时比较扑克牌4和9:</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example_step.png"></p>
<p>只有当集合不用进行再进行交换的时候，整个集合才算所排序完成。最差的情况下，堆集合的遍历需要<em>n - 1</em>次，其中 <em>n</em> 为集合元素的个数。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">bubbleSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> (<span class="number">1</span> <span class="operator">..&lt;</span> array.count).reversed() &#123;</span><br><span class="line">        <span class="keyword">var</span> swapped <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> end &#123;</span><br><span class="line">            <span class="keyword">if</span> array[current] <span class="operator">&gt;</span> array[current <span class="operator">+</span> <span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(current, current <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">                swapped <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>swapped &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对集合进行元素个数检查，如果元素的个数小于2，则不需要进行排序；</li>
<li>进行外层循环，首次循环之后，最大的元素将会移至集合的末尾，下次循环的时候，总是会比上一次少一个元素，因此，每次循环基本上都会少一次比较；</li>
<li>进行元素间的比较和交换。比较当前元素和下一个元素的大小，如果当前元素大于下一个元素，则进行位置的交换；</li>
<li>如果再无元素需要交换，则说明集合已经排序完成，排序退出。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;bubble sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    bubbleSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bubble sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of bubble sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Bubble sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>冒泡排序最好的时间复杂度为O(n)，最差时间复杂度为O(n^2)。</p>
<h2 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h2><p>选择排序遵循冒泡排序的基本思想，但是优化了元素位置交换的数量，选择排序仅在每次传递结束之后才进行元素的交换。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下数量的扑克牌：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>每轮传递之后，选择排序将找到最小的未排序的元素，并对其进行位置交换：</p>
<ol>
<li>首先，发现扑克3是最小的，因此和扑克9交换位置；</li>
<li>下一个最小的扑克是4，其已经在正确地位置；</li>
<li>最后，最小的未扑克9，和扑克10交换。</li>
</ol>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/selection-sort-02.png"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">selectionSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> (array.count <span class="operator">-</span> <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> lowest <span class="operator">=</span> current</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> other <span class="keyword">in</span> (current <span class="operator">+</span> <span class="number">1</span>) <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">            <span class="keyword">if</span> array[lowest] <span class="operator">&gt;</span> array[other] &#123;</span><br><span class="line">                lowest <span class="operator">=</span> other</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lowest <span class="operator">!=</span> current &#123;</span><br><span class="line">            array.swapAt(lowest, current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历除了集合最后一个元素之外的其他元素，因为如果其他的元素都在正确地位置了，那么最后一个元素也是正确位置了；</li>
<li>再次遍历除当前索引之前的其他所有元素，寻找子集合中最小值的元素；</li>
<li>如果当前元素的索引并不是最小元素对应的索引，则进行元素位置的交换。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;selection sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    selectionSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Selection sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of selection sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Selection sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>类似冒泡排序，选择排序的最好、最坏和平均时间复杂度为O(n^2)，虽然有点让人沮丧，但是相比冒泡排序而言，选择排序的确表现的更好一些。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是更加有用的排序算法。像冒泡排序和选择排序，插入排序的平均时间复杂度依然为O(n^2)，但是插入排序的性能不同。越多的数据需要进行排序，选择排序会带来事半功倍的效果。在集合已经排序好的情况下，插入排序能达到最好时间复杂度O(n)。在Swift标准库中的排序算法使用的是混合排序的方式，当未排序的区间元素个数小于20个元素的时候，会采用插入排序的方式。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>同上，加入有如下的扑克牌：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>插入排序将会从左至右遍历扑克一次，每张扑克均向左移动，直到其所在位置正确位置：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/insertion-sort-02.png"></p>
<ol>
<li>在遍历时，最左边的扑克可以忽略，因为在其前面再无其他扑克牌；</li>
<li>接下来，比较扑克9和扑克4，因为扑克4较小，因此和扑克9进行位置交换；</li>
<li>扑克10此时不需要移动，因为再其前面的扑克为9，说明扑克10在正确地位置上；</li>
<li>最后，扑克3前面的所有扑克均比扑克3大，因此一次交换扑克3到最首位置。</li>
</ol>
<p>插入排序最佳的时间复杂度为O(n)，其发生在进行排序的集合元素预先是排序好的，这样在进行插入排序的时候无序进行任何左移操作。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insertionSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">1</span> <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">        <span class="keyword">for</span> shifting <span class="keyword">in</span> (<span class="number">1</span> <span class="operator">...</span> current).reversed() &#123;</span><br><span class="line">            <span class="keyword">if</span> array[shifting] <span class="operator">&lt;</span> array[shifting <span class="operator">-</span> <span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(shifting, shifting <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>插入排序需要遍历集合中的每一个元素，因此第一个for循环从左至右遍历集合，这里忽略了首个位置的元素；</li>
<li>从当前索引向前遍历元素，比较当前索引元素和前一个索引元素，如果位置不正确则进行位置交换；</li>
<li>一直交换，直到所有索引位置的元素均在正确地位置为止。如果位置正确，则跳出当前循环，进行下一个索引元素的检查。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insertion sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    insertionSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Insertion sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insertion sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Insertion sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="算法泛化"><a href="#算法泛化" class="headerlink" title="算法泛化"></a>算法泛化</h2><p>在本内容中，将对现有的排序算法进行优化，因为现有的算法接受的集合仅仅为<em>Array</em>，对于其他的集合类型并不适用，因此将对算法进行升级，有增强算法的泛化能力，具体有如下三方面：</p>
<ol>
<li>对于插入排序而言，需要对集合进行前向遍历和元素交换，因此接受的参数集合应该是双向集合类型<em>BidirectionalCollection</em>；</li>
<li>冒泡排序和选择排序仅仅对集合进行从前向后的遍历，因此集合参数仅仅需要符合集合类型<em>Collection</em>；</li>
<li>无论哪一种情况下，集合必须是<em>MutableCollection</em>可变集合类型，因为需要在遍历过程中进行元素的交换；</li>
</ol>
<p><strong>优化后的冒泡排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">bubbleSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> collection.indices.reversed() &#123;</span><br><span class="line">        <span class="keyword">var</span> swapped <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> collection.startIndex</span><br><span class="line">        <span class="keyword">while</span> current <span class="operator">&gt;</span> end &#123;</span><br><span class="line">            <span class="keyword">let</span> next <span class="operator">=</span> collection.index(after: current)</span><br><span class="line">            <span class="keyword">if</span> collection[current] <span class="operator">&gt;</span> collection[next] &#123;</span><br><span class="line">                collection.swapAt(current, next)</span><br><span class="line">                swapped <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>swapped &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化后的选择排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">selectionSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> collection.indices &#123;</span><br><span class="line">        <span class="keyword">var</span> lowest <span class="operator">=</span> current</span><br><span class="line">        <span class="keyword">var</span> other <span class="operator">=</span> collection.index(after: current)</span><br><span class="line">        <span class="keyword">while</span> other <span class="operator">&lt;</span> collection.endIndex &#123;</span><br><span class="line">            <span class="keyword">if</span> collection[lowest] <span class="operator">&gt;</span> collection[other] &#123;</span><br><span class="line">                lowest <span class="operator">=</span> other</span><br><span class="line">            &#125;</span><br><span class="line">            other <span class="operator">=</span> collection.index(after: other)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lowest <span class="operator">!=</span> current &#123;</span><br><span class="line">            collection.swapAt(lowest, current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化后的插入排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insertionSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">BidirectionalCollection</span> &amp; <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> collection.indices &#123;</span><br><span class="line">        <span class="keyword">var</span> shifting <span class="operator">=</span> current</span><br><span class="line">        <span class="keyword">while</span> shifting <span class="operator">&gt;</span> collection.startIndex &#123;</span><br><span class="line">            <span class="keyword">let</span> previous <span class="operator">=</span> collection.index(before: shifting)</span><br><span class="line">            <span class="keyword">if</span> collection[shifting] <span class="operator">&lt;</span> collection[previous] &#123;</span><br><span class="line">                collection.swapAt(shifting, previous)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            shifting <span class="operator">=</span> previous</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>n²算法通常名声不太那么好，在性能消耗方面总是会带来更大消耗，但是在合理的数据量下，此类算法也可解决一些排序问题；</li>
<li>插入排序是最好的排序算法之一，在进行排序之前，需要了解数据是否已经是排序的。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-30-Data-Structures-&amp;-Algorithms-in-Swift-18/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/18/cover.jpg" alt="\#18\ 归并排序（Merge Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.092Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.092Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">7 分钟读完 (大约1113个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-30-Data-Structures-&amp;-Algorithms-in-Swift-18/">\#18\ 归并排序（Merge Sort）</a></h1><div class="content"><p><strong>归并排序[Merge Sort]<strong>是最有效的排序算法之一，它的时间复杂度为O(n log n)，是所有通用排序算法中速度最快的一种。归并排序背后的思想是</strong>分而治之</strong>，即将一个大问题分解成多个更小、更易于解决的问题，然后将各个小问题的结果合并为最终结果。<strong>归并排序的终极秘诀是先拆分后合并。</strong></p>
<p>例如，有如下未排序的扑克牌：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/18/eg-1.png"></p>
<p>针对上述问题，归并排序的工作原理如下：</p>
<ul>
<li>对扑克牌进行对半拆分，拆分后会有两大部分：</li>
</ul>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/18/eg-2.png"></p>
<ul>
<li>对上一步的拆分结果继续进行拆分：</li>
</ul>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/18/eg-3.png"></p>
<p>直到无法再拆分为止</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/18/eg-4.png"></p>
<ul>
<li>最后，将拆分的每一部分进行反向的合并，每次合并时，将不同的部分按照顺序进行排序。</li>
</ul>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/18/eg-5.png"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>归并排序的思想是分而治之，因此首先要进行问题的拆解，之后再进行合并。</p>
<h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Element</span>]) -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> left <span class="operator">=</span> <span class="type">Array</span>(array[<span class="operator">..&lt;</span>middle])</span><br><span class="line">    <span class="keyword">let</span> right <span class="operator">=</span> <span class="type">Array</span>(array[middle<span class="operator">...</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... more to come</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对待排序集合进行了对半拆分，但是仅仅一次拆分并不能满足归并排序的思想，需要持续拆分，直到集合再无法进行拆分为止，因此更新上述代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Element</span>]) -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> middle <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> left <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[<span class="operator">..&lt;</span>middle]))</span><br><span class="line">    <span class="keyword">let</span> right <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[middle<span class="operator">...</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... more to come</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先确定算法可进入的条件，如果不符合基本的条件，则算法退出。这里的退出条件是待排序集合中仅有一个元素或无元素时，算法退出；</li>
<li>使用递归的方式进行拆分，直至无法再次拆分为止。</li>
</ul>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>完全拆分后，则进入到了归并排序的最后一步，将所拆分的左右部分进行合并，此时新建函数<em>merge</em>进行合并操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">merge</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">left</span>: [<span class="type">Element</span>], <span class="keyword">_</span> <span class="params">right</span>: [<span class="type">Element</span>]) -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> leftIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> leftIndex <span class="operator">&lt;</span> left.count <span class="operator">&amp;&amp;</span> rightIndex <span class="operator">&lt;</span> right.count &#123;</span><br><span class="line">        <span class="keyword">let</span> leftElement <span class="operator">=</span> left[leftIndex]</span><br><span class="line">        <span class="keyword">let</span> rightElement <span class="operator">=</span> right[rightIndex]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftElement <span class="operator">&lt;</span> rightElement &#123;</span><br><span class="line">            result.append(leftElement)</span><br><span class="line">            leftIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> leftElement <span class="operator">&gt;</span> rightElement &#123;</span><br><span class="line">            result.append(rightElement)</span><br><span class="line">            rightIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.append(leftElement)</span><br><span class="line">            leftIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            result.append(rightElement)</span><br><span class="line">            rightIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> leftIndex <span class="operator">&lt;</span> left.count &#123;</span><br><span class="line">        result.append(contentsOf: left[leftIndex<span class="operator">...</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> rightIndex <span class="operator">&lt;</span> right.count &#123;</span><br><span class="line">        result.append(contentsOf: right[rightIndex<span class="operator">...</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><em>leftIndex</em>和<em>rightIndex</em>两个变量用于对遍历过程进行索引追踪；</li>
<li><em>result</em>变量为最终的合并结果；</li>
<li>使用<em>while</em>循环对左右集合进行遍历和元素比较，直到到达集合末尾位置；</li>
<li>在遍历过程中，对元素进行比较，更小的元素或相等的元素均将追加到结果<em>result</em>并对索引进行移动；</li>
<li><em>while</em>循环结束后，<em>left</em>和<em>right</em>两个集合均是已经排序了的，确保了剩下的元素都是大于或等于<em>result</em>中已存在的元素。此种情况下，可以直接将其追加到结果集合中。</li>
</ol>
<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>合并工作使用了单独的函数完成，此时整合拆分和合并，最终归并排序算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Element</span>]) -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> middle <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> left <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[<span class="operator">..&lt;</span>middle]))</span><br><span class="line">    <span class="keyword">let</span> right <span class="operator">=</span> mergeSort(<span class="type">Array</span>(array[middle<span class="operator">...</span>]))</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下归并排序的关键流程：</p>
<ol>
<li>归并排序的核心思想是分而治之，即将大问题拆分成多个小问题，依次对各个小问题进行求解，最后在合并各个结果；</li>
<li>归并排序算法有两个核心的职责：一个是递归拆分初始集合的方法，另一个是合并两个集合的方法；</li>
<li>合并函数应该使用两个排序的数组并生成一个排序的数组。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;merge sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merge sorted: <span class="subst">\(mergeSort(array))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of merge sort---</span></span><br><span class="line"><span class="comment">Original: [7, 2, 6, 3, 9]</span></span><br><span class="line"><span class="comment">Merge sorted: [2, 3, 6, 7, 9]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>归并排序有着并不太坏的时间复杂度，其最好、最坏和平均时间复杂度为O(n log n)。</p>
<ul>
<li>在递归的时候，需要将一个集合拆分成更小的集合，这意味着大小为2的集合需要一次递归，大小为4的集合需要两次递归，大小为8的集合需要三次递归等等。一般情况下，如果集合的大小为n，则要拆分的层级数就是log2(n)；</li>
<li>一个递归级别将合并n个元素。不管合并的规模是大是小;每一层合并的元素数量仍然是n。这意味着一个递归的代价是O(n)。</li>
</ul>
<p>那么拆分和合并的总体消耗为 *O(log n) x O(n) &#x3D; O(n log n)*。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>归并排序的核心思想是<strong>分而治之</strong>的原则；</li>
<li>归并排序算法的实现由多种方式，不同的实现可能带来不同的性能体现。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-25-Data-Structures-&amp;-Algorithms-in-Swift-11/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/11/cover.jpg" alt="\#11\ 二叉搜索树"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.090Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.091Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">17 分钟读完 (大约2613个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-25-Data-Structures-&amp;-Algorithms-in-Swift-11/">\#11\ 二叉搜索树</a></h1><div class="content"><p>二叉搜索树又称为二叉查找树（BST），是一种支持快速查找、插入和删除操作的树结构，例如下方的决策树，其中选择一方而放弃另一方的所有可能性，从而将问题减半。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/bst-decision-tree-demo.png"></p>
<p>在决策树中，一旦做出了决定并选择了某个分支，便不能回头，在选择的分支上一直查找直到叶子节点，得到最终决定。二叉搜索树在上一文中的二叉树的基础上增加了以下两个规则：</p>
<ol>
<li>左节点的值必须小于父节点的值；</li>
<li>同样的，右节点的值必须大于等于其父节点的值。</li>
</ol>
<p>二叉搜索树使用这两个规则可避免执行不必要的检查，其查找、插入和删除的平均时间复杂度为O(log n)，比线性结构快的多。</p>
<h2 id="Array-vs-BST"><a href="#Array-vs-BST" class="headerlink" title="Array vs. BST"></a>Array vs. BST</h2><p>例如有如下的两种结构的集合：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/array-vs-bst.png"></p>
<p>上面的结构为数组，下方的为二叉搜索树结构。</p>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>对于未排序的数组来说，搜索只能从开头到结尾，例如搜索元素105。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/array-search-105.png"></p>
<p>这也是为什么*array.contains(:)*操作为O(n)的原因。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/bst-search-105.png"></p>
<p>使用二叉搜索树的数据结构，搜索同样的元素105，简单且高效的多。因为搜索算法每次访问节点的时候，都会遵循如下两个原则：</p>
<ol>
<li>如果目标搜索值小于当前节点的值，那么目标搜索值一定在当前节点的左树中；</li>
<li>如果目标搜索值大于当前节点的值，那么目标搜索值一定在当前节点的右树中。</li>
</ol>
<p>通过BST的这些搜索原则，可以避免一些数据项检查，减半搜索空间，这也是BST中搜索算法的时间复杂度为O(log n)的原因。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于数组来说，如果要插入一个元素，需要将插入位置之后的所有元素向后移动一个位置，这也是为什么对于数组的插入算法，时间复杂度为O(n)的原因。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/array-insertion.png"></p>
<p>而对于二叉搜索树来说，插入一个新的元素，相对舒服的多。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/bst-insertion.png"></p>
<p>由于二叉搜索树的规则，小于当前节点元素值的节点一定在当前节点的左树或左节点，因此插入一个新的元素的时候，可以减少一半的检查时间。例如上图中，在现有的二叉搜索树中插入新的元素1。二叉搜索树的插入算法，时间复杂度应该为O(log n)。</p>
<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>和插入类似，数组的元素移除同样需要移动删除目标元素之后的所有元素的位置，因此其时间复杂度依然是O(n)。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/array-removal.png"></p>
<p>对于二叉搜索树来说，会由两种情况，当删除的节点是叶子节点的时候，相对较为简单，但是如果待删除的节点有子节点的时候，相对要进行一些复杂的管理工作。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/bst-removal.png"></p>
<h2 id="结构与算法实现"><a href="#结构与算法实现" class="headerlink" title="结构与算法实现"></a>结构与算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">BinarySearchTree</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Comparable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> root: <span class="type">BinaryNode</span>&lt;<span class="type">Element</span>&gt;?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BinarySearchTree</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> root <span class="operator">=</span> root <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Empty tree&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树的本质是二叉树，因此在二叉搜索树的内部，定义的节点类型为BinaryNode，并且二叉搜索树中的元素时可比较的。</p>
<h3 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h3><p>二叉树的基本准则是：</p>
<ol>
<li>左节点的值必须小于父节点的值；</li>
<li>同样的，右节点的值必须大于等于其父节点的值。</li>
</ol>
<p>依据这两个准则，即可实现二叉搜索树的插入算法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        root <span class="operator">=</span> insert(from: root, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="params">from</span> <span class="params">node</span>: <span class="type">BinaryNode</span>&lt;<span class="type">Element</span>&gt;?, <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">BinaryNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果是空的树，则直接使用当前值构建一个节点返回</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">BinaryNode</span>(value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到左树</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> node.value &#123;</span><br><span class="line">            node.leftChild <span class="operator">=</span> insert(from: node.leftChild, value: value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入到右树</span></span><br><span class="line">            node.rightChild <span class="operator">=</span> insert(from: node.rightChild, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;building a BST&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> bst <span class="operator">=</span> <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">5</span> &#123;</span><br><span class="line">        bst.insert(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(bst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of building a BST---</span></span><br><span class="line"><span class="comment">   ┌──4</span></span><br><span class="line"><span class="comment">  ┌──3</span></span><br><span class="line"><span class="comment">  │ └──nil </span></span><br><span class="line"><span class="comment"> ┌──2</span></span><br><span class="line"><span class="comment"> │ └──nil </span></span><br><span class="line"><span class="comment">┌──1</span></span><br><span class="line"><span class="comment">│ └──nil </span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">└──nil </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/unbalanced-bst.png"></p>
<p>然而，对于上述构建的BST，貌似是不平衡的，二叉树的节点均在根节点的右树上，而理想的状态应该是上图中右侧的部分。如果此时插入新的元素5，则会出现如下情况：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/unbalanced-bst-insertion.png"></p>
<blockquote>
<p>解决方案是构建自平衡树的结构，自平衡树这里不进行详述。</p>
</blockquote>
<p>为了防止树结构的不平衡，这里仅仅使用最为笨重的方式构建一个平衡的二叉树。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exampleTree: <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> bst <span class="operator">=</span> <span class="type">BinarySearchTree</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    bst.insert(<span class="number">3</span>)</span><br><span class="line">    bst.insert(<span class="number">1</span>)</span><br><span class="line">    bst.insert(<span class="number">4</span>)</span><br><span class="line">    bst.insert(<span class="number">0</span>)</span><br><span class="line">    bst.insert(<span class="number">2</span>)</span><br><span class="line">    bst.insert(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> bst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;building a balanced BST&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(exampleTree)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of building a balanced BST---</span></span><br><span class="line"><span class="comment"> ┌──5</span></span><br><span class="line"><span class="comment">┌──4</span></span><br><span class="line"><span class="comment">│ └──nil </span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">│ ┌──2</span></span><br><span class="line"><span class="comment">└──1</span></span><br><span class="line"><span class="comment"> └──0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="元素搜索"><a href="#元素搜索" class="headerlink" title="元素搜索"></a>元素搜索</h3><p>二叉搜索树元素的搜索需要遍历二叉树的各个节点，因此可以使用上一文中实现的二叉树相关遍历算法 — 有序、前序和后序。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> root <span class="operator">=</span> root <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> found <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        root.traverseInOrder &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="variable">$0</span> <span class="operator">==</span> value &#123;</span><br><span class="line">                found <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如搜索上述二叉搜索树中是否包含元素5：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;finding a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> exampleTree.contains(<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found 5!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find 5&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of finding a node---</span></span><br><span class="line"><span class="comment">Found 5!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里的元素搜索算法使用了有序遍历的方法，因此其时间复杂度也为O(n)。但是该复杂度的搜索算法存在可优化的空间，由于二叉搜索树有左节点小于父节点，右节点大于父节点的特性，因此在元素搜索的时候，可以利用该属性减少搜索检查的范围，进一步优化搜索耗时等。</p>
<p>优化元素的搜索算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">containsOpt</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> current &#123;</span><br><span class="line">        <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> node.value &#123;</span><br><span class="line">            current <span class="operator">=</span> node.leftChild</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current <span class="operator">=</span> node.rightChild</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化的算法时间复杂度为O(log n)。</p>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>二叉搜索树元素的移除相对元素的搜索和插入复杂一些，有如下三种场景需要考虑：</p>
<p><strong>Case 1：叶子节点</strong></p>
<p>对于待删除的元素所在的节点为叶子节点时，是最为简单直接的场景，直接分类该节点和其父节点的链接即可。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-leaf-node.png"></p>
<p><strong>Case 2：有一个子节点的节点</strong></p>
<p>当待删除的元素所在的节点拥有一个子节点的时候，不仅仅要删除该节点，还需要将该节点的字节点和树的其余节点进行重新链接，一般情况下，会重新和删除节点的原始父节点进行链接。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-one-node.png"></p>
<p><strong>Case 3：有两个子节点的节点</strong></p>
<p>当待删除节点拥有两个子节点的时候，删除操作相对较为复杂一点。例如下图二叉搜索树，想要删除的元素为25：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-1.png"></p>
<p>如果只是简单的删除节点25，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-2.png"></p>
<p>此时虽然删除掉了节点25，但是带来了另一个问题。当删除掉节点25之后，会出现两个需要重建链接的节点12和37，此时原节点25的父节点却只有一个子节点的空间，如果如上图那样建立链接的话，会导致该二叉搜索树不成立。为了解决此问题，需要对节点的链接进行交换，使得删除节点后的二叉搜索树依然成立。</p>
<p>方法就是，删除拥有两个节点的节点之后，使用其右侧子树中最小的节点替换删除的节点，根据二叉搜索树的特点，最小的节点即为右侧子树中最左的节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/11/remove-element-two-node-3.png"></p>
<p>这样进行节点交换之后，二叉搜索树依然有效，因为新节点是右子树中的最小节点，所以右子树中的所有节点仍将大于或等于新节点。并且由于新节点来自右子树，因此左子树中的所有节点都小于新节点。</p>
<p><strong>算法实现</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">extension</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> min: <span class="type">BinaryNode</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftChild<span class="operator">?</span>.min <span class="operator">??</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        root <span class="operator">=</span> remove(node: root, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">node</span>: <span class="type">BinaryNode</span>&lt;<span class="type">Element</span>&gt;?, <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">BinaryNode</span>&lt;<span class="type">Element</span>&gt;? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> node.value &#123;</span><br><span class="line">            <span class="keyword">if</span> node.leftChild <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> node.rightChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.leftChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node.rightChild</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.rightChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node.leftChild</span><br><span class="line">            &#125;</span><br><span class="line">            node.value <span class="operator">=</span> node.rightChild<span class="operator">!</span>.min.value</span><br><span class="line">            node.rightChild <span class="operator">=</span> remove(node: node.rightChild, value: node.value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&lt;</span> node.value &#123;</span><br><span class="line">            node.leftChild <span class="operator">=</span> remove(node: node.leftChild, value: value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.rightChild <span class="operator">=</span> remove(node: node.rightChild, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;removing a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tree <span class="operator">=</span> exampleTree</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tree before removal:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(tree)</span><br><span class="line">    tree.remove(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tree after removing root:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(tree)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of removing a node---</span></span><br><span class="line"><span class="comment">Tree before removal:</span></span><br><span class="line"><span class="comment"> ┌──5</span></span><br><span class="line"><span class="comment">┌──4</span></span><br><span class="line"><span class="comment">│ └──nil </span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">│ ┌──2</span></span><br><span class="line"><span class="comment">└──1</span></span><br><span class="line"><span class="comment"> └──0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Tree after removing root:</span></span><br><span class="line"><span class="comment">┌──5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">│ ┌──2</span></span><br><span class="line"><span class="comment">└──1</span></span><br><span class="line"><span class="comment"> └──0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>二叉搜索树是一种存储排序数据的数据结构；</li>
<li>二叉搜索树的插入、移除和查找算法的平均时间复杂度为O(log n)；</li>
<li>当树不平衡的时候，时间复杂度会降低到O(n)。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-10-Data-Structures-&amp;-Algorithms-in-Swift-08/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/8/cover.jpg" alt="\#8\ 队列的Swift实现与操作定义"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.088Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.089Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">32 分钟读完 (大约4762个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-10-Data-Structures-&amp;-Algorithms-in-Swift-08/">\#8\ 队列的Swift实现与操作定义</a></h1><div class="content"><p>在生活中，人人都熟悉排队等待。无论你是在排队购买喜欢的电影的电影票，还是排队等待打印一份文件等等，这些都是<strong>队列（Queue）</strong>数据结构。在上文<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/08/Data-Structures-&-Algorithms-in-Swift-07.html">\#7\ Stack &amp; Stack Simple Challenges</a>中已经提到过队列和栈属于基本的数据结构类型，但是其在应用层面非常有效。</p>
<p><strong>队列（Queue）</strong>是一种<strong>FIFO(ﬁrst-in ﬁrst-out)<strong>型的数据操作特性，和栈的</strong>LIFO</strong>形成鲜明的对比。<strong>FIFO</strong>意味着首先进入队列的元素，也是第一个推出队列的元素。在项目中，如果要维护一个有顺序的数据并稍后处理，队列是无二之选。</p>
<p>在本内容中，我们将学习关于队列的常见操作，以及使用Swift语言实现这些操作，衡量这些操作的时间复杂度等。</p>
<h2 id="一般性操作实现"><a href="#一般性操作实现" class="headerlink" title="一般性操作实现"></a>一般性操作实现</h2><p>由于队列的操作特性较多，在这里我们可以使用Swift的面向协议的编程思想进行实现，首先我们定义一个关于操作的协议，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span>  <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>enqueue：</strong> 向队列的尾部插入一个元素，如果该操作成功，则返回true，反之返回false；</li>
<li><strong>dequeue：</strong> 从队列的头部删除一个元素，并返回被删除的元素；</li>
<li><strong>isEmpty：</strong> 检查队列是否为空；</li>
<li><strong>peek：</strong> 返回队列头部的元素，和<strong>dequeue</strong>的区别在于，该操作并不删除元素。</li>
</ul>
<p>通过操作类型的定义可以看到，队列有两个普遍的操作，在队列的尾部插入元素和从队列的头部删除元素，而并不需要关心队列的中间元素，如果需要关心中间元素，你可能需要使用数组。</p>
<h2 id="一个队列的例子"><a href="#一个队列的例子" class="headerlink" title="一个队列的例子"></a>一个队列的例子</h2><p>理解队列最简单的方式是通过实际的示例了解队列的工作原理。假设在影院门口，很多人在排队购买电影票：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/queue-example.png"></p>
<p>队伍中有Ray、Brian、Sam和Mic四人，当Ray买到了电影票后，他就会从队伍中退出，相当于调用了**dequeue()**，从队伍的头部删除了一个元素类似。</p>
<p>此时，调用<strong>peek</strong>将返回队列中此刻的头元素Brain。</p>
<p>如果来了一个新的人Vicki，加入到了队伍中，等待购买电影票，她站到了队伍的尾部。相当于调用了**enqueue(“Vicki”)**。</p>
<p>这就是队列的一般性工作原理，接下来我们将使用四种不同的基础数据结构来创建队列以及队列的一般性操作。分别为：</p>
<ul>
<li>使用数组（Array）</li>
<li>使用双向链表（Double LinkedList）</li>
<li>使用环形缓冲器（Ring buffer）</li>
<li>使用两个栈（two stacks）</li>
</ul>
<h2 id="基于Array的队列"><a href="#基于Array的队列" class="headerlink" title="基于Array的队列"></a>基于Array的队列</h2><p>Swift标准库中继承了大量高度优化的核心数据结构，利用这些数据结构可以构建更高级别的抽象，例如基础数据结构Array，用于存储连续的有序元素列表。在本节中，将使用Array来构建队列，并实现队列的基础操作等。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/array-queue.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">QueueArray</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> array: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个采用Queue协议的通用型QueueArray结构体，在Queue协议中定义的关联类型Element这里由T推断。</p>
<p>接下来实现Queue协议中的定义等，使得QueueArray符合Queue协议。</p>
<h3 id="数组检查"><a href="#数组检查" class="headerlink" title="数组检查"></a>数组检查</h3><p>首先添加如下两个协议属性的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> array.isEmpty</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> array.first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里使用的是数组，因此在实现<code>isEmpty</code>和<code>peek</code>时，均可直接使用数组的内置属性，简洁方便。其中<code>peek</code>返回的是队列的头部元素，也就是数组的第一个元素。</p>
<p>这连个操作的时间复杂度均为**O(1)**。</p>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>入队就是将元素添加到队列的末尾。使用数组实现也非常方便，只要进行append操作即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    array.append(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队的操作，无论数组的大小如何，该操作的时间复杂度都是**O(1)**。这是因为在数组的末尾，存在着空白空间。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/array-queue-enqueue.png"></p>
<p>在上例中，当添加了<code>Mic</code>元素之后，数组还剩下两个空白空间。当添加了多个元素之后，数组的空白空间将会被填满，继续添加元素的时候，则要使用超出数组原始分配空间的空间，进而必须调整数组大小以增加空间。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/array-queue-enqueue-full.png"></p>
<p>在数组进行大小重新调整的时候，其时间复杂度为O(n)，数组大小重组意味着数组需要重新分配内存空间，并将原数据元素拷贝到新的数组中，因为这样的调整并不是经常性的，因此入队操作的时间复杂度仍可认为是**O(1)**。</p>
<h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>出队操作是将队列头节点的元素移出队列，可使用数组的<strong>removeFirst</strong>操作即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> isEmpty <span class="operator">?</span> <span class="literal">nil</span> : array.removeFirst()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组为空，则出队操作后返回nil，否则返回出队的元素。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/array-queue-dequeue.png"></p>
<p>从队列中头部移除元素的操作属于O(n)时间复杂度，在上述方式中就是从数组中移除第一个元素。这始终是一个线性的时间度量，因为在内存中，当移除一个元素后，其他所有的元素都需要移动其位置。</p>
<h3 id="调试与测试"><a href="#调试与测试" class="headerlink" title="调试与测试"></a>调试与测试</h3><p>对于调试目的来说，Swift中提供了专用的协议<strong>CustomStringConvertible</strong>，为了调试的方便，我们需要添加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">QueueArray</span>: <span class="title class_">CustomDebugStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: array)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进行队列的调试，调试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Debug the Queue with Array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">QueueArray</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue.peek <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Debug the Queue with Array---</span></span><br><span class="line"><span class="comment">[&quot;Ray&quot;, &quot;Brian&quot;, &quot;Eric&quot;]</span></span><br><span class="line"><span class="comment">[&quot;Brian&quot;, &quot;Eric&quot;]</span></span><br><span class="line"><span class="comment">Eric</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>由于是使用Array来进行队列的设计，因此操作方式非常类似于Array，上述打印结果也符合队列的先进先出的原则。</p>
<h3 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h3><p>上述就是基于数组的队列的一般操作的算法实现，大多数的操作都是恒定时间复杂度的，例如*dequeue()*操作，属于线性时间，内存空间也是线性的。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/array-queue-adv-disa.png"></p>
<p>基于数组的队列相对是简单的，也是因为数组的append操作，使得入队操作是恒定的时间复杂度O(1)。然而在实施中却有一些明显的缺点，出队的操作是从队列的头部移除元素，移除后，其他的所有元素都需要向前移动一个位置，对于队列来说影响算是非常大的。一旦队列已满，队列就必须调整其大小，调整完后，队列中很容易存在未使用的空间，随着时间的推移，未使用空间越来越多，这可能增加内存的占用率。</p>
<h2 id="基于双向链表（Double-LinkedList）的队列"><a href="#基于双向链表（Double-LinkedList）的队列" class="headerlink" title="基于双向链表（Double LinkedList）的队列"></a>基于双向链表（Double LinkedList）的队列</h2><p>在<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/04/Data-Structures-&-Algorithms-in-Swift-05.html">\#5\ Swift集合协议在Linked List上的应用</a>中我们已经了解了单向链表，双向链表则是每个节点不仅包含指向下一个节点的指针，还包含指向上一个节点的指针。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">LinkedListNode</span>? <span class="comment">// 指向下一个节点。尾节点为nil</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> previous: <span class="type">LinkedListNode</span>? <span class="comment">// 指向上一个节点。头节点为nil</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用双向链表实现队列如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueLinkedList</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">DoublyLinkedList</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        list.append(element)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>list.isEmpty, <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> list.first <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.remove(at: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> list.head<span class="operator">?</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><p>由于链表中实现了能够直接添加元素到链表尾部的操作，因此入队操作相当于链表的追加操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    list.append(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-linkedlist-enqueue.png"></p>
<p>基于双向链表的队列入队时，其内部需要转换节点的两个指针的指向，上一个节点中指向下一个节点的指针指向该新节点，该新节点的上一个节点指向上一个节点。同时tail节点的上一个节点指针也需要更新。</p>
<h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><p>出队列操作前，需要检查队列是否为空队列，如果是空队列的时候，直接返回nil，否则移除链表中索引为0的元素即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>list.isEmpty, <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> list.first <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.remove(at: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-linkedlist-dequeue.png"></p>
<p>出队需要更新head节点的指针指向，将head的next指针的指向原来队列的第二个节点即可。</p>
<h3 id="调试与测试-1"><a href="#调试与测试-1" class="headerlink" title="调试与测试"></a>调试与测试</h3><p>同样调试模式下，我们实现<strong>CustomStringConvertible</strong>协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">QueueLinkedList</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试程序中实现和基于数组的队列相同的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Debug the Queue with Doubly Linkedlist&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">QueueLinkedList</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue.peek <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Debug the Queue with Doubly Linkedlist---</span></span><br><span class="line"><span class="comment">[Ray, Brian, Eric]</span></span><br><span class="line"><span class="comment">[Brian, Eric]</span></span><br><span class="line"><span class="comment">Eric</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="优势和劣势-1"><a href="#优势和劣势-1" class="headerlink" title="优势和劣势"></a>优势和劣势</h3><p>基于双向链接的队列，各个操作的最佳时间复杂度和最差时间复杂度如下图所示：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-linkedlist-queue-adv-disa.png"></p>
<p>基于数组的队列在出队操作上是一个线性的操作，使用链表的队列，出队操作简化为了恒定时间复杂，每次出队操作只需要更新节点的上一个和下一个指针即可。</p>
<p>从上表中可以看出，基于链表的队列的弱点并不明显，但是O(1)的时间复杂度却只是表面性能，操作在执行的时候，需要很高的内存开销，每个元素的操作都必须有额外的空间以供前向指针和后向指针引用，此外，每次创建新元素都需要进行昂贵的内存动态分配，相比之下，基于数组的队列进行的是批量的内存分配，速度更快。</p>
<h2 id="基于环形缓冲器的队列"><a href="#基于环形缓冲器的队列" class="headerlink" title="基于环形缓冲器的队列"></a>基于环形缓冲器的队列</h2><p>环形缓冲区也称为循环缓冲区，是一个固定大小的数组，当数组末尾没有要删除的元素时，环形缓冲区会从策略绕到数组开头。那么环形缓冲区是如何实现队列的操作的呢？</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-1.png"></p>
<p>首先创建一个固定大小为4的缓冲区，在该缓冲区中同时含有两个指针，分别追踪不同的事情：</p>
<ul>
<li><strong>read</strong>指针追踪队列的头部</li>
<li><strong>write</strong>指针追踪下一个可写的空间指针，这样就能够重写已读过的元素了。</li>
</ul>
<p>进行入队操作，如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-enqueue.png"></p>
<p>每次添加一个元素到队列的时候，<strong>write</strong>指针加一。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-enqueue-2.png"></p>
<p>上图中，<strong>write</strong>指针又移动了两个位置，而且其位置位于<strong>read</strong>指针的前面，也意味着队列是非空队列。</p>
<p>接下来，进行两次出队的操作：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-dequeue.png"></p>
<p>出队操作的是<strong>read</strong>指针，read指针向后移动，指向第三个元素的位置即可。接下来在进行入队操作，将队列填充满：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-enqueue-full.png"></p>
<p>当<strong>write</strong>指针到达队列的末尾是，环形缓冲区会重新转换该指针到队列的开始位置。</p>
<p>最后，在出队两个队列中的元素：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-queue-dequeue-2.png"></p>
<p>此时<strong>read</strong>指针也指向了队列的开始位置。最后一次出队操作后，read指针和write指针都指向了队列的开始位置，这也意味着队列中已经无元素了，为空的队列。</p>
<p>上述就是RingBuffer的基本数据结构和工作原理，接下来进行数据结构的实现和基本操作的实现。</p>
<p>首先定义所需的变量，包括了数据存储的结构，这里使用Array即可，还有两个基本的指针read和write，为了方便对数据进行检验，增加辅助检查可写空间大小和可读空间大小的变量，以及是否为空和是否已满的变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">RingBuffer</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> array: [<span class="type">T</span>?]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> readIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> writeIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        array <span class="operator">=</span> [<span class="type">T</span>?](repeating: <span class="literal">nil</span>, count: count)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> availableSpaceForReading: <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> writeIndex <span class="operator">-</span> readIndex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> availableSpaceForReading <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> availableSpaceForWriting: <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> array.count <span class="operator">-</span> availableSpaceForReading</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isFull: <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> availableSpaceForWriting <span class="operator">==</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于RingBuffer是固定大小的数据结构，因此在可读可写空间判断的时候，直接使用减法的方式即可获取到可用空间大小。接下来就是基本的read操作和write操作的实现，在实现这两个操作时需要检查缓存区是否已满和是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">write</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>isFull <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        writeIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    array[wrapped: writeIndex] <span class="operator">=</span> element</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">read</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>isEmpty  <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        array[wrapped: readIndex] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        readIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[wrapped: readIndex]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外在操作中使用了Array的subscript操作属性，但是原始的subscript并不符合RingBuffer的定义，因此还需要重写subscript操作如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">extension</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span> (<span class="params">wrapped</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[index <span class="operator">%</span> count]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>[index <span class="operator">%</span> count] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另由于RingBuffer还应该支持序列的可遍历迭代操作，因此定义RingBuffer的Iterator操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">RingBuffer</span>: <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">makeIterator</span>() -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> index <span class="operator">=</span> readIndex</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> index <span class="operator">&lt;</span> <span class="keyword">self</span>.writeIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">defer</span> &#123;</span><br><span class="line">                index <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.array[wrapped: index]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了RingBuffer的定义之后，就可以实现基于RingBuffer的队列定义和实现了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">QueueRingBuffer</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ringBuffer: <span class="type">RingBuffer</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        ringBuffer <span class="operator">=</span> <span class="type">RingBuffer</span>&lt;<span class="type">T</span>&gt;(count: count)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ringBuffer.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> ringBuffer.first <span class="keyword">as?</span> <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ringBuffer.write(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty <span class="operator">?</span> <span class="literal">nil</span> : ringBuffer.read()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列的定义都大同小异，同样对QueueRingBuffer进行测试如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Debug the Queue with RingBuffer&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">QueueRingBuffer</span>&lt;<span class="type">String</span>&gt;(count: <span class="number">10</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue.peek <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Debug the Queue with RingBuffer---</span></span><br><span class="line"><span class="comment">RingBuffer&lt;String&gt;(array: [Optional(&quot;Ray&quot;), Optional(&quot;Brian&quot;), Optional(&quot;Eric&quot;), nil, nil, nil, nil, nil, nil, nil], readIndex: 0, writeIndex: 3)</span></span><br><span class="line"><span class="comment">RingBuffer&lt;String&gt;(array: [nil, Optional(&quot;Brian&quot;), Optional(&quot;Eric&quot;), nil, nil, nil, nil, nil, nil, nil], readIndex: 1, writeIndex: 3)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/ring-buffer-adc-disa.png"></p>
<p>基于环形缓冲区的队列具有相同的时间复杂性，和链表的入队和出队类似。唯一的区别是空间复杂度。环形缓冲区的大小是固定的，这意味着排队可能会失败。</p>
<p>到目前为止，您已经看到了三种实现：简单数组、双链表和环形缓冲区。</p>
<p>尽管它们看起来非常有用，但接下来您将看到使用两个栈实现的队列。您将看到它的空间位置如何远远优于链接列表。它也不需要像环形缓冲区那样的固定大小。</p>
<h2 id="基于双栈的队列"><a href="#基于双栈的队列" class="headerlink" title="基于双栈的队列"></a>基于双栈的队列</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">QueueStack</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leftStack: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rightStack: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双栈的思路其实很简单，无论何时加入元素都是讲元素添加到rightStack。当需要进行出队操作时，反转rightStack并将元素加入到leftStack中，然后在leftStack中即可使用FIFO原则进行出队操作了。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-stack-queue.png"></p>
<p>根据上图双栈的工作原理，实现队列的基本操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftStack.isEmpty <span class="operator">&amp;&amp;</span> rightStack.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">T</span>?&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="operator">!</span>leftStack.isEmpty <span class="operator">?</span> leftStack.last : rightStack.first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    rightStack.append(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> leftStack.isEmpty &#123;</span><br><span class="line">        leftStack <span class="operator">=</span> rightStack.reversed()</span><br><span class="line">        rightStack.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftStack.popLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队操作</strong></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-stack-queue-enqueue.png"></p>
<p><strong>出队操作</strong></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-stack-queue-dequeue.png"></p>
<p>测试代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Debug the Queue with Double Stack&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">QueueStack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Ray&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Brian&quot;</span>)</span><br><span class="line">    queue.enqueue(<span class="string">&quot;Eric&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue)</span><br><span class="line">    queue.dequeue()</span><br><span class="line">    <span class="built_in">print</span>(queue.peek <span class="operator">??</span> <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Debug the Queue with Double Stack---</span></span><br><span class="line"><span class="comment">[&quot;Ray&quot;, &quot;Brian&quot;, &quot;Eric&quot;]</span></span><br><span class="line"><span class="comment">[&quot;Brian&quot;, &quot;Eric&quot;]</span></span><br><span class="line"><span class="comment">Eric</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/double-stack-adv-disa.png"></p>
<p>与基于数组的实现相比，通过利用两个堆栈，您可以将出队操作转换为分步的O(1)操作。</p>
<p>此外，两个栈实现是完全动态的，并且没有基于环形缓冲区的队列所具有的固定大小限制。</p>
<p>最后，它在空间位置方面胜过了链表。这是因为数组元素在内存块中彼此相邻。因此，在第一次访问时，大量元素将加载到缓存中。</p>
<p><strong>基于双栈的队列</strong></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/queue-double-stack.png"></p>
<p><strong>基于链表的队列</strong></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/8/queue-linked-list.png"></p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>队列是一个FIFO的结构；</li>
<li>入队操作必须在队列的末尾；</li>
<li>出队操作必须在队列的开端；</li>
<li>数组中的元素在内存中是连续的，链表是分散的，并且链表的内存存储方式可能导致缓存未命中；</li>
<li>基于环形缓冲区的队列适用于固定大小的队列结构；</li>
<li>相比其他的数据结构，双栈结构的队列能够将出栈操作分散为O(1)的时间复杂度；</li>
<li>双栈的操作在空间复杂度上由于链表结构。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-25-Data-Structures-&amp;-Algorithms-in-Swift-10/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/10/cover.jpg" alt="\#10\ 二叉树及其有序、前序和后序遍历"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.087Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.087Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">6 分钟读完 (大约905个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-25-Data-Structures-&amp;-Algorithms-in-Swift-10/">\#10\ 二叉树及其有序、前序和后序遍历</a></h1><div class="content"><p>在上一文中认识了一般树结构，其每一个节点可能会有多个子节点。二叉树也是树型结构，只不过其每一个节点最多只有两个节点，通常称为<strong>左节点</strong>和<strong>右节点</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/10/binary-tree.png"></p>
<h2 id="二叉树的Swift实现"><a href="#二叉树的Swift实现" class="headerlink" title="二叉树的Swift实现"></a>二叉树的Swift实现</h2><p>首先定义二叉树的基本属性，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryNode</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">Element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> leftChild: <span class="type">BinaryNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rightChild: <span class="type">BinaryNode</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了二叉树的基本属性之后，就可以定义一颗二叉树了，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree: <span class="type">BinaryNode</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> zero <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> one <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> five <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">let</span> seven <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">let</span> eight <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">let</span> nine <span class="operator">=</span> <span class="type">BinaryNode</span>(value: <span class="number">9</span>)</span><br><span class="line">    </span><br><span class="line">    seven.leftChild <span class="operator">=</span> one</span><br><span class="line">    one.leftChild <span class="operator">=</span> zero</span><br><span class="line">    one.rightChild <span class="operator">=</span> five</span><br><span class="line">    seven.rightChild <span class="operator">=</span> nine</span><br><span class="line">    nine.leftChild <span class="operator">=</span> eight</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> seven</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>该二叉树的形态即如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/10/binary-tree-demo.png"></p>
<h2 id="二叉树图"><a href="#二叉树图" class="headerlink" title="二叉树图"></a>二叉树图</h2><p>数据结构的图像化能够帮助进一步理解数据结构，为了能够更加清晰的查看二叉树的树形结构，这里我们构造一个打印函数，以在Console中打印出二叉树的树形结构图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BinaryNode</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diagram(for: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">diagram</span>(<span class="params">for</span> <span class="params">node</span>: <span class="type">BinaryNode</span>?,</span><br><span class="line">                         <span class="keyword">_</span> <span class="params">top</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">_</span> <span class="params">root</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                         <span class="keyword">_</span> <span class="params">bottom</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root <span class="operator">+</span> <span class="string">&quot;nil <span class="subst">\n</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.leftChild <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> node.rightChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(node.value)</span><span class="subst">\n</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diagram(for: node.rightChild,</span><br><span class="line">                       top <span class="operator">+</span> <span class="string">&quot; &quot;</span>,</span><br><span class="line">                       top <span class="operator">+</span> <span class="string">&quot;┌──&quot;</span>,</span><br><span class="line">                       top <span class="operator">+</span> <span class="string">&quot;│ &quot;</span>) <span class="operator">+</span> root <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(node.value)</span><span class="subst">\n</span>&quot;</span> <span class="operator">+</span> diagram(for: node.leftChild,</span><br><span class="line">                                                                          bottom <span class="operator">+</span> <span class="string">&quot;│ &quot;</span>,</span><br><span class="line">                                                                          bottom <span class="operator">+</span> <span class="string">&quot;└──&quot;</span>,</span><br><span class="line">                                                                          bottom <span class="operator">+</span> <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对前面构建的二叉树进行打印，输出如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">---</span><span class="type">Example</span> of tree diagram<span class="operator">---</span></span><br><span class="line"> <span class="operator">┌──</span><span class="literal">nil</span> </span><br><span class="line"><span class="operator">┌──</span><span class="number">9</span></span><br><span class="line"><span class="operator">│</span> <span class="operator">└──</span><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="operator">│</span> <span class="operator">┌──</span><span class="number">5</span></span><br><span class="line"><span class="operator">└──</span><span class="number">1</span></span><br><span class="line"> <span class="operator">└──</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>在一般树中学习了深度优先和广度优先两种树型结构的遍历算法，经过小小的改动后，这两种遍历算法同样适用于二叉树的遍历。但是在二叉树结构中，更加关注的是另外三种遍历算法：有序、前序和后序遍历。</p>
<h3 id="有序遍历"><a href="#有序遍历" class="headerlink" title="有序遍历"></a>有序遍历</h3><p>有序遍历按照如下的顺序遍历节点：</p>
<ol>
<li>如果当前节点有左节点，则递归访问该节点的子节点；</li>
<li>然后访问当前节点</li>
<li>如果当前节点有有节点，则继续递归遍历该节点的子节点。</li>
</ol>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/10/in-order.png"></p>
<p>算法实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">traverseInOrder</span>(<span class="params">visit</span>: (<span class="type">Element</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        leftChild<span class="operator">?</span>.traverseInOrder(visit: visit)</span><br><span class="line">        visit(value)</span><br><span class="line">        rightChild<span class="operator">?</span>.traverseInOrder(visit: visit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;in-order traversal&quot;</span>) &#123;</span><br><span class="line">    tree.traverseInOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of in-order traversal---</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历总是先访问当前节点，然后递归遍历左节点和有节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/10/pre-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">traversePreOrder</span>(<span class="params">visit</span>: (<span class="type">Element</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    visit(value)</span><br><span class="line">    leftChild<span class="operator">?</span>.traversePreOrder(visit: visit)</span><br><span class="line">    rightChild<span class="operator">?</span>.traversePreOrder(visit: visit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;pre-order traversal&quot;</span>) &#123;</span><br><span class="line">    tree.traversePreOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of ore-order traversal---</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历总是先递归访问当前节点的左节点和右节点，然后在访问当前节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/10/post-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">traversePostOrder</span>(<span class="params">visit</span>: (<span class="type">Element</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    leftChild<span class="operator">?</span>.traversePostOrder(visit: visit)</span><br><span class="line">    rightChild<span class="operator">?</span>.traversePostOrder(visit: visit)</span><br><span class="line">    visit(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;post-order traversal&quot;</span>) &#123;</span><br><span class="line">    tree.traversePostOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of post-order traversal---</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>二叉树数据结构是其他树形数据结构的基础，很多类型的树例如二叉搜索树、AVL树等，都以二叉树为基础，并在其上增加插入和删除等操作行为；</li>
<li>有序、前序和后序并不仅仅针对二叉树非常重要，在其他的树形结构中，这些遍历算法依然有效且重要。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-03-Data-Structures-&amp;-Algorithms-in-Swift-04/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/4/cover.jpg" alt="\#4\ 单向链表的Swift实现"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.086Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.086Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">19 分钟读完 (大约2785个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-03-Data-Structures-&amp;-Algorithms-in-Swift-04/">\#4\ 单向链表的Swift实现</a></h1><div class="content"><p><strong>链表</strong>是一种线性的、单向的数据结构，不同于数组连续的内存存储，链表中的元素在内存是独立的对象。链表具有以下理论优势：</p>
<ul>
<li>元素插入和从列表头部删除元素的时间恒定；</li>
<li>具有可靠的性能特性。</li>
</ul>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/a-linked-list.png"></p>
<p>如上图所示，链表的结构是一个<strong>节点</strong>结构。节点具有两个功能：</p>
<ol>
<li>保存值；</li>
<li>保存下一个节点的指针。<strong>nil</strong>节点表示链表的结尾。</li>
</ol>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/linked-list-node.png"></p>
<blockquote>
<p>链表分为<strong>单向链表</strong>和<strong>双向链表</strong>，双向链表的每个阶段，还具有指向前一个节点的指针。</p>
</blockquote>
<p>在本文中，将学习链表的Swift实现，以及关于链表的一些通用的操作。将了解每个操作的时间复杂性，并实现一个整洁的小 Swift 功能，称为<strong>写入时复制</strong>。</p>
<h2 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h2><p>首先我们需要定义<strong>节点</strong>的数据结构，使用Xcode的新建Playground，并在<strong>Sources</strong>目录下新建<strong>Node.swift</strong>文件。根据对节点功能的了解，在Node的结构中，应该有至少两个数据属性，一个用来存储，一个用于指向，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;<span class="title class_">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">Node</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">value</span>: <span class="type">Value</span>, <span class="params">next</span>: <span class="type">Node</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">        <span class="keyword">self</span>.next <span class="operator">=</span> next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Node</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> next <span class="operator">=</span> next <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(value)</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(value)</span> -&gt;&quot;</span> <span class="operator">+</span> <span class="type">String</span>(describing: next) <span class="operator">+</span> <span class="string">&quot; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便定义好了一个单向链表的节点结构。为了能够在测试方便，可以添加如下工具函数：</p>
<blockquote>
<p>新建helper.swift文件，编写工具类函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">example</span>(<span class="params">of</span> <span class="params">description</span>: <span class="type">String</span>, <span class="params">action</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;---Example of <span class="subst">\(description)</span>---&quot;</span>)</span><br><span class="line"> action()</span><br><span class="line"> <span class="built_in">print</span>()</span><br><span class="line"><span class="operator">&gt;</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时，回到主Playground，定义一个链表结构的示例，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;creating and linking nodes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node1 <span class="operator">=</span> <span class="type">Node</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> node2 <span class="operator">=</span> <span class="type">Node</span>(value: <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> node3 <span class="operator">=</span> <span class="type">Node</span>(value: <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    node1.next <span class="operator">=</span> node2</span><br><span class="line">    node2.next <span class="operator">=</span> node3</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(node1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of creating and linking nodes---</span></span><br><span class="line"><span class="comment">// 1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<p>示例所定义的链表结构，图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/demo-linked-list-1.png"></p>
<p>一个单向链表，包含了三个值分别为1、2、3的节点。这样的链表定义似乎已经完成了，但是当节点的数量上升后，我们就需要每个节点都进行赋值和指针指向的定义，显然这样的方式即笨重且不灵活。就实用性而言，目前的结构还需要进行优化，缓解此问题的常用方法是构建一个专门管理Node节点对象的链表结构，如下：</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>Sources</strong>目录下新建<strong>LinkedList.swift</strong>文件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">LinkedList</span>&lt;<span class="title class_">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> head: <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> tail: <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head <span class="operator">==</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">LinkedList</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> head <span class="operator">=</span> head <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Empty Linked List&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(describing: head)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构下的链表具有<strong>头</strong>和<strong>尾</strong>概念，分别指向链表的第一个节点和末尾节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/head-tail.png"></p>
<h2 id="向链表中添加值"><a href="#向链表中添加值" class="headerlink" title="向链表中添加值"></a>向链表中添加值</h2><p>有了节点管理形式的链表后，需要为该链表<strong>添加</strong>头结点，<strong>追加</strong>末尾节点，以及<strong>插入</strong>节点，因此需要定义三个通用的方法：</p>
<ul>
<li><strong>push</strong>：在链表的头部添加值；</li>
<li><strong>append</strong>：在链表的末尾添加值；</li>
<li>**insert(after:)**：在链表的特定节点后添加值。</li>
</ul>
<h3 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a>push操作</h3><p>在链表的头部位置添加值，也就是<strong>头插法</strong>，其时间复杂度为**O(1)**。其实现较为简单，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">    head <span class="operator">=</span> <span class="type">Node</span>(value: value, next:head)</span><br><span class="line">    <span class="keyword">if</span> tail <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        tail <span class="operator">=</span> head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>struct</strong> 和 <strong>enum</strong> 的值在内部是不能修改的, 如果要修改需要在方法前面添加 <strong>mutating</strong> 修饰符</p>
</blockquote>
<p>对于一个空的链表来说，头节点也是尾节点，采用头插法插入值后，每次插入的值都会放在链表的头部。</p>
<p>回到主Playground，进行链表的<strong>push</strong>操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;push&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of push---</span></span><br><span class="line"><span class="comment">// 1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h3 id="append操作"><a href="#append操作" class="headerlink" title="append操作"></a>append操作</h3><p>在链表的尾部位置添加值，也就是<strong>尾插法</strong>，其时间复杂度**O(1)**。实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果链表尾空，使用push操作新建节点，更新链表的头节点和尾节点。</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        push(value)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新节点，赋值为尾部节点的下一个节点，将节点连接起来。</span></span><br><span class="line">    tail<span class="operator">!</span>.next <span class="operator">=</span> <span class="type">Node</span>(value: value)</span><br><span class="line">    <span class="comment">// 因为是尾部拼接节点，所以新的节点将成为尾部节点</span></span><br><span class="line">    tail <span class="operator">=</span> tail<span class="operator">!</span>.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到主Playground，进行链表的<strong>append</strong>操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;append&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.append(<span class="number">1</span>)</span><br><span class="line">    list.append(<span class="number">2</span>)</span><br><span class="line">    list.append(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of append---</span></span><br><span class="line"><span class="comment">// 1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h3 id="insert-after-操作"><a href="#insert-after-操作" class="headerlink" title="insert(after:) 操作"></a>insert(after:) 操作</h3><p><strong>插入</strong>操作是指在链表的特定节点位置，插入一个新的节点。该操作需要两个步骤完成：</p>
<ol>
<li>查找特定节点</li>
<li>插入新的节点</li>
</ol>
<p>首先需要根据给定的索引，查找特定的节点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">node</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;? &#123;</span><br><span class="line">    <span class="comment">// 由于只能从头部遍历链表，因此先创建当前节点和索引的引用</span></span><br><span class="line">    <span class="keyword">var</span> currentNode <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> currentIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用while循环，将引用向下移动到列表中，直到达到所需的索引。 空列表或越界索引将导致nil返回值。</span></span><br><span class="line">    <span class="keyword">while</span> currentNode <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> currentIndex <span class="operator">&lt;</span> index &#123;</span><br><span class="line">        currentNode <span class="operator">=</span> currentNode<span class="operator">!</span>.next</span><br><span class="line">        currentIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> currentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要说明的是，我们针对的是<strong>单向链表</strong>，链表节点的访问只能从头节点依次向后访问，在实现节点的查找时，必须使用迭代的方式进行节点遍历。</p>
<p>找到了特定索引的节点后，接下来就是插入一个新的节点了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Node</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果要插入新节点的位置是尾节点，则直接使用append操作，添加新的尾节点</span></span><br><span class="line">    <span class="keyword">guard</span> tail <span class="operator">!==</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        append(value)</span><br><span class="line">        <span class="keyword">return</span> tail<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 否则新建节点，并赋值为查找节点的下一个节点，将节点进行连接</span></span><br><span class="line">    node.next <span class="operator">=</span> <span class="type">Node</span>(value: value, next: node.next)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> node.next<span class="operator">!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@discardableResult</strong>指的是接口的调用者忽略此方法的返回值，而编译器不会向上和向下跳过警告。</p>
</blockquote>
<p>完成逻辑编写后，回到主Playground，进行链表的**insert(after:)**操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;inserting at a particular index&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before inserting: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> middleNode <span class="operator">=</span> list.node(at: <span class="number">1</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span> <span class="operator">...</span> <span class="number">3</span> &#123;</span><br><span class="line">        list.insert(<span class="operator">-</span><span class="number">1</span>, after: middleNode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After inserting: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of inserting at a particular index---</span></span><br><span class="line"><span class="comment">// Before inserting: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// After inserting: 1 -&gt;2 -&gt;-1 -&gt;-1 -&gt;-1 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h3 id="性能分析-—-时间复杂度"><a href="#性能分析-—-时间复杂度" class="headerlink" title="性能分析 — 时间复杂度"></a>性能分析 — 时间复杂度</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/performance-analysis.png"></p>
<h2 id="从链表中删除值"><a href="#从链表中删除值" class="headerlink" title="从链表中删除值"></a>从链表中删除值</h2><p>对应向链表中添加值，从链表中删除值同样对应三个主要的方法：</p>
<ol>
<li><strong>pop</strong>：从链表头部删除值；</li>
<li><strong>removeLast</strong>：从链表尾部删除值；</li>
<li>**remove(after:)**：删除指定位置的节点值。</li>
</ol>
<h3 id="pop-操作"><a href="#pop-操作" class="headerlink" title="pop 操作"></a>pop 操作</h3><p>从链表的头部直接删除值的操作和给链表头部添加值的操作<strong>push</strong>有点类似，其算法也相对简单，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        head <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">        <span class="keyword">if</span> isEmpty &#123;</span><br><span class="line">            tail <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head<span class="operator">?</span>.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pop</strong>方法的返回值是被删除的节点的值。该结果是一个<strong>可选值</strong>，因为链表有可能是一个空链表。</p>
<p>将原链表的头节点向前移动一个位置即可，在<strong>ARC</strong>模式下，系统内存会在头部节点无任何引用的时候，自动清理原链表的头节点资源。如果移动头节点后，链表是一个空链表，需要将尾部节点重新置空。</p>
<p>回到主Playground，尝试进行链表的<strong>pop</strong>操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;pop&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before popping list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> poppedValue <span class="operator">=</span> list.pop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After popping list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Popped value: &quot;</span> <span class="operator">+</span> <span class="type">String</span>(describing: poppedValue))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of pop---</span></span><br><span class="line"><span class="comment">// Before popping list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// After popping list: 2 -&gt;3 </span></span><br><span class="line"><span class="comment">// Popped value: Optional(1)</span></span><br></pre></td></tr></table></figure>

<h3 id="removeLast-操作"><a href="#removeLast-操作" class="headerlink" title="removeLast 操作"></a>removeLast 操作</h3><p>删除链表的尾部节点相对比较复杂，算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeLast</span>() -&gt; <span class="type">Value</span>? &#123;</span><br><span class="line">    <span class="comment">// 如果链表的头节点为nil，无节点移除，故返回nil</span></span><br><span class="line">    <span class="comment">// 这里也可以直接使用isEmpty进行判断</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> head <span class="operator">=</span> head <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果链表仅有一个节点，头节点也是末尾节点，因此直接使用pop()操作即可</span></span><br><span class="line">    <span class="keyword">guard</span> head.next <span class="operator">!=</span> <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建节点的引用</span></span><br><span class="line">    <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> head</span><br><span class="line">    <span class="comment">// 遍历链表节点，直到当前节点的下一个节点为nil，则表明当前节点已经是末尾节点了</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> next <span class="operator">=</span> current.next &#123;</span><br><span class="line">        prev <span class="operator">=</span> current</span><br><span class="line">        current <span class="operator">=</span> next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前节点的前一个节点的next指针值为nil，并更新末尾节点</span></span><br><span class="line">    prev.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    tail <span class="operator">=</span> prev</span><br><span class="line">    <span class="comment">// 返回被删除的值</span></span><br><span class="line">    <span class="keyword">return</span> current.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>回到主Playground，尝试进行链表的<strong>removeLast</strong>操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;removing the last node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before remove last node: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> removedValue <span class="operator">=</span> list.removeLast()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After remove last node: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Removed value: &quot;</span> <span class="operator">+</span> <span class="type">String</span>(describing: removedValue))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of removing the last node---</span></span><br><span class="line"><span class="comment">// Before remove last node: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// After remove last node: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// Removed value: Optional(3)</span></span><br></pre></td></tr></table></figure>

<p><strong>removeLast</strong>操作需要遍历整个链表，因此其时间复杂度为**O(n)**。</p>
<h3 id="remove-after-操作"><a href="#remove-after-操作" class="headerlink" title="remove(after:) 操作"></a>remove(after:) 操作</h3><p>**remove(after:)<strong>操作类似</strong>insert(after:)**，首先需要找到特定位置的节点，然后执行删除操作。算法过程如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/remove-at.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Value</span>? &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.next <span class="operator">===</span> tail &#123;</span><br><span class="line">            tail <span class="operator">=</span> node</span><br><span class="line">        &#125;</span><br><span class="line">        node.next <span class="operator">=</span> node.next<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.next<span class="operator">?</span>.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点的引用清理放在<strong>defer</strong>区块内，当删除的节点无任何引用的时候，系统内存会自动清理其占用资源。</p>
<p>回到主Playground，尝试进行链表的**remove(after:)**操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;removing a node after a particular node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Before removing at particular index: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> index <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> node <span class="operator">=</span> list.node(at: index <span class="operator">-</span> <span class="number">1</span>)<span class="operator">!</span></span><br><span class="line">    <span class="keyword">let</span> removedValue <span class="operator">=</span> list.remove(after: node)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After removing at index <span class="subst">\(index)</span>: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Removed value: &quot;</span> <span class="operator">+</span> <span class="type">String</span>(describing: removedValue))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of removing a node after a particular node---</span></span><br><span class="line"><span class="comment">// Before removing at particular index: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// After removing at index 1: 1 -&gt;3 </span></span><br><span class="line"><span class="comment">// Removed value: Optional(2)</span></span><br></pre></td></tr></table></figure>

<h3 id="性能分析-—-时间复杂度-1"><a href="#性能分析-—-时间复杂度-1" class="headerlink" title="性能分析 — 时间复杂度"></a>性能分析 — 时间复杂度</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/4/remove-performance-analysis.png"></p>
<h2 id="阶段性总结"><a href="#阶段性总结" class="headerlink" title="阶段性总结"></a>阶段性总结</h2><p>支持关于LinkedList的定义和基本操作就完成了，对于链表而言，单向链表只是一个开始，这里没有涉及到双向链表。</p>
<ul>
<li>链表是有一个个节点链接而成的，每个节点具有保存值和下一个节点索引的属性；</li>
<li>链表中节点值的添加涉及头尾和指定位置，在指定位置插入需要两步操作，首先找到给定位置的节点，然后删除其后的一个节点并重建链接；</li>
<li>链表中节点值的删除同样涉及头尾和指定位置；</li>
<li>在进行链表的操作时，需要时刻记住在必须的时机更新链表的节点指向指针，保证链表的链接性。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-27-Data-Structures-&amp;-Algorithms-in-Swift-12/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/12/cover.png" alt="\#12\ 自平衡二叉搜索树（AVL Trees）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.085Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.086Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">16 分钟读完 (大约2460个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-27-Data-Structures-&amp;-Algorithms-in-Swift-12/">\#12\ 自平衡二叉搜索树（AVL Trees）</a></h1><div class="content"><p>在上文中，已经了解二叉搜索树的O(log n)性能特征，但是当二叉搜索树节点删除中，可能会出现不平衡的树，并降低树的性能到O(n)。这一文的内容将学习另一种改进了的二叉搜索树 — 自平衡二叉搜索树。</p>
<blockquote>
<p>1962年，Georgy Adelson-Velsky和Evgenii Landis提出了第一个自平衡二进制搜索树：AVL树。</p>
</blockquote>
<h2 id="理解什么是平衡"><a href="#理解什么是平衡" class="headerlink" title="理解什么是平衡"></a>理解什么是平衡</h2><p>自平衡二叉搜索树，简称平衡树，是在二叉搜索树的基础上改进的，首先了解一下平衡树的三种平衡状态。</p>
<p><strong>完全平衡树</strong></p>
<p>二叉搜索树的理想形式便是完全平衡状态，也就是说二叉搜索树的每个层级从上之下均存在节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/perfect-tree.png"></p>
<p>完全平衡树不仅仅整棵树是对称的，而且最底部的叶子都均存在节点。</p>
<p><strong>“够好”的平衡树</strong></p>
<p>尽管完全平衡是理想的平衡树状态，但是在现实中往往难以实现，要达到完全平衡的树结构，需要节点有确切的数量，才有可能达到完全平衡，因此只有一定数量的元素才能平衡。</p>
<p>例如一棵树有1个、3个、4个节点的时候，是可以达到完全平衡的，但是当树有2个、4个、5个或6个节点的时候，却不能达到完全平衡，因为树的最后一层无法完全被填满。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/balance-tree.png"></p>
<p>平衡树的定义是树的每一个层级必须被填满（底部层级除外）。在大多数情况下，二叉树是可以做到的最好的结构。</p>
<p><strong>不平衡树</strong></p>
<p>最后一种状态是不平衡的状态，二叉搜索树的不平衡状态会带来各种等级的性能损失。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/unbanlance-tree.png"></p>
<p>保持树的平衡会带来查找、插入和移除元素操作O(log n)的时间复杂度。当树的结构不平衡是，AVL树会自动调整树的结构，使得树结构保持平衡，从而带来良好地时间复杂度等。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>AVL树和二叉搜索树有很多地方都是相同的实现，但是为了便于区分，我们将新建文件重新编写关于AVL树的实现。</p>
<h3 id="平衡度衡量"><a href="#平衡度衡量" class="headerlink" title="平衡度衡量"></a>平衡度衡量</h3><p>要确保二叉树的平衡，就需要一种能够衡量二叉树是否平衡的方法。在AVL树中，每个节点都有一个 <strong>height</strong> 属性，该属性描述了当前节点到叶子节点的<strong>最长距离</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/node-marks-height.png"></p>
<p>我们新建AVLNode类，添加存储节点高度的变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在使用中，将使用节点的相对高度来确定节点是否平衡。</p>
<p>AVL树中左节点和有节点的高度差最多相差1，这个差值称之为<strong>平衡因子</strong>。为了计算的方便，对节点增加如下变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> balanceFactor: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftHeight <span class="operator">-</span> rightHeight</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> leftHeight: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> leftChild<span class="operator">?</span>.height <span class="operator">??</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> rightHeight: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rightChild<span class="operator">?</span>.height <span class="operator">??</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>balanceFactor</code>平衡因子计算的是左树和右树的高度差，如果子节点为nil，则节点的高度为-1。例如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/avl-tree-demo.png"></p>
<p>该树是一个平衡的二叉树，但是如果增加一个节点40的话，就会改变为不平衡的树：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/unbalance-tree.png"></p>
<p>从图中的平衡因子即可判断出该树处于一个不平衡的状态。为了使得不平衡树改变形态，而成为平衡树，需要进一步的操作。</p>
<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>应用于二叉搜索树，使得其平衡的操作称之为<strong>旋转</strong>。共有四种选装的操作，分别是<strong>左旋转</strong>、<strong>左-右旋转</strong>、<strong>右旋转</strong>、<strong>右-左旋转</strong>。</p>
<p><strong>左旋转</strong></p>
<p>例如上述不平衡的二叉树中，插入节点40导致树处于不平衡的状态，而是用左旋转可以解决此不平衡问题。左旋转的工作原理如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/left-rotation.png"></p>
<p>树在旋转前后会由两点不同之处：</p>
<ul>
<li>树节点的有序遍历保持不变；</li>
<li>旋转后，树的深度减少一级。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">leftRotate</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot <span class="operator">=</span> node.rightChild<span class="operator">!</span></span><br><span class="line">    node.rightChild <span class="operator">=</span> pivot.leftChild</span><br><span class="line">    pivot.leftChild <span class="operator">=</span> node</span><br><span class="line">    </span><br><span class="line">    node.height <span class="operator">=</span> <span class="built_in">max</span>(node.leftHeight, node.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    pivot.height <span class="operator">=</span> <span class="built_in">max</span>(pivot.leftHeight, pivot.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/left-rotation-done.png"></p>
<p><strong>右旋转</strong></p>
<p>右旋转和左旋转类似，如果是由于左节点导致了树不平衡，则使用右旋转的方式，其原理如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/right-rotation.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">rightRotate</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot <span class="operator">=</span> node.leftChild<span class="operator">!</span></span><br><span class="line">    node.leftChild <span class="operator">=</span> pivot.rightChild</span><br><span class="line">    pivot.rightChild <span class="operator">=</span> node</span><br><span class="line">        </span><br><span class="line">    node.height <span class="operator">=</span> <span class="built_in">max</span>(node.leftHeight, node.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    pivot.height <span class="operator">=</span> <span class="built_in">max</span>(pivot.leftHeight, pivot.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>右-左旋转</strong></p>
<p>左旋转和右旋转的操作都有一个特点是：均平衡了树的左节点或右节点。假设有如下的不平衡树：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/left-right-nodes-tree.png"></p>
<p>单纯使用左旋转不能得到平衡树，针对此种情况可以先进行右旋转，使得节点均有右节点，然后再使用左旋转，以达到平衡树状态。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/right-left-rotation.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">rightLeftRotate</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> rightChild <span class="operator">=</span> node.rightChild <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.rightChild <span class="operator">=</span> rightRotate(rightChild)</span><br><span class="line">    <span class="keyword">return</span> leftRotate(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>左-右旋转</strong></p>
<p>左-右旋转和右-左旋转针对的情形类似，当单纯使用左旋转无法达到平衡的时候，根据节点的情况，再次进行右旋转，以达到平衡状态。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/left-right-rotation.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">leftRightRotate</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> leftChild <span class="operator">=</span> node.leftChild <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.leftChild <span class="operator">=</span> leftRotate(leftChild)</span><br><span class="line">    <span class="keyword">return</span> rightRotate(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h3><p>进行了树的节点旋转后，虽然形态上会达到平衡，但是某些节点可能破坏了二叉搜索树的特性，因此还需要根据不同的情形，对数的节点进行交换，这里交换的根据是根据节点的平衡因子进行不同的操作。算法结构如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">balanced</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> node.balanceFactor &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="operator">-</span><span class="number">2</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法会根据三种情况进行节点的转换：</p>
<ol>
<li>平衡因子<em>balanceFactor</em>为2的时候，表示节点的左子节点多于右子节点，意味着节需要使用右旋或者左-右旋转；</li>
<li>平衡因子<em>balanceFactor</em>为-2的时候，表示节点的右子节点多于左子节点，意味着需要使用左旋或者右-左旋转；</li>
<li>除了这两种情况之外，表示当前节点处于平衡状态，不需要进行任何的转换。</li>
</ol>
<p>平衡因子<em>balanceFactor</em>符号能够确定需要使用单旋还是双旋。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/12/balanceFactor-single-or-double-rotation.png"></p>
<p>完整的算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">balanced</span>(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> node.balanceFactor &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> leftChild <span class="operator">=</span> node.leftChild, leftChild.balanceFactor <span class="operator">==</span> <span class="operator">-</span><span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRightRotate(node)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="operator">-</span><span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> rightChild <span class="operator">=</span> node.rightChild, rightChild.balanceFactor <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightLeftRotate(node)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h3><p>至此，节点调整，使得树平衡的工作已经完成了，而该平衡操作大部分情况下是在向树插入新的节点的时候进行的，因此完成插入算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">    root <span class="operator">=</span> insert(from: root, value: value)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="params">from</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;?, <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AVLNode</span>(value: value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> value <span class="operator">&lt;</span> node.value &#123;</span><br><span class="line">        node.leftChild <span class="operator">=</span> insert(from: node.leftChild, value: value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.rightChild <span class="operator">=</span> insert(from: node.rightChild, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> balancedNode <span class="operator">=</span> balanced(node)</span><br><span class="line">    balancedNode.height <span class="operator">=</span> <span class="built_in">max</span>(balancedNode.leftHeight, balancedNode.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> balancedNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点的插入算法也适用于新建一颗AVL树，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;repeated insertions in sequence&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tree <span class="operator">=</span> <span class="type">AVLTree</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">15</span> &#123;</span><br><span class="line">        tree.insert(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(tree)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of repeated insertions in sequence---</span></span><br><span class="line"><span class="comment">  ┌──14</span></span><br><span class="line"><span class="comment"> ┌──13</span></span><br><span class="line"><span class="comment"> │ └──12</span></span><br><span class="line"><span class="comment">┌──11</span></span><br><span class="line"><span class="comment">│ │ ┌──10</span></span><br><span class="line"><span class="comment">│ └──9</span></span><br><span class="line"><span class="comment">│  └──8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">│  ┌──6</span></span><br><span class="line"><span class="comment">│ ┌──5</span></span><br><span class="line"><span class="comment">│ │ └──4</span></span><br><span class="line"><span class="comment">└──3</span></span><br><span class="line"><span class="comment"> │ ┌──2</span></span><br><span class="line"><span class="comment"> └──1</span></span><br><span class="line"><span class="comment">  └──0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="节点的移除"><a href="#节点的移除" class="headerlink" title="节点的移除"></a>节点的移除</h3><p>移除树中的节点，也会导致树不平衡，因此在移除算法中也需要对树的平衡性进行调整。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">    root <span class="operator">=</span> remove(from: root, value: value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">from</span> <span class="params">node</span>: <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;?, <span class="params">value</span>: <span class="type">Element</span>) -&gt; <span class="type">AVLNode</span>&lt;<span class="type">Element</span>&gt;? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> value <span class="operator">==</span> node.value &#123;</span><br><span class="line">        <span class="keyword">if</span> node.leftChild <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> node.rightChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.leftChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.rightChild</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.rightChild <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.leftChild</span><br><span class="line">        &#125;</span><br><span class="line">        node.value <span class="operator">=</span> node.rightChild<span class="operator">!</span>.min.value</span><br><span class="line">        node.rightChild <span class="operator">=</span> remove(from: node.rightChild, value: node.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&lt;</span> node.value &#123;</span><br><span class="line">        node.leftChild <span class="operator">=</span> remove(from: node.leftChild, value: value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.rightChild <span class="operator">=</span> remove(from: node.rightChild, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> balancedNode <span class="operator">=</span> balanced(node)</span><br><span class="line">    balancedNode.height <span class="operator">=</span> <span class="built_in">max</span>(balancedNode.leftHeight, balancedNode.rightHeight) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> balancedNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;removing a vaue&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tree <span class="operator">=</span> <span class="type">AVLTree</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    tree.insert(<span class="number">15</span>)</span><br><span class="line">    tree.insert(<span class="number">10</span>)</span><br><span class="line">    tree.insert(<span class="number">16</span>)</span><br><span class="line">    tree.insert(<span class="number">18</span>)</span><br><span class="line">    <span class="built_in">print</span>(tree)</span><br><span class="line">    </span><br><span class="line">    tree.remove(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(tree)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of removing a vaue---</span></span><br><span class="line"><span class="comment"> ┌──18</span></span><br><span class="line"><span class="comment">┌──16</span></span><br><span class="line"><span class="comment">│ └──nil </span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">└──10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">┌──18</span></span><br><span class="line"><span class="comment">16</span></span><br><span class="line"><span class="comment">└──15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>移除了元素10之后，树进行了平衡调整（左旋），依然保持树的平衡性。由于节点的插入和移除操作同于二叉搜索树，因此其时间复杂度依然是O(log n)。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>自平衡树在节点的插入和移除过程中，增加平衡性调节操作，保持其执行效率不会降低；</li>
<li>AVL树在树不平衡的情况下，通过重新调整树的部分节点，而使得树保持平衡。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-02/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/2/cover.jpg" alt="\#2\ 认识 Array &amp; Dictionary"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.082Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.082Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">14 分钟读完 (大约2050个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-02/">\#2\ 认识 Array &amp; Dictionary</a></h1><div class="content"><p>在 <strong>Swift Standard Library</strong> 中包含了Swift语言的核心组件。在标准库框架中你可以发现很多可用于应用程序开发的同居和类型，在开始设计自己的数据结构前，了解Swift语言本身的语言特性是设计良好数据结构和算法设计的基础。</p>
<p>在此篇内容中，着重了解 Swift Standard Library 中的两大数据结构：<strong>Array &amp; Dictionary</strong>。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p><strong>Array</strong> 是一个通用型的容器组件，用于存储元素的有序集合，在Swift语言中被大量使用。<strong>Swift Standard Library</strong>中的 <strong>Array</strong> 可以使用任意的数据类型创建数组。例如使用文字创建数据时，文字使用用逗号分隔，方括号括起来，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people <span class="operator">=</span> [<span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Stanley&quot;</span>, <span class="string">&quot;Ringo&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>在Swift中，Array的定义是通过协议定义的，不同的协议层给Array提供了不同的能力。例如，数组是一个**序列(Sequence)<strong>，至少可以遍历它一次。它也是一个</strong>集合(Collection)<strong>，又可以被多次遍历，而且不具有破坏性，并且可以使用下标运算符访问它。数组也是一个</strong>随机访问集合(RandomAccessCollection)**，它保证了效率。</p>
<p>上文提到，Swift中的Array是一个通用型的数据结构，意味着你可以在数据中使用任何数据类型。事实上，在Swift标准库中有大量的通用型代码。</p>
<p>对于任何数据结构，都会有一些显著性的特征值的关注，对于Array来说，首先需要关注的是 — <strong>顺序</strong>。</p>
<h5 id="顺序（Order）"><a href="#顺序（Order）" class="headerlink" title="顺序（Order）"></a>顺序（Order）</h5><p>Array中的元素（Element）具有显性的顺序，例如上述<code>people</code>数组，”Brian” 会出现在 “Stanley” 的前面。</p>
<p>数据中的所有元素都有一个明确的基于0开始的整数类型下标。例如上述例子中，数组中包含了三个元素，每一个下标将对应唯一的一个元素，可以通过下标的方式获取具体的某个元素。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people[<span class="number">0</span>] <span class="comment">// &quot;Brian&quot;</span></span><br><span class="line">people[<span class="number">1</span>] <span class="comment">// &quot;Stanley&quot;</span></span><br><span class="line">people[<span class="number">2</span>] <span class="comment">// &quot;Ringo&quot;</span></span><br></pre></td></tr></table></figure>

<p>数据中的元素顺序是显著性的，该顺序也是数组的数据结构所定义的，但是需要注意的是并不是所有的集合类型都有显著性的顺序。例如<strong>Dictionary</strong>，并没有显著性的顺序，仅有有一个弱化的顺序的概念。</p>
<h5 id="随机访问权限（Random-access）"><a href="#随机访问权限（Random-access）" class="headerlink" title="随机访问权限（Random-access）"></a>随机访问权限（Random-access）</h5><p><strong>随机访问权限</strong>是数组的数据结构所定义的特性，表示在数组可以在恒定的时间内完成数据元素的检索。例如在上述数组中，”Brian”元素的获取总是在恒定的时间内。同样地，并不是所有的集合类型都是如此，例如链表、树并没有随机访问权限，元素的获取也不会有恒定的时间。</p>
<h3 id="数组的性能"><a href="#数组的性能" class="headerlink" title="数组的性能"></a>数组的性能</h3><p>随机访问权限的另一个影响是数组操作的<strong>性能</strong>。对于一个开发者而言，对于数组的各种操作，了解其在数据量持续增大的情况下性能的变更，是影响程序是否高效的关键因素之一。而对于数组而言，影响其性能的因素主要有两个：</p>
<h5 id="插入位置（Insertion-location）"><a href="#插入位置（Insertion-location）" class="headerlink" title="插入位置（Insertion location）"></a>插入位置（Insertion location）</h5><p>在Swift中，数组的插入操作大多数高效的规则是进行数据元素的追加，也就是在现有数据上使用追加的方式，在数据末尾添加新的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">people.append(<span class="string">&quot;Charles&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(people)  <span class="comment">// [&quot;Brian&quot;, &quot;Stanley&quot;, &quot;Ringo&quot;, &quot;Charles&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上述示例中使用<code>append</code>方法，在数组的末尾位置插入了新的元素”Charles”，这个操作的耗时是恒定的，也意味着不论原数组中的元素有多少，在该数组的末尾插入新的元素并不会带来额外的时间消耗。但是如果在原数组的除了末尾位置之外的其他既定位置插入元素，例如在数组的中间位置插入新的元素，会带来更多的时间消耗。</p>
<p>举个例子，人们正在按秩序排队进行结账，此时来了一个新的顾客，在不妨碍其他任何人的情况下，新顾客应该直接在队伍的尾部加入队伍，也不会引起其他人的反感等，而如果该新顾客非要走到队伍中间位置插队，那么该位置后面的每一个人都需要向后挪动，这样至少给原有队伍中一半的人带来的愤怒。</p>
<p>有一条经验是，<strong>如果在开发工作中，你需要在原有的集合类型数据结构中，频繁的在集合的头部或者非末尾位置进行元素的插入，那你可能需要重新设计你的数据结构了。</strong></p>
<h5 id="数组容量（Capacity）"><a href="#数组容量（Capacity）" class="headerlink" title="数组容量（Capacity）"></a>数组容量（Capacity）</h5><p>影响数组性能的另一个因素便是<strong>数组的容量</strong>，这里所说的容量是数组的预制容量。Swift中的数组是根据数组中的元素总量来进行内存空间的预开辟的。如果数组的容量已经达到了预设定的最大值，那么数组必须重构自己来为新的元素增加空间。这一步操作是底层帮你完成的，系统会拷贝所有原有的元素并在内存中新建一个更大容量的数组，这将带来性能和时间的消耗，因为数组中的每一个元素都需要被访问到并进行拷贝。</p>
<p>也就意味着，数组的插入操作，除了在数组的末尾进行追加式插入新元素外，其他的插入操作都会使得数组进行 <em>n</em>（数组大小） 步才能完整操作。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p><strong>Dictionary</strong> 是另一种集合类型的数据结构，存储<strong>key-value对</strong>数据。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scores: [<span class="type">String</span>: <span class="type">Int</span>] <span class="operator">=</span> [<span class="string">&quot;Eric&quot;</span>: <span class="number">9</span>, <span class="string">&quot;Mark&quot;</span>: <span class="number">12</span>, <span class="string">&quot;Wayne&quot;</span>: <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>在字典中没有任何既定的顺序，也不能通过索引插入。在Swift中，字典的必备条件是key值必须是<code>Hashable</code>的。幸运的是，在最近几个版本的Swift中，几乎所有的标准类型都遵循<code>Hashable</code>协议，开发者不用自己去实现<code>Hashable</code>了。</p>
<p>在字典中插入新的数据，一般情况下，通过如下的句法进行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[<span class="string">&quot;Andrew&quot;</span>] <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这样底层实现会创建一个新的<code>key-value</code>对，并添加到字典中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;Eric&quot;</span>: <span class="number">9</span>, <span class="string">&quot;Andrew&quot;</span>: <span class="number">0</span>, <span class="string">&quot;Mark&quot;</span>: <span class="number">12</span>, <span class="string">&quot;Wayne&quot;</span>: <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>可以看到字典是无序的集合类型。对于同一个字典，新数据的插入，会访问到字典中的每一个键值对，其消耗的时间是相同的，直到集合被改变。对于字典而言，并不需要关心数据插入和获取的时间消耗问题，每次操作都是字典中数据量的总访问时间。但是相对于数组来说，字典的数据获取会更高效。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>每一种数据结构都有其优点和缺点，了解数据结构的优缺点，能够为高效的软件性能提供帮助；</li>
<li>数组是有序的集合。数组的插入操作会影响数组的操作耗时，末尾追加除外。如果在软件开发中，需要在数组的非末尾位置频繁的进行插入，可能需要重新设计数据结构，例如链表等；</li>
<li>字典是无序的集合。字典为了快速插入和搜索而牺牲了保持元素顺序的能力。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Data-Structures-Algorithms-in-Swift/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/categories/Data-Structures-Algorithms-in-Swift/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Data-Structures-Algorithms-in-Swift/">1</a></li><li><a class="pagination-link is-current" href="/categories/Data-Structures-Algorithms-in-Swift/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.804Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2018-08-28-coreml-vs-mlkit/">Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.803Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2020-07-13-iOS-memory-manager/">Runtime剖析05 --- 再议iOS内存管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.802Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-09-07-machine-learning-feature/">机器学习与移动应用开发的未来</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.801Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-08-31-mind-flower/">思维的火花 --- 大数据与数据思维</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.800Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/">\#1\ 为什么要学习数据结构与算法</a></p><p class="categories"><a href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">48</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">Swift中的数据结构与算法</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"><span class="tag">开发知识 iOS</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">开发知识 技术人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">技术人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F-%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"><span class="tag">技术人生 读书计划</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-Python/"><span class="tag">数据科学 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"><span class="tag">机器学习 Keras MNIST</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-MFCC/"><span class="tag">机器学习 MFCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python/"><span class="tag">机器学习 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97-CoreML/"><span class="tag">端测计算 CoreML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>