<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 开发知识 - Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">开发知识</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/06/19/2022-05-25-runtime-again/"><img class="fill" src="/images/cover/2022-05-25-runtime-again.jpg" alt="再议Objective-C 2.0 中的 Runtime"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-06-19T06:47:10.914Z" title="6/19/2022, 2:47:10 PM">2022-06-19</time>发表</span><span class="level-item"><time dateTime="2022-06-19T06:56:00.384Z" title="6/19/2022, 2:56:00 PM">2022-06-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">25 分钟读完 (大约3701个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/19/2022-05-25-runtime-again/">再议Objective-C 2.0 中的 Runtime</a></h1><div class="content"><p>绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>可以看到其中保存了类的实例变量，方法列表等信息。</p>
<p>不知道有多少读者思考过 <code>OBJC2_UNAVAILABLE</code> 意味着什么。其实早在 2006 年，苹果在 WWDC 大会上就发布了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Objective-C#Objective-C_2.0">Objective-C 2.0</a>，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。</p>
<p>这意味着上述代码，以及任何带有 <code>OBJC2_UNAVAILABLE</code> 标记的内容，都已经在 2006 年就永远的告别了我们，只停留在历史的文档中。</p>
<h2 id="Category-的原理"><a href="#Category-的原理" class="headerlink" title="Category 的原理"></a>Category 的原理</h2><p>虽然上述代码已经过时，但仍具备一定的参考意义，比如 <code>methodLists</code> 作为一个二级指针，其中每个元素都是一个数组，数组中的每个元素则是一个方法。</p>
<p>接下来就介绍一下 category 的工作原理，在美团的技术博客 <a target="_blank" rel="noopener" href="http://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a> 中已经有了非常详细的解释，然而可能由于时间问题，其中的不少内容已经过时，我根据目前最新的版本(objc-680) 做一些简单的分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先 runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">└──<span class="keyword">const</span> <span class="type">char</span> *map_2_images(...)</span><br><span class="line">    └──<span class="keyword">const</span> <span class="type">char</span> *map_images_nolock(...)</span><br><span class="line">        └──<span class="type">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br></pre></td></tr></table></figure>

<p>以上四个方法可以理解为 runtime 的初始化过程，我们暂且不深究。在 <code>_read_images</code> 方法中有如下代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">    <span class="comment">/* ||  cat-&gt;classProperties */</span>) &#123;</span><br><span class="line">    addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">        remethodizeClass(cls-&gt;ISA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释可见苹果曾经计划利用 category 来添加属性。在 <code>addUnattachedCategoryForClass</code> 方法中会找到当前类的所有 category，然后在 <code>remethodizeClass</code> 真正的去做处理。不过到目前为止还没有接触到相关的 category 处理，我们继续沿着调用栈向下走:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br><span class="line">└──<span class="keyword">static</span> <span class="type">void</span> remethodizeClass(Class cls)</span><br><span class="line">    └──<span class="keyword">static</span> <span class="type">void</span> attachCategories(Class cls, category_list *cats, <span class="type">bool</span> flush_caches)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>attachCategories</code> 就是处理 category 的核心所在，不过在阅读这段代码之前，我们有必要先熟悉一下相关的数据结构。</p>
<h3 id="Category-相关的数据结构"><a href="#Category-相关的数据结构" class="headerlink" title="Category 相关的数据结构"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义，我只列出了其中成员变量:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见一个 category 持有了一个 <code>method_list_t</code> 类型的数组，<code>method_list_t</code> 又继承自 <code>entsize_list_tt</code>，这是一种泛型容器:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_list_t : entsize_list_tt&lt;method_t, method_list_t, <span class="number">0x3</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 成员变量和方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List, uint32_t FlagMask&gt;</span><br><span class="line"><span class="keyword">struct</span> entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    Element first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>entsize_list_tt</code> 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。 <code>Element</code> 表示元素类型，<code>List</code> 用于指定容器类型，最后一个参数为标记位。</p>
<p>虽然这段代码实现比较复杂，但仍可了解到 <code>method_list_t</code> 是一个存储 <code>method_t</code> 类型元素的容器。<code>method_t</code> 结构体的定义如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，我们还有一个结构体 <code>category_list</code> 用来存储所有的 category，它的定义如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> locstamped_category_list_t &#123;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    locstamped_category_t list[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> locstamped_category_t &#123;</span><br><span class="line">    category_t *cat;</span><br><span class="line">    <span class="keyword">struct</span> header_info *hi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> locstamped_category_list_t category_list;</span><br></pre></td></tr></table></figure>

<p>除了标记存储的 category 的数量外，<code>locstamped_category_list_t</code> 结构体还声明了一个长度为零的数组，这其实是 C99 中的一种写法，允许我们在运行期动态的申请内存。</p>
<p>以上就是相关的数据结构，只要了解到这个程度就可以继续读源码了。</p>
<h3 id="处理-Category"><a href="#处理-Category" class="headerlink" title="处理 Category"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 <code>attachCategories</code> 的简化版代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> attachCategories(Class cls, category_list *cats, <span class="type">bool</span> flush_caches) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="type">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，通过 while 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。</p>
<p>换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。这句话比较绕，但你可以把 <code>mlists</code> 理解为文章开头所说，旧版本的 <code>objc_method_list **methodLists</code>。</p>
<p>在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto rw = cls-&gt;data();</span><br><span class="line">rw-&gt;methods.attachLists(mlists, mcount);</span><br></pre></td></tr></table></figure>

<p>这两行代码读不懂是必然的，因为在 Objective-C 2.0 时代，对象的内存布局已经发生了一些变化。我们需要先了解对象的布局模型才能理解这段代码。</p>
<h2 id="Objective-C-2-0-对象布局模型"><a href="#Objective-C-2-0-对象布局模型" class="headerlink" title="Objective-C 2.0 对象布局模型"></a>Objective-C 2.0 对象布局模型</h2><h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p>相信读到这里的大部分读者都学习过文章开头所说的对象布局模型，因此在这一部分，我们采用类比的方法，来看看 Objective-C 2.0 下发生了哪些改变。</p>
<p>首先，<code>Class</code> 和 <code>id</code> 指针的定义并没有发生改变，他们一个指向类对应的结构体，一个指向对象对应的结构体:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="type">id</span>;</span><br></pre></td></tr></table></figure>

<p>比较有意思的一点是，<code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一点也很容易理解，早在 Objective-C 1.0 时代，我们就知道一个对象的结构体只有 <code>isa</code> 指针，指向它所属的类。而类的结构体也有 <code>isa</code> 指针指向它的元类。因此让类结构体继承自对象结构体就很容易理解了。 </p>
<p>可见 Objective-C 1.0 的布局模型中，<code>cache</code> 和 <code>super_class</code> 被原封不动的移过来了，而剩下的属性则似乎消失不见。取而代之的是一个 <code>bits</code> 属性，以及 <code>data()</code> 方法，这个方法调用的其实是 <code>bits</code> 属性的 <code>data()</code> 方法，并返回了一个 <code>class_rw_t</code> 类型的结构体指针。 </p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p>以下是简化版 <code>class_data_bits_t</code> 结构体的定义:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这个结构体只有一个 64 位的 <code>bits</code> 成员，存储了一个指向 <code>class_rw_t</code> 结构体的指针和三个标志位。它实际上由三部分组成。首先由于 Mac OS X 只使用 47 位内存地址，所以前 17 位空余出来，提供给 <code>retain/release 和</code> <code>alloc/dealloc</code> 方法使用，做一些优化。其次，由于内存对齐，指针地址的后三位都是 0，因此可以用来做标志位:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// class&#x27;s instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure>

<p>如果计算一下就会发现，<code>FAST_DATA_MASK</code> 这个 16 进制常量的二进制表示恰好后三位为0，且长度为47位: <code>11111111111111111111111111111111111111111111000</code>，我们通过这个掩码做按位与运算即可取出正确的指针地址。</p>
<p>引用 Draveness 在 <a target="_blank" rel="noopener" href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a> 中的图片做一个总结:</p>
<p><img src="/images/runtime-again/bit.png" alt="bits 示意图"></p>
<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到有一个名字很类似的结构体 <code>class_ro_t</code>，这里的 ‘rw’ 和 ro’ 分别表示 ‘readwrite’ 和 ‘readonly’。因为  <code>class_ro_t</code> 存储了一些由编译器生成的常量。</p>
<blockquote>
<p>These are emitted by the compiler and are part of the ABI. </p>
</blockquote>
<p>正是由于 <code>class_ro_t</code> 中的两个属性 <code>instanceStart</code> 和 <code>instanceSize</code> 的存在，保证了 Objective-C2.0 的 ABI 稳定性。因为即使父类增加方法，子类也可以在运行时重新计算 ivar 的偏移量，从而避免重新编译。</p>
<p>关于 ABI 稳定性的问题，本文不做赘述，读者可以参考 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/3b219ab86b09">Non Fragile ivars</a>。</p>
<p>如果阅读 <code>class_ro_t</code> 结构体的定义就会发现，旧版本实现中类结构体中的大部分成员变量现在都定义在 <code>class_ro_t</code> 和 <code>class_rw_t</code> 这两个结构体中了。感兴趣的读者可以自行对比，本文不再赘述。</p>
<p><code>class_rw_t</code> 结构体中还有一个 <code>methods</code> 成员变量，它的类型是 <code>method_array_t</code>，继承自 <code>list_array_tt</code>。</p>
<p><code>list_array_tt</code> 是一个泛型结构体，用于存储一些元数据，而它实际上是元数据的二维数组:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;&#123;</span><br><span class="line">    <span class="keyword">struct</span> array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; </span><br></pre></td></tr></table></figure>

<p>其中 <code>Element</code> 表示元数据的类型，比如 <code>method_t</code>，而 <code>List</code> 则表示用于存储元数据的一维数组，比如 <code>method_list_t</code>。</p>
<p><code>list_array_tt</code> 有三种状态:</p>
<ol>
<li>自身为空，可以类比为 <code>[[]]</code></li>
<li>它只有一个指针，指向一个元数据的集合，可以类比为 <code>[[1, 2]]</code></li>
<li>它有多个指针，指向多个元数据的集合，可以类比为 <code>[[1, 2], [3, 4]]</code></li>
</ol>
<p>当一个类刚创建时，它可能处于状态 1 或 2，但如果使用 <code>class_addMethod</code> 或者 category 来添加方法，就会进入状态 3，而且一旦进入状态 3 就再也不可能回到其他状态，即使新增的方法后来又被移除掉。</p>
<h2 id="方法合并"><a href="#方法合并" class="headerlink" title="方法合并"></a>方法合并</h2><p>掌握了这些 runtime 的基础只是以后就可以继续钻研剩下的 category 的代码了:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto rw = cls-&gt;data();</span><br><span class="line">rw-&gt;methods.attachLists(mlists, mcount);</span><br></pre></td></tr></table></figure>

<p>这是刚刚卡住的地方，现在来看，<code>rw</code> 是一个 <code>class_rw_t</code> 类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    uint32_t oldCount = array()-&gt;count;</span><br><span class="line">    uint32_t newCount = oldCount + addedCount;</span><br><span class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">    array()-&gt;count = newCount;</span><br><span class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，其实就是先调用 <code>realloc()</code> 函数将原来的空间拓展，然后把原来的数组复制到后面，最后再把新数组复制到前面。</p>
<p>在实际代码中，比上面略复杂一些。因为为了提高性能，苹果做了一些优化，比如当 List 处于第二种状态(只有一个指针，指向一个元数据的集合)时，其实并不需要在原地扩容空间，而是只要重新申请一块内存，并将最后一个位置留给原来的集合即可。</p>
<p>这样只多花费了很少的内存空间，也就是原来二维数组占用的内存空间，但是 <code>malloc()</code> 的性能优势会更加明显，这其实是一个空间换时间的权衡问题。</p>
<p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。而我们简单的看一下 runtime 在查找方法时的逻辑:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123;</span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists) &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">        <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见搜索的过程是按照从前向后的顺序进行的，一旦找到了就会停止循环。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完本文后，你应该对以下内容有比较深刻的理解，排名不分先后:</p>
<ol>
<li>定义在 runtime.h 中的数据结构，如果有 <code>OBJC2_UNAVAILABLE</code> 标记则表示已经废弃。</li>
<li>Objective-C 2.0 中，类结构体的结构层次: <code>objc_class</code> -&gt; <code>class_data_bits_t</code> -&gt; <code>class_rw_t</code> -&gt; <code>method_array_t</code>。</li>
<li><code>class_ro_t</code> 结构体的作用，与 <code>class_rw_t</code> 的区别，以及和 ABI 稳定性的关系。</li>
<li>category 解析过程的调用栈以及基本的流程。</li>
<li><code>method_array_t</code> 为什么要设计成一种类似于二维数组的数据结构，以及它的三种状态之间的关系。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="http://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md">从源代码看 ObjC 中消息的发送</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a></li>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/8847146/whats-is-methodlists-attribute-of-the-structure-objc-class-for">Whats is methodLists attribute of the structure objc_class for?</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jiazhh/articles/3309085.html">Objc与C（C++）之亲缘关系（一） Class</a></li>
<li><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a></li>
</ol>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/06/19/2022-05-20-how-to-reduce-git/"><img class="fill" src="/images/cover/2022-06-01-how-to-reduce-git.jpg" alt="如何进行 Git 仓库瘦身"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-06-19T06:18:32.204Z" title="6/19/2022, 2:18:32 PM">2022-06-19</time>发表</span><span class="level-item"><time dateTime="2022-06-19T06:53:17.889Z" title="6/19/2022, 2:53:17 PM">2022-06-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">16 分钟读完 (大约2386个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/19/2022-05-20-how-to-reduce-git/">如何进行 Git 仓库瘦身</a></h1><div class="content"><p>对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题：</p>
<ul>
<li>理解从 Git 的历史记录中删除文件</li>
<li>使用 BFG 重写历史记录</li>
<li>可选，使用 git filter-branch 重写历史记录</li>
<li>垃圾回收</li>
</ul>
<p>请格外小心…..</p>
<p>本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/3959924/whats-the-difference-between-git-clone-mirror-and-git-clone-bare">–mirror</a> 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了您的仓库的关键元素，那么你可以通过备份的仓库来恢复。</p>
<p>请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是一个不错的主意。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。</p>
<h3 id="理解从-Git-的历史记录中删除文件"><a href="#理解从-Git-的历史记录中删除文件" class="headerlink" title="理解从  Git  的历史记录中删除文件"></a><strong>理解从</strong>  <strong>Git</strong>  <strong>的历史记录中删除文件</strong></h3><p>回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：</p>
<ul>
<li>从你的项目的当前的文件树中删除该文件;</li>
<li>从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;</li>
<li>删除指向旧的提交历史记录的所有 <a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-reflog">reflog</a> 历史记录;</li>
<li>重新整理仓库，使用 <a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-gc">git gc</a> 对现在没有使用的数据进行垃圾回收。</li>
</ul></div><a class="article-more button is-small is-size-7" href="/2022/06/19/2022-05-20-how-to-reduce-git/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-08-iOS_Tips/"><img class="fill" src="/images/ios-jq/logo.jpeg" alt="iOS开发隐藏技能如何开启"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.795Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:58.501Z" title="4/30/2022, 3:44:58 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">8 分钟读完 (大约1230个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-08-iOS_Tips/">iOS开发隐藏技能如何开启</a></h1><div class="content"><p>在iOS的开发过程中，我们经常会遇到一些需要关心但是无法直接得到的信息，本文记录了一些能够开启IDE隐藏功能的方法，帮助开发者了解更多的信息等。</p>
<h2 id="1-在-Xcode-中追踪构建时间"><a href="#1-在-Xcode-中追踪构建时间" class="headerlink" title="1. 在 Xcode 中追踪构建时间"></a>1. 在 Xcode 中追踪构建时间</h2><p>在使用Xcode进行项目的编译和打包的时候，总是耗时的，而这个时间Xcode本身是具有统计功能的。如果需要查看此时间，需要开启Xcode的<code>ShowBuildOperationDuration</code>选项，打开命令行工具，直接输入如下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES</span><br></pre></td></tr></table></figure>

<p>开启后，Xcode的构建完成后，会在Xcode的状态栏显示本次构建的耗时。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-03-08-iOS_Tips/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-iOS_VMManage/"><img class="fill" src="/images/vm/memory_manage.jpg" alt="iOS虚拟内存管理"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.794Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:53.482Z" title="4/30/2022, 3:44:53 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">28 分钟读完 (大约4166个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-iOS_VMManage/">iOS虚拟内存管理</a></h1><div class="content"><p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p>
<h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p>
<p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p>
<p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p>
<p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-01-22-iOS_VMManage/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-09-29-ios-architecture-patterns/"><img class="fill" src="/images/iOSArchitecturePatterns/cover.jpeg" alt="浅谈iOS架构模式"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">1 小时读完 (大约7869个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-09-29-ios-architecture-patterns/">浅谈iOS架构模式</a></h1><div class="content"><p>每一个软件开发者在开始学习软件开发的时候，可能都不清楚软件的架构设计是什么样的，仅仅是依靠前人的方式进行代码开发的，至少本人是这样的。慢慢熟悉了软件开发后，对于软件代码如何更加合理的进行组织，以前的开发为什么是那样进行组织的便有了有些理解。其实这一切都是软件的架构模式。</p>
<p>对于iOS开发者来说，几乎每个人都熟悉应用程序的测试、代码的重构和通过视图控制器对业务进行支持等，但是如何合理的选用对当前产品业务更加合理的软件架构，往往会被忽略。这里针对当前业界常见的五种架构模式，进行详细的分析和试用，了解每种架构模式。</p>
<blockquote>
<p>架构模式并不是所有问题都适用的解决方案，它们仅仅描述了移动应用程序代码的组织方式和方法，具体的实现细节往往会跟随业务的变化而变化。</p>
</blockquote>
<p>在本文中，将介绍以下五种iOS端的通用架构模式：</p>
<ul>
<li>传统MVC</li>
<li>苹果的MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER</li>
</ul>
<h2 id="传统MVC"><a href="#传统MVC" class="headerlink" title="传统MVC"></a>传统MVC</h2><p>在70年代后期，Model、View、Controller的模式在编程语言Smalltalk-80中出现，随着时间的推移，人们对MVC有了许多不同的理解，尽管最初的想法逐渐被人们遗忘，但是MVC带给软件开发行业的巨大变化是有目共睹的，有必要好好了解一下最初的MVC以及相关的原理等。MVC最初要解决的问题是：<strong>将组件的职责明确划分为模型、视图、控制器。</strong></p>
<p><strong>模型：</strong> 一组封装特定主题领域数据及其验证算法的类。 在传统MVC中，模型还包含处理逻辑（“业务逻辑”）。 有两种类型的模型：主动模型和被动模型。 主动模型能够通知其状态的更改（通常是通过观察者模式）。 传统MVC实现被认为是主动模型，该模型对View和Controller一无所知，并且可以独立运行。 在测试中，此要求起着重要作用。</p>
<p><strong>视图：</strong> 负责（但不一定）显示数据的图形类。 在传统MVC中，仅在只读模式下，视图可以直接访问模型，视图不应直接更改模型的状态，状态的更改应该是控制器的职责。</p>
<p><strong>控制器：</strong> 直接和外部互动的组件，根据不同的外部行为，控制器会执行一些逻辑，包括但不限于改变模型的状态等，但是控制器不会直接对视图做出响应，也不会保持视图的状态，也就是说控制器并不是视图和模型的中间介质，也不负责将数据从模型输出到视图。</p>
<p><img src="/images/iOSArchitecturePatterns/classicMVC.png"></p>
<h3 id="传统MVC原理"><a href="#传统MVC原理" class="headerlink" title="传统MVC原理"></a>传统MVC原理</h3><p>在70年代，MVC模式基本上都是在具有实体按键的设备上应用的。一些外部按键事件，该事件和控制器进行交互，控制器决定如何处理该事件。例如，控制器可以更改模型的状态（一般是调用模型的方法），但是绝不能更改视图的状态，仅仅只有模型会直接影响视图。</p>
<p>如果模型的状态发生了更改，模型将通知视图进行相应的更改，并且视图应该读取新的模型数据，然后在必要时更新并重新绘制视图（视图观察者模型）。虽然MVC在控制台模式下成功完成了任务，但图形界面和鼠标或触摸变得越来越流行，用户现在可以直接与视图进行交互，并且视图会生成事件，从理论上讲，该事件应由Controller处理。 实际上传统的MVC已经发生了变化。</p>
<p>在图像界面时代，界面上将要显示各种样式的图形组件，开发人员的大部分任务演变成了建立各个小组件的层级结构并将事件从组件上重定向到所需的类，因此在现代开发中，可以认为视图是由小部件的不同层级结构构成的。</p>
<p>图形组件通常相对比较复杂。例如，UIKit库中的常用按钮（UIButton）可以为按钮的每种状态包含不同的文本（例如，“highlighted” –“处于突出显示状态”，以及“selected” –“处于选定状态”）。 您还可以设置每种状态的文本颜色，可以直接在可视编辑器中进行配置，也可以通过写代码的方式配置。</p>
<p>因此，按钮本身具有设置功能，并且本身也响应外部事件。 实际上，它包含自己的模型（所谓的View Model）和自己的Controller。 因此，当前程序更像是View，Controllers和Model的复杂层次结构。</p>
<h3 id="传统MVC的缺点"><a href="#传统MVC的缺点" class="headerlink" title="传统MVC的缺点"></a>传统MVC的缺点</h3><p>传统MVC的缺点之一是组件之间的强互连性，这使单元测试变得复杂。 在现代程序中，控制器，视图和视图模型的层次结构愈发复杂，它们被认为是基于MVC的应用程序，因此实际上无法进行单元测试。</p>
<p>另一个问题是业务模型的“增厚”。 为什么会这样呢？ 视图可以具有复杂的状态。 例如，文本输入框的输入字段验证的逻辑及其取决于验证结果的文本颜色的设置，此时视图的状态不能直接保存在视图模型的字段中，也不能在IDE中进行设置。</p>
<p>那么，在哪里“转移”这种状态呢？模型和控制器中可以吗？</p>
<p>在传统的MVC中，控制器不应保存视图的状态，因此这些复杂的状态需要在Model中实现。 因此，除了域模型之外，该模型还包括部分文本输入ViewModel。</p>
<h2 id="苹果MVC"><a href="#苹果MVC" class="headerlink" title="苹果MVC"></a>苹果MVC</h2><p>为了适应传统MVC并解决其缺点，苹果重新构建了MVC架构，实际上是在传统的MVC的基础上构建了<code>Cocoa</code>和<code>CocoaTouch</code>框架。 在苹果的MVC下，模型与传统MVC中的模型相同，并且是主动模型（即在观察者的帮助下通知其状态的变化）。</p>
<p>为此，在Cocoa和CocoaTouch框架中，可以方便地使用<code>NSNotificationCenter</code>和<code>KVO</code>，而不必了解其他组件。 视图也类似于来自MVC的视图（可以是组件的层次结构）。 为了减少类的互连性，View无法直接访问Model。</p>
<p><img src="/images/iOSArchitecturePatterns/appleMVC.png"></p>
<p>用户在视图上进行也写操作，视图既能自行处理一部分视图逻辑，也能够将一部分事件转发到控制器，由控制器决定处理事务并在必要时更改模型的状态。如果模型的状态发生了更改，将通知控制器，并由控制器决定如何处理这些更改。控制器的职责还有从模型中读取数据，必要的时候会对数据进行一些转换（以便于视图使用），并对视图进行新值设定等。</p>
<h3 id="优于传统MVC的优势"><a href="#优于传统MVC的优势" class="headerlink" title="优于传统MVC的优势"></a>优于传统MVC的优势</h3><p>在Apple的MVC模式下，视图和模型之间不再存在直接的连接，视图的状态和数据表示的处理逻辑也在控制器中，在当前情况下，这种职责分工更为合适。</p>
<p>这种模式的缺点是Controller包含View状态的一部分和几乎所有View逻辑，而且由于Controller还充当View和Model之间的中介者，因此它成为应用程序逻辑适应的一个非常着重的地方。 实际上，UIViweController类变得过于庞大。 通常，由于Controller和视图之间的紧密关系，它们被视为<code>表示层</code>的组成部分。</p>
<p><img src="/images/iOSArchitecturePatterns/betterClassicMVC.png"></p>
<blockquote>
<p><strong>查看逻辑</strong> : 一种与小部件层次管理，从一个场景到另一个场景的动画过渡，显示对话等相关的逻辑。</p>
<p><strong>表示逻辑</strong> : 与将域模型转换为可在View上显示的模型以及处理View中需要操纵域模型的事件相关的逻辑。 </p>
<p><strong>域逻辑</strong> : 在具有模型对象的模型级别上运行的基本逻辑。 域逻辑因此可以在另一个应用程序中重用。</p>
<p><strong>应用程序逻辑</strong> :特定应用程序中固有的逻辑。 这与域逻辑不同，它不能重复使用，因为它是特定于特定应用程序的并且是唯一的。</p>
</blockquote>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model、View、Presenter）是MVC模式的进一步发展。 Controller由Presenter代替。 Presenter，与经典MVC中的Controller不同：</p>
<ul>
<li>保存视图的状态；</li>
<li>更改视图的状态；</li>
<li>处理视图的事件；</li>
<li>将域模型转换为ViewModel。</li>
</ul>
<p>Presenter与经典MVC中的Controller也有类似之处：</p>
<ul>
<li>拥有模型；</li>
<li>响应外部事件（通过调用适当的方法）更改模型的状态；</li>
<li>可能包含应用逻辑。</li>
</ul>
<p>MVP诞生于上世纪90年代初期的IBM。 与MVC一样，由于对其模式的不同解释，因此出现了多个版本。 马丁·福勒（Martin Fowler）定义了MVP的以下变化：</p>
<ul>
<li>演示模型</li>
<li>监督控制器</li>
<li>被动视图</li>
</ul>
<p>它们都是相似的，但主要取决于View和Presenter之间的连接以及View的更新顺序。 小部件的层次结构通常扮演视图的角色。 MVP中的模型与MVC中的模型没有什么不同。</p>
<h3 id="监督控制器"><a href="#监督控制器" class="headerlink" title="监督控制器"></a>监督控制器</h3><p>与MVC最接近的模式。 组件之间的相互作用如下图所示。</p>
<p><img src="/images/iOSArchitecturePatterns/mvp.png"></p>
<p>监督控制器视图：</p>
<ul>
<li>实现视图逻辑；</li>
<li>将事件转发给演示者；</li>
<li>与经典MVC中一样，观察模型（在数据绑定的帮助下或实现观察者模式）；</li>
<li>不会直接更改模型的状态；</li>
<li>可能需要从Presenter请求数据或读取模型。</li>
</ul>
<p>Presenter处理View的事件并更改Model的状态（通过调用适当的方法）。 与经典MVC中的Controller不同，如果无法借助数据绑定或Observer在Model与View之间建立连接的话，Presenter会保持并更改View的状态。</p>
<p>监督控制器的好处在于，视图状态现在位于Presenter中（而不是在Model中）。 Presenter处理演示逻辑，因此View和Model变得“更薄”。 缺点是View严重依赖Model和Presenter，这极大地使单元测试复杂化。</p>
<h3 id="展示模型"><a href="#展示模型" class="headerlink" title="展示模型"></a>展示模型</h3><p>移除了监督控制器缺点的MVP，该结构进一步开发了视图与模型之间的连接。 组件之间的交互方案是：</p>
<p><img src="/images/iOSArchitecturePatterns/mvp2.png"></p>
<p><strong>View：</strong></p>
<ul>
<li>负责视图逻辑；</li>
<li>将所有事件重定向到Presenter；</li>
</ul>
<p>与经典的MVC和Supervision Controller不同，View无法直接访问模型。 </p>
<p><strong>Presenter：</strong></p>
<ul>
<li>将视图的状态移动到单独的Presentation Model中，作为Presenter的一部分；</li>
<li>交互并提供与域模型的接口（即，视图的外观）；</li>
<li>观察模型状态的变化；</li>
<li>提供一个公共接口，View可以使用该接口与Presenter进行交互。</li>
</ul>
<h3 id="该方案的工作原理如下："><a href="#该方案的工作原理如下：" class="headerlink" title="该方案的工作原理如下："></a>该方案的工作原理如下：</h3><p>视图中有一个事件，View可以尝试自行处理它，并向Presenter请求数据。 如果View无法处理该事件，它将把该事件委托给Presenter，Presenter决定如何处理该事件。 如有必要，Presenter可以更改模型的状态。 该模型将其状态更改反向通知给Presenter，Presenter读取模型的新值，如有必要，对它们执行附加逻辑并更新视图。</p>
<p>该模型相对于Supervision Controller的优势在于，视图与模型没有任何关系，这有利于单元测试。 缺点包括需要创建其他接口（至少对于View和Presenter而言）以及在View中进行更新的逻辑，这并不能大大简化测试。</p>
<h3 id="Humble-View"><a href="#Humble-View" class="headerlink" title="Humble View"></a>Humble View</h3><p>Humble View和Presentation模型之间的区别在于视图及其状态如何更新。 视图变为被动，MVP的先前版本没有对View施加限制，它可能会向Presenter询​​问一些数据。 在这种情况下，被动视图受到限制，它不再向Presenter询问任何数据。</p>
<p>视图状态的任何更改均由Presenter执行。 视图不知道Presenter或Model的存在。 View的无源性最多可以简化单元测试。 与每种架构模式一样，组件之间的关系也有很多问题。 最常见的：</p>
<ul>
<li>谁拥有MVP中的View和Presenter？</li>
</ul>
<p>视图通常具有对Presenter的强烈引用。 反过来，Presenter对模型有很强的引用，而对View则无能为力。 与经典MVC中一样，该模型对View和Presenter一无所知。</p>
<ul>
<li>谁创建View和Presenter？</li>
</ul>
<p>可以认为，视图是由Presenter创建的。 但是，Presenter需要一个模型，即创建Presenter的视图必须通过模型进行配置，并且在此之后，她知道模型的存在。 此顺序不适合我们，因为我们正在尝试使组件之间的连接性达到最小（以实现更轻松的测试和更大的灵活性）。</p>
<p>因此，如果下一个View Presenter是由另一个Presenter创建的，或者是在单独的Router类中创建的，则更好（后者也可能参与下一个View的配置和创建）。 但是，没有明确的规则。</p>
<h2 id="iOS-MVP"><a href="#iOS-MVP" class="headerlink" title="iOS MVP"></a>iOS MVP</h2><p>经过一些理论，我们可以进行实际的发展。 一个典型的iOS应用程序是围绕一个中央UIViewController类构建的，该类承担着许多责任，因此放置UI逻辑和应用程序逻辑的一部分是最有吸引力的地方。 但是，我们在上面提到，由于View和Controller之间的紧密结合（在iOS UIViewController和UIView的上下文中），将它们视为View很方便。</p>
<p><img src="/images/iOSArchitecturePatterns/iosmvp.png"></p>
<p>例如，让我们考虑一个包含两个场景的简单应用程序。 它允许您使用REST服务 <a target="_blank" rel="noopener" href="http://random.cat/meow">http://random.cat/meow</a> 从Internet上加载猫的随机照片（“加载猫场景”） ，在猫的图片上应用内置照片滤镜，然后保存编辑后的照片（“编辑猫”现场）。</p>
<p>您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVP_Sample</p>
<p>加载照片时，“加载猫场景视图”会显示活动指示器，实际加载的照片和图片的URL。 演示者将借助“最小”界面LoadCatViewProtocol与“加载猫场景视图”进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateLoadingState</span>(<span class="keyword">_</span> <span class="params">loadingState</span>: <span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateTitle</span>(<span class="keyword">_</span> <span class="params">imageTitle</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">LoadCatViewProtocol</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> image: <span class="type">Data</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageTitle: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">installView</span>(<span class="keyword">_</span> <span class="params">view</span>: <span class="type">View</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view <span class="operator">=</span> view <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>() &#123;</span><br><span class="line">        view.updateLoadingState(isLoading)</span><br><span class="line">        view.updateTitle(imageTitle)</span><br><span class="line">        view.updateImage(image)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isLoading <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        image <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        imageTitle <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">        updateUI()</span><br><span class="line">        loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载猫场景允许您开始加载和取消它，还可以转到下一个场景进行图像编辑。 这些事件由用户启动，并且View只是将它们重定向到Presenter，调用其方法。 视图通过协议LoadCatPresenterProtocol与Presenter进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatPresenterProtocol</span>: <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">load</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> catProvider: <span class="type">CatProvider</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actCancel</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">setPresenter</span>(<span class="keyword">_</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter <span class="operator">=</span> presenter <span class="keyword">as!</span> <span class="type">LoadCatPresenterProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的测试项目中，无需Router类即可过渡到下一个场景。</p>
<ul>
<li>要将负载猫场景切换到编辑猫场景，您需要按编辑。</li>
<li>LoadCatViewController将此事件重定向到LoadCatPresenter。</li>
<li>LoadCatViewController不知道此事件会启动转换。</li>
<li>LoadCatPresenter创建EditCatPresenter并使用必要的模型对其进行配置。</li>
<li>要显示下一个场景，LoadCatPresenter调用LoadCatViewController showEditScene的方法并在此处传递EditCatPresenter。</li>
<li>LoadCatViewController创建下一个视图，将其与接收的Presenter连接并显示。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actEdit</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        loadButton.isEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        editCat()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextViewController <span class="operator">=</span> storyboard<span class="operator">!</span>.instantiateViewController(withIdentifier: <span class="type">Constants</span>.editCatViewControllerStoryboardId) <span class="keyword">as!</span> <span class="type">View</span></span><br><span class="line">        presenter.installView(nextViewController)</span><br><span class="line">        nextViewController.setPresenter(presenter)</span><br><span class="line">        present(nextViewController <span class="keyword">as!</span> <span class="type">UIViewController</span>, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一个场景，则可以按照Apple的所有原则在UIApplicationDelegate中执行此配置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> window<span class="operator">?</span>.rootViewController <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">        <span class="keyword">let</span> presenter <span class="operator">=</span> <span class="type">LoadCatPresenter</span>()</span><br><span class="line">        presenter.catProvider <span class="operator">=</span> catProvider</span><br><span class="line">        presenter.installView(view)</span><br><span class="line">        view.setPresenter(presenter)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>尽管MVP具有很多优点，但由于IDE开发和框架，它不适合自动化应用程序开发，需要“手动”工作。 下一个模式应该可以解决这些问题。 MVVM（Model、View、ViewModel）由Microsoft Ken Cooper和Ted Peters的工程师开发，并由John Gossman在2005年的博客中宣布。</p>
<p>该模式的目的是将用户界面与开发以及业务逻辑开发分开，并使用WPF和Silverlight平台的主要功能来促进应用程序测试。 尽管专业化模式是针对Microsoft技术构想的，但可以在Cocoa &#x2F; CocoaTouch框架中使用。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvm.png"></p>
<p>MVVM源自MVC模式，由以下3个组件组成：模型，视图，视图模型。 模型与MVP和MVC中的模型不同：</p>
<ul>
<li>它是一个领域模型；</li>
<li>包括数据，业务逻辑和验证逻辑；</li>
<li>不依赖于其他组件（ View 和 ViewModel ）。</li>
</ul>
<p><strong>View：</strong></p>
<ul>
<li>确定用户界面（如MVP，Apple MVC）的结构，位置和外观；</li>
<li>具有View的逻辑：动画、View与子View的操作之间的过渡等；</li>
<li>保持对ViewModel的强烈引用，但对Model一无所知；</li>
<li>监视ViewModel并使用数据绑定或直接引用它进行通信。</li>
</ul>
<p>为了避免View与ViewModel之间的牢固关系，需要创建一个接口，View将通过该接口与ViewModel进行通信。 ViewModel是视图和模型之间的中介者，并负责表示逻辑的处理。</p>
<p><strong>ViewModel：</strong></p>
<ul>
<li>保持View的状态；</li>
<li>了解模型并可以更改其状态（适当类的调用方法）；</li>
<li>将模型中的数据转换为对视图更方便的格式；</li>
<li>验证来自视图的数据；</li>
<li>不了解View，只能通过数据绑定机制与View交互。</li>
</ul>
<p>在Cocoa中有其自己的数据绑定机制，但在CocoaTouch中则没有。 我们只能用KVO来做，但是这个东西不方便使用，只允许您实现单边绑定。 反过来，数据绑定使实现MVVM固有的全部潜力成为可能，并总体上促进了开发。 因此，应该使用一些提供与CocoaTouch的数据绑定或响应式编程的第三方库。</p>
<p>MVVM和MVP中的UIViewController被视为View的一部分。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvmcocoa.png"></p>
<p>从苹果的MVC到MVVM的过渡过程中出现了一个重要的问题：如何实现导航？ 如上所述，视图直接执行到其他视图的过渡。 因此，有两种方法可以进行过渡：</p>
<ul>
<li>最简单的一种是从View启动过渡时。 在这种情况下，当前场景的ViewModel会创建下一个场景的ViewModel（如果需要，可以通过模型对其进行配置）。 然后，View创建下一个场景的View，将新的ViewModel传递给它，然后执行过渡。 </li>
<li>过渡从ViewModel启动。 由于ViewModel对View一无所知，因此无法进行过渡。 在这种情况下，需要一个特殊的组件-路由器-它知道视图的层次结构以及如何进行转换。 ViewModel可以将下一场景的ViewModel或模型传递给路由器。 路由器处理其他所有事务。</li>
</ul>
<p>因此，MVVM和MVP（低视角）在Presentation层（在MVP中由Presenter呈现，在MVVM中由ViewModel呈现）差异很大。 MVVM优于MVP（Humble View）的优点是Presentation层完全独立于View（意味着更容易测试）和DataBinding的使用。 总之，它成为在现代IDE中使用的更具吸引力的候选者，并减少了将View与ViewModel同步的代码量。</p>
<p>MVVM的缺点主要在于数据绑定机制，因为在某些情况下，它可能需要大量的内存资源，并且也是内存泄漏出现的薄弱环节。 接下来，我们将考虑上一节中描述的应用程序示例，但使用MVVM模式。 您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVVM_Sample</p>
<p>应用程序和模型（Cat，CatProvider）的用户界面相同。 它们仅在表示逻辑上有所不同，这将是主要重点。 View组件由LoadCatViewController和EditCatViewController呈现。 LoadCatViewController通过以下接口与LoadCatViewModel进行交互：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">CatViewModelProtocol</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> isLoading: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isEditable: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">Observable</span>&lt;<span class="type">String</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> imageData: <span class="type">Observable</span>&lt;<span class="type">Data</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> editCatViewModel: <span class="type">EditCatViewModelProtocol</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadNextCat</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelCurrentDownloading</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCatViewModel包含一组用于定义LoadCatViewController的状态的功能，以及一组与用户可以执行的操作相对应的方法。 对于数据绑定机制，我们使用 Bond 。 由于Load Cat是初始场景，因此很明显，它的配置是在AppDelegate中执行的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> catProvider <span class="operator">=</span> <span class="type">CatProvider</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> catViewModel <span class="operator">=</span> <span class="type">CatViewModel</span>(catProvider: catProvider)</span><br><span class="line">        (window<span class="operator">?</span>.rootViewController <span class="keyword">as?</span> <span class="type">CatViewController</span>)<span class="operator">?</span>.viewModel <span class="operator">=</span> catViewModel</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与MVP一样，配置Edit Cat场景分别在View和ViewModel中进行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">prepare</span>(<span class="params">for</span> <span class="params">segue</span>: <span class="type">UIStoryboardSegue</span>, <span class="params">sender</span>: <span class="keyword">Any</span><span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> editCatViewController <span class="operator">=</span> segue.destination <span class="keyword">as?</span> <span class="type">EditCatViewController</span> &#123;</span><br><span class="line">            editCatViewController.viewModel <span class="operator">=</span> viewModel.editCatViewModel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用Segue机制的LoadCatViewController创建EditCatViewController。</li>
<li>然后，在prepareForSegue方法中，LoadCatViewController询问LoadCatViewModel下一个场景的已配置ViewModel，即包含当前Cat模型的EditCatViewModel。</li>
<li>此外，我们将此EditCatViewModel传递给EditCatViewController。</li>
<li>单元测试是ViewModel和Model中的应用程序测试。 在测试项目中，您将找到单元测试的示例。</li>
</ul>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>在上面描述的架构中，如果尝试将体系结构划分为多个层，则使用Presenter或View Model可能会遇到困难。 它们属于哪一层？ 这个问题没有明确的答案：您可以为Presenter引入一个单独的Presentation层，或者它可以属于Application Logic。 MVVM也一样。 这种歧义造成了另一个问题。</p>
<p>将应用逻辑与域模型逻辑分开是非常困难的。 因此，通常没有分隔并且位于同一层。 此外，Presenter中存在应用程序逻辑有时会使很难测试不同的用例。 以前的体系结构中的另一个问题是组装和导航。 在数十个场景的大型项目中，很明显，这是由单独的模块路由器负责的。</p>
<p>2012年 发表 了一篇非凡的文章 。 清洁建筑以及有关该主题的几篇演讲。 后来，在Mutual Mobile中，我们为iOS做了一些修改，并进入了VIPER的新模式。 它 是View，Interactor，Presenter，Entity，Router的缩写，它们是构成应用程序的基本组件。 在下面查看他们如何互动。</p>
<p><img src="/images/iOSArchitecturePatterns/VIPER.png"></p>
<p><strong>View：</strong></p>
<p>与MVP（被动视图）一样，它是来自Presenter的数据的可视化。 View通过高于UI类级别的协议与Presenter通信。 演示者不知道构成视图层次结构的特定类。 要在View和Presenter之间共享数据，可以使用单独的结构（即，没有方法可以更改其状态的类）。 只有View和Presenter知道这些类。</p>
<p><strong>Presenter：</strong> 与MVP中的功能相同，不同之处在于它不应包含应用程序逻辑。 我们主要让Presenter参与数据转换。</p>
<p><strong>Interactor：</strong> 这些对象封装了应用程序的单独用例（我们将其称为应用逻辑）。 交互器与演示者和模型一起使用。 Interactor永远不会将属于模型层的对象类传递给Presenter。 因此，演示者不依赖于模型。 而且，他不知道该模型的存在。</p>
<p><strong>Model：</strong> 与以前的模式相同。 对于方向模型，只有交互器起作用。 该模型不知道其他组件的存在。 模型层可能包含各种管理器（用于创建或保留实体）和封装数据处理算法的对象。</p>
<p><strong>Entity：</strong> 实体是仅包含数据且不包含其处理方法的PONSO（普通的NSObject）对象（例如，其所有属性均为只读，并且NSManagerObject类的对象不能脱离模型层的边界）。</p>
<p><strong>Routing：</strong> 线框和演示者负责VIPER中的导航。</p>
<p>演示者接收视图的事件并知道如何响应它们。 但是Presenter对View的层次结构一无所知，并且包含View Logic（场景之间的动画切换– View Logic示例），并且无法在场景之间切换。</p>
<p>在这里，它将需要Wireframe（一个包含对UIWindow的引用的对象），可以创建View &#x2F; UIViewController并知道如何将它们放入View层次结构中。 同样，线框是诸如场景之间的自定义过渡之类的事务处理的理想位置。 例如，让我们考虑一个测试项目的VIPER版本，上面已针对MVP进行了描述。</p>
<p>您可以在此处下载示例代码： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_VIPER_Sample</p>
<p>在项目的MVP和VIPER版本中比较LoadCatView的协议。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> imageTitle: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">Data</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> showEditScene(withPresenter presenter: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishedEdit()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> title: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">UIImage</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishEditing()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>



<p>它们仅在方法上有所不同</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) </span><br></pre></td></tr></table></figure>

<p>因为就VIPER而言，新场景或对话显示是线框的职责。 因此，两个项目的LoadCatViewProtocol实现几乎相同。 比较MVP和VIPER项目的LoadCatPresenter。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">ar</span><span style="font-weight: 400;"> catProvider: </span><span style="font-weight: 400;">CatProvider</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">var</span><span style="font-weight: 400;"> loadCatInteractor: </span><span style="font-weight: 400;">LocadCatInteractor</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>

<p>它们之间的区别不是很大。 该项目的MVP版本包含一个变量catProvider，该变量引用了Model层。 在项目的VIPER版本中，Presenter不必依赖于Model层。</p>
<p>由于通过按下按钮加载图片是一个用例（或应用程序逻辑），因此要实现功能，需要一个Interactor（可变loadCatInteractor）。 通常，交互器具有输入（演示者可以通过其与之交互的接口）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorInput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadCat</span>() </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelLoad</span>() </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>和与演示者交互的输出</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorOutput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>因此，通过按下按钮加载猫图片处理如下所示</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIButton</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">LoadCatInteractorOutput</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> loadCatInteractor: <span class="type">LocadCatInteractor</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Some code to prepare UI</span></span><br><span class="line">        loadCatInteractor.loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: LoadCatInteractorOutput</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the URL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the image</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交互器和模型层之间的交互。 模型层由CatProvider和Cat类表示。 由于它很原始，因此对于交互器和模型之间的数据交换，我们没有创建实体类。</p>
<p>让我们考虑在场景之间切换。 正如我们上面提到的，在VIPER项目中，这是线框的责任。 如果下一个场景需要上一个场景的某些数据，则可以将它们传递到线框中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">EditCatPresenterDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: <span class="keyword">self</span>.image<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">let</span> editCatPresenter <span class="operator">=</span> <span class="type">EditCatPresenter</span>()</span><br><span class="line">        editCatPresenter.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        editCatPresenter.image <span class="operator">=</span> image<span class="operator">!</span></span><br><span class="line">        </span><br><span class="line">        view.showEditScene(withPresenter: editCatPresenter)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，不再将Seguey机制用于场景之间的过渡是不方便的，但是也不是拒绝使用UIStoryboard这样的便捷机制处理场景的理由。 这里的场景将没有Seguey。</p>
<p>一个普通的VIPER项目包含许多您需要配置的模块。 对于我们的简单示例，在应用程序启动时使用单独的Dependencies类就足够了。 但是，在复杂的项目中，更容易使用其他解决方案或库。</p>
<p><strong>测试:</strong> VIPER项目的测试与MVP相似，不同之处在于将应用逻辑交付到单独的类–交互器中。 一方面，您必须编写更多用于单元测试的代码，另一方面，还需要针对单个功能测试（用户案例）使用更简单的算法。 在我们的测试项目中，您将找到所有VIPER项目的单元测试示例。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们研究了可用于开发iOS应用程序的体系结构模式的演变。 进化链中的每个模式都改进了前一个模式。 明确了组件之间的界限及其职责（如有必要，引入了新的层或组件），这有助于开发和支持。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://thinkmobiles.com/blog/ios-architecture-patterns/">iOS architecture patterns: A guide for developers</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/ios-architecture-patterns">iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/61a656431685">iOS的MVP设计模式</a></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/"><img class="fill" src="/images/lightweight-api/cover.jpg" alt="Swift语言中的轻量级API设计"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">22 分钟读完 (大约3270个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/">Swift语言中的轻量级API设计</a></h1><div class="content"><p>Swift语言自诞生以来，总是或多或少受到人们的非议，新生的编程语言难免有些不够尽善尽美，但是哪种编程语言是尽善尽美的呢？OC语言算得上是一种古老的面向对象语言了，发展至今，其版本仍处于2.0，但是Apple为了让其看起来强大一点，增加了很多特性，例如Block、instancetype等等，但是其核心的语法变化并不大。</p>
<p>截止目前，Swift的版本已经迭代到5.*，整个ABI也已经稳定，每一次迭代更新，总是会带来一些漂亮的设计模式实践，例如在如何设计API方面，给开发者带来了舒适而强大的枚举、扩展和协议等，不仅让开发者对于函数的定义有了更清晰的认识，而且对于构建API而言，第一印象往往是轻量的，同时，仍会根据需要逐步显现出更多的功能，以及底层的复杂性。</p>
<p>在本篇文章里，将尝试创建一些轻量级的API，以及如何使用API组合的力量使得功能或者系统更加强大等。</p>
<h2 id="功能和易用性之间的较量"><a href="#功能和易用性之间的较量" class="headerlink" title="功能和易用性之间的较量"></a>功能和易用性之间的较量</h2><p>通常，当我们设计API时，会在数据结构和函数功能的相互交互上，寻找一个相对平衡的方式，最终构建出在功能上满足需求，数据结构尽量简单的API。但是，让API过于简单，可能它们又不够灵活，无法使功能有不断发展的潜力，然而，太过复杂的设计又难免导致开发工作复杂而无章法，容易造成开发者挫败，逻辑混乱而且API也难以使用，最终可能会导致延期甚至失败。</p>
<p>例如，一款应用程序的主要功能是对用户选择的图像应用不同的滤镜效果。每一种滤镜的核心其实都是一组图像变换的组合，不同的变换组合形成不同的滤镜效果。假设使用<code>ImageFilter</code> 结构体作为图像滤镜的定义，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">Icon</span></span><br><span class="line">    <span class="keyword">var</span> transforms: [<span class="type">ImageTransform</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageTransform</code>是图像变换的统一入口，因为可能会由多种不同的变换，因此可以将其定义为一个<code>protocol</code>，然后由实现单独变换操作的各种变换类型所遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortraitImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zoomMultiplier: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayScaleImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brightnessLevel: <span class="type">BrightnessLevel</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述设计方式的优势在于，由于每种转换都是按照自己的类型实现的，因此在使用时可以自由地让每种变换类型定义自己所需的属性和参数。例如<code>GrayScaleImageTransform</code> 接受 <code>BrightnessLevel</code>参数，以将图像转换为灰度图像。</p>
<p>然后，可以根据需要组合任意数量的图像变换类型，以形成不同类型的滤镜效果。例如，通过一系列的转换使得图像具有某种“戏剧性”外观的滤镜：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>, icon: .drama, transforms: [</span><br><span class="line">        <span class="type">PortraitImageTransform</span>(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        <span class="type">ContrastBoostImageTransform</span>(),</span><br><span class="line">        <span class="type">GrayScaleImageTransform</span>(brightnessLevel: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So far so Good.  但是回头重新审视上述API的实现，可以肯定的说，上述实现仅仅是为了功能的实现，在API的易用性方面并没有优势，那么该如何进行优化，来保证功能的同时，提高API的灵活性和易用性呢？在上述实现中，每个图像的变换都是作为单独的类型实现的，因此没有一个可以对所有变换类型一目了然的地方，使用者难以清楚该代码库都包含哪些图像变换的类型。</p>
<p>为了解决外部使用者无法得知软件库所支持的变换类型，假设使用<strong>枚举</strong>的方式代替上述方式，来观察哪种方式更能够体现API的简洁明了以及使用上的清晰易用？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> protrait(<span class="keyword">_</span> zoomMultiplier: <span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> grayScale(<span class="keyword">_</span> brightnessLevel: <span class="type">BrightnessLevel</span>)</span><br><span class="line">    <span class="keyword">case</span> contrastBoost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举的好处既能够提高代码的整洁程度和可读性，也使得API更加的灵活易用，因为在枚举的使用上，开发者可以直接使用点语法构造任意数量的转换，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .protrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>截止目前，枚举都是很漂亮的一个工具，在很多情况下Swift的枚举类型都能够提供良好的解决方式，但是枚举也有其明显的弊端。</p>
<p>就上述例子来说，由于每个转换都需要执行截然不同的图像操作，因此在这种情况下使用枚举将迫使我们编写一个庞大的<em>switch</em>语句来处理这些操作中的每一项, 这可能会造成代码的冗长繁琐等。</p>
<h2 id="枚举虽轻，结构体更优"><a href="#枚举虽轻，结构体更优" class="headerlink" title="枚举虽轻，结构体更优"></a>枚举虽轻，结构体更优</h2><p>幸运的事，针对上述问题，我们还有第三种选择 — 一种目前算是两全其美的方案。相较于协议或者枚举，结构体是一个既能够定义操作类型，还能够封装给定各种操作的闭包的数据结构。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> closure: (<span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>apply(to:)</code> 方法在这里并不应该被外部调用，这里写出来是为了代码的美观性以及代码的向前兼容。在实际项目开发中，这里可以使用宏定义区分。</p>
</blockquote>
<p>完成上述操作后，我们现在可以使用<strong>静态工厂方法</strong>和属性来创建我们的转换 — 每个转换仍可以单独定义并具有自己的一组参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> contrastBoost: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">portrait</span>(<span class="keyword">_</span> <span class="params">multiplier</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">grayScale</span>(<span class="keyword">_</span> <span class="params">brightness</span>: <span class="type">BrightnessLevel</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在 Swift 5.1 中，可以将<strong>Self</strong>用作静态工厂方法的返回类型。</p>
</blockquote>
<p>上面方法的优点在于，我们回到了将ImageTransform定义为协议时所具有的灵活性和功能性，同时仍保持了与定义为枚举时的调用方式 — 点语法一致，保证了易用性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>点语法本身与枚举无关，但是其可以与任何静态API一起使用，这点对于开发者而言非常友好。使用点语法可以将上述的几个滤镜的创建和建模构造成静态属性，使得我们能够进一步的封装特性等。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> dramatic: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageFilter</span>(</span><br><span class="line">            name:<span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">            icon: .drama,</span><br><span class="line">            transforms: [</span><br><span class="line">                .portrait(<span class="number">2.1</span>),</span><br><span class="line">                .contrastBoost,</span><br><span class="line">                .grayScale(.dark)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述改造，一系列复杂的任务 — 包括图像滤镜和图像转换 – 封装到一个API中，在使用上，可以像传值给函数一样轻松。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> image.withFilter(.dramatic)</span><br></pre></td></tr></table></figure>

<p>上述一系列的改造可以成为为类型构造<strong>语法糖</strong>。不仅改善了API读取的方式，还改善了API的组织方式，由于所有的转换和滤镜现在只需要进行传单一的值即可，因此在可扩展性方面来说，能够组织多种方式，不仅使得API轻巧灵活，对于使用者来说也简洁明了。</p>
<h2 id="可变参数与API设计"><a href="#可变参数与API设计" class="headerlink" title="可变参数与API设计"></a>可变参数与API设计</h2><p>接下来我们一起看看Swift语言的另一个特性 — 可变参数，以及可变参数如何影响API设计中的代码构建的。</p>
<p>假设正在开发一个使用基于形状的绘图来创建其用户界面的应用程序，并且我们已经使用了与上述类似的基于结构的方法来对每种形状进行建模，并最终将结果绘制到了<code>DrawingContext</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> drawing: (<span class="keyword">inout</span> <span class="type">DrawingContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面使用<strong>inout</strong>关键字来启用值类型（DrawingContext）的传递。</p>
</blockquote>
<p>类似我们在上面例子中使用静态工厂方法轻松创建<code>ImageTransform</code>一样，在这里也能够将每个形状的绘图代码封装在一个完全独立的方法中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">at</span> <span class="params">point</span>: <span class="type">Point</span>, <span class="params">sideLength</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> origin <span class="operator">=</span> point.movedBy(</span><br><span class="line">                x: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span>,</span><br><span class="line">                y: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            context.move(to: origin)</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength, y: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(y: sideLength))</span><br><span class="line">            context.drawLine(to: origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于将每个形状简单地建模为一个属性值，因此绘制它们的数组变得非常容易-我们要做的就是创建一个<strong>DrawingContext</strong>实例，然后将其传递到每个形状的闭包中以构建最终图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context <span class="operator">=</span> <span class="type">DrawingContext</span>()</span><br><span class="line">    </span><br><span class="line">    shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">        context.move(to: .zero)</span><br><span class="line">        shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> context.makeImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的函数看起来也很优雅，因为我们再次可以使用点语法来大大减少执行工作所需的语法量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw([</span><br><span class="line">    .circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">    .square(at: point, sideLength: <span class="number">5</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>但是，让我们看看是否可以使用可变参数来使事情更进一步。虽然不是Swift独有的功能，但结合Swift真正灵活的参数命名功能后，使用可变参数可以产生一些非常有趣的结果。</p>
<p>当参数被标记为可变参数时（通过在其类型中添加<code>...</code>后缀），我们基本上可以将任意数量的值传递给该参数 — 编译器会自动为我们将这些值组织到一个数组中，例如这个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: <span class="type">Shape</span>...) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="comment">// Within our function, &#x27;shapes&#x27; is still an array:</span></span><br><span class="line">    shapes.forEach &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述更改后，我们现在可以从对draw函数的调用中删除所有数组文字，而使它们看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">                 .square(at: point, sideLength: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>这看起来似乎不是很大的变化，但是尤其是在设计旨在用于创建更多更高级别值（例如我们的draw函数）的更低级别的API时，使用可变参数可以使这类API感觉更轻巧和方便。</p>
<p>但是，使用可变参数的一个缺点是，预先计算的值数组不能再作为单个参数传递。值得庆幸的是，在这种情况下，可以通过创建一个特殊的组形状（就像draw函数本身一样），在一组基础形状上进行迭代并绘制它们来轻松解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">group</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">                context.move(to: .zero)</span><br><span class="line">                shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述操作后，我们现在可以再次轻松地将一组预先计算的Shape值传递给我们的draw函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shapes: [<span class="type">Shape</span>] <span class="operator">=</span> loadShapes()</span><br><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.group(shapes))</span><br></pre></td></tr></table></figure>

<p>不过，真正酷的是，上述组API不仅使我们能够构造形状数组，而且还使我们能够更轻松地将多个形状组合到更高级的组件中。例如，这是我们如何使用一组组合形状来表示整个图形（例如徽标）的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">logo</span>(<span class="params">withSize</span> <span class="params">size</span>: <span class="type">Size</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        .group([</span><br><span class="line">            .rectangle(at: size.centerPoint, size: size),</span><br><span class="line">            .text(<span class="string">&quot;The Drawing Company&quot;</span>, fittingInto: size),</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述徽标与其他徽标一样都是Shape，因此只需调用一次draw方法就可以轻松绘制它，并使用与之前相同的优雅点语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo <span class="operator">=</span> draw(.logo(withSize: size))</span><br></pre></td></tr></table></figure>

<p>有趣的是，尽管我们最初的目标可能是使我们的API更轻量级，但这样做也使它的可组合性和灵活性也得到了提高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们向“ API设计者的工具箱”添加的工具越多，我们越有可能能够设计出在功能，灵活性和易用性之间达到适当平衡的API。 使API尽可能轻巧可能不是我们的最终目标，但是通过尽可能减少API的数量，我们也经常发现如何使它们变得更强大-通过使我们创建类型的方式更灵活，以及使他们组成。所有这些都可以帮助我们在简单性与功能之间实现完美的平衡。</p>
<blockquote>
<p>原文： Lightweight API design in Swift<br>链接：<a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</a></p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-10-30-app-start-time-measure-and-improvement/"><img class="fill" src="/images/start-time/cover.jpg" alt="关于iOS App启动时间的那些事"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.091Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.091Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">17 分钟读完 (大约2599个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-10-30-app-start-time-measure-and-improvement/">关于iOS App启动时间的那些事</a></h1><div class="content"><p>在iOS应用程序的开发过程中，应用的启动时长可谓是影响应用程序用户体验的第一要素，过长的应用启动耗时，势必带来用户的长时间等待，直接让用户失去了对应用程序进一步体验的兴趣，影响应用程序在用户心中的印象。一般情况下，应用程序开发完成上线后，接下来就是针对架构、性能、业务进行进一步优化和调整的阶段，这个阶段也是检验一个iOS开发工程师内功的时候。</p>
<h2 id="iOS应用启动方式"><a href="#iOS应用启动方式" class="headerlink" title="iOS应用启动方式"></a>iOS应用启动方式</h2><p>iOS应用程序的启动整体分为<strong>冷启动</strong>和<strong>热启动</strong>两种方式，两种启动方式具有不同的启动触发条件，也是在不同的业务场景模式下，最终导致应用启动，进而延续业务的方式。</p>
<ul>
<li><strong>冷启动：</strong>指的是当应用还没准备好运行时，必须从零开始加载和构建整个应用。包括设置屏幕底部的分栏菜单，确保用户是否被合适地登录，以及处理其他更多的事情。整个应用程序的入口是在*applicationDidFinishLaunching:withOptions:*方法中开始的。</li>
<li><strong>热启动：</strong>指的是应用已经运行但是在后台被挂起（比如用户点击了 <code>home</code> 健）。在这种情况下，应用通过 <em>applicationWillEnterForeground:</em> 接收到回到前台的事件，接着应用恢复。</li>
</ul>
<blockquote>
<p>另一种理解是，冷启动时App的进行不存在，系统需要为App分配进程等资源，以供App正确启动，而热启动时，App进程是存在的，只是App处于被挂起状态，热启动可以认为是App恢复形式的启动。</p>
</blockquote>
<p>在应用启动时间的衡量和治理上，往往<strong>冷启动</strong>是重中之重，因为严格意义上，冷启动是包含热启动的（冷启动初始化应用程序并获取摘要，热启动仅获取摘要），另外，冷启动需要做的工作更多，其中包含了一些额外的初始化工作，也更加的耗时，因此，针对冷启动的治理更加有意义。</p>
<h2 id="冷启动的定义"><a href="#冷启动的定义" class="headerlink" title="冷启动的定义"></a>冷启动的定义</h2><p>通常情况下，针对iOS的冷启动过程是从用户点击App图标开始到*applicationDidFinishLaunching:withOptions:*方法执行完毕为止，在这个过程中主要分为两个阶段：</p>
<ul>
<li>T1阶段：应用程序*main()<em>函数执行之前，即操作系统加载App可执行文件到内存，然后执行一系列的加载和链接等工作，最后执行至App的</em>main()*函数。</li>
<li>T2阶段：*main()<em>函数执行之后，即从</em>main()<em>函数开始，到</em>applicationDidFinishLaunching:withOptions:*方法执行完毕。</li>
</ul>
<p><img src="/images/start-time/code-start.jpg"></p>
<p>在T1阶段，通常也被称为<strong>pre-main</strong>阶段，在该阶段，主要的工作主角是操作系统，此时会执行如下几个工作：</p>
<p><img src="/images/start-time/pre-main"></p>
<p>在<strong>pre-main</strong>阶段做进行的各个任务，其主要工作也不尽相同，操作系统采用分而治之的策略，并顺序执行（可能会有并行的情况）。</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>工作</th>
</tr>
</thead>
<tbody><tr>
<td>Load dylibs</td>
<td>Dyld从主执行文件的header中获取到需要加载的所依赖动态库列表，然后找到动态库所对应的每个dylib，而应用所依赖的dylib文件还可能依赖其他的dylib，所以所需要加载的动态列表是一个递归依赖的集合。</td>
</tr>
<tr>
<td>Rebase</td>
<td>Rebase是在Image内部调整指针的指向。在历史OS中，会把动态库加载到指定的地址，所有指针和数据对应的代码都是正确的，而在随着OS的演进，指针和数据所对应的地址空间演变成了随机化的方式，所以需要在原来地址的基础上根据随机的地址偏移量进行指向修正。</td>
</tr>
<tr>
<td>Bind</td>
<td>Bind是把指针正确地指向Image外部的内容，这些指向外部的指针被符号（symbol）名称绑定，dyld需要去符号表里进行查找，找到symbol对应的实现。</td>
</tr>
<tr>
<td>ObjC Setup</td>
<td>- 注册ObjC类（class registration）  - 把category的定义插入到方法列表（category registration） - 保证每个selector的唯一性（selector uniquing）</td>
</tr>
<tr>
<td>Initializers</td>
<td>- ObjC的+load()函数   - C++的构造函数属性函数等  - 非基本类型的C++静态全局变量的创建（通常是类或结构体）</td>
</tr>
</tbody></table>
<h2 id="pre-main阶段耗时统计"><a href="#pre-main阶段耗时统计" class="headerlink" title="pre-main阶段耗时统计"></a>pre-main阶段耗时统计</h2><p>对于pre-main阶段，Xcode提供了针对上述各个阶段耗时统计的功能，只需要开发者为项目添加特殊的环境变量即可。针对pre-main耗时统计的环境变量有两个，分贝是<strong>DYLD_PRINT_STATISTICS</strong>和<strong>DYLD_PRINT_STATISTICS_DETAILS</strong>，前者是各个阶段的整体耗时统计，后者会输出一些更加详细的参数。</p>
<p>Xcode环境变量的添加位置在 <em>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Environment Variables</em>。</p>
<p><img src="/images/start-time/var-env.png"></p>
<blockquote>
<p><strong>DYLD_PRINT_STATISTICS</strong>和<strong>DYLD_PRINT_STATISTICS_DETAILS</strong>的值设置为1表示开启，0表示关闭，默认为0.</p>
</blockquote>
<p>设置之后，重启App，则会在Xcode的console中看到如下的统计输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 216.18 milliseconds (100.0%)</span><br><span class="line">         dylib loading time:  61.15 milliseconds (28.2%)</span><br><span class="line">        rebase/binding time: 126687488.9 seconds (372410141.8%)</span><br><span class="line">            ObjC setup time:  25.85 milliseconds (11.9%)</span><br><span class="line">           initializer time: 174.40 milliseconds (80.6%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :  13.24 milliseconds (6.1%)</span><br><span class="line">   libBacktraceRecording.dylib :   7.55 milliseconds (3.4%)</span><br><span class="line">    libMainThreadChecker.dylib : 144.91 milliseconds (67.0%)</span><br><span class="line">                              ...</span><br></pre></td></tr></table></figure>

<p>当然我们也可以获取更详细的时间，只需将环境变量 <strong>DYLD_PRINT_STATISTICS_DETAILS</strong> 设为 1 就可以得到更加详细的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">total time: 966.57 milliseconds (100.0%)</span><br><span class="line">  total images loaded:  334 (327 from dyld shared cache)</span><br><span class="line">  total segments mapped: 21, into 370 pages</span><br><span class="line">  total images loading time: 710.13 milliseconds (73.4%)</span><br><span class="line">  total load time in ObjC:  20.68 milliseconds (2.1%)</span><br><span class="line">  total debugger pause time: 472.96 milliseconds (48.9%)</span><br><span class="line">  total dtrace DOF registration time:   0.15 milliseconds (0.0%)</span><br><span class="line">  total rebase fixups:  17,943</span><br><span class="line">  total rebase fixups time:   2.25 milliseconds (0.2%)</span><br><span class="line">  total binding fixups: 457,972</span><br><span class="line">  total binding fixups time: 188.15 milliseconds (19.4%)</span><br><span class="line">  total weak binding fixups time:   0.01 milliseconds (0.0%)</span><br><span class="line">  total redo shared cached bindings time: 201.78 milliseconds (20.8%)</span><br><span class="line">  total bindings lazily fixed up: 0 of 0</span><br><span class="line">  total time in initializers and ObjC +load:  45.17 milliseconds (4.6%)</span><br><span class="line">                         libSystem.B.dylib :   5.18 milliseconds (0.5%)</span><br><span class="line">               libBacktraceRecording.dylib :   5.59 milliseconds (0.5%)</span><br><span class="line">                            CoreFoundation :   1.99 milliseconds (0.2%)</span><br><span class="line">                libMainThreadChecker.dylib :  27.94 milliseconds (2.8%)</span><br><span class="line">                    libLLVMContainer.dylib :   1.89 milliseconds (0.1%)</span><br><span class="line">total symbol trie searches:    1109484</span><br><span class="line">total symbol table binary searches:    0</span><br><span class="line">total images defining weak symbols:  37</span><br><span class="line">total images using weak symbols:  92</span><br></pre></td></tr></table></figure>

<p>有了以上信息，就可以对pre-main阶段的时间消耗进行一个度量和优化了。那么除了上述两个环境变量外，Xcode还支持dyld的其他一些环境变量，如下：</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>描述说明</th>
</tr>
</thead>
<tbody><tr>
<td>DYLD_PRINT_SEGMENTS</td>
<td>日志段映射</td>
</tr>
<tr>
<td>DYLD_PRINT_INITIALIZERS</td>
<td>日志图像初始化要求</td>
</tr>
<tr>
<td>DYLD_PRINT_BINDINGS</td>
<td>日志符号绑定</td>
</tr>
<tr>
<td>DYLD_PRINT_APIS</td>
<td>日志dyld API调用(例如，dlopen)</td>
</tr>
<tr>
<td>DYLD_PRINT_ENV</td>
<td>打印启动环境变量</td>
</tr>
<tr>
<td>DYLD_PRINT_OPTS</td>
<td>打印启动时命令行参数</td>
</tr>
<tr>
<td>DYLD_PRINT_LIBRARIES_POST_LAUNCH</td>
<td>日志库加载，但仅在main运行之后</td>
</tr>
<tr>
<td>DYLD_PRINT_LIBRARIES</td>
<td>日志库加载</td>
</tr>
<tr>
<td>DYLD_IMAGE_SUFFIX</td>
<td>首先搜索带有这个后缀的库</td>
</tr>
</tbody></table>
<h2 id="pre-main阶段的优化策略"><a href="#pre-main阶段的优化策略" class="headerlink" title="pre-main阶段的优化策略"></a>pre-main阶段的优化策略</h2><p>从上可知，在pre-mian阶段，应用程序会执行dylib loading、rebase&#x2F;binding、ObjC setup、initializers四个步骤，从每个阶段的主要工作分析得知：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>优化策略</th>
</tr>
</thead>
<tbody><tr>
<td>Load dylibs</td>
<td>1.尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大；2.合并已有的dylib和使用静态库（static archives），减少dylib的使用个数；3.懒加载dylib，但是要注意dlopen()可能造成一些问题，且实际上懒加载做的工作会更多</td>
</tr>
<tr>
<td>Rebase&amp;Bind</td>
<td>1.减少ObjC类（class）、方法（selector）、分类（category）的数量；2.减少C++虚函数的的数量（创建虚函数表有开销）；3.使用Swift structs（内部做了优化，符号数量更少）</td>
</tr>
<tr>
<td>ObjC Setup</td>
<td>减少 Objective-C Class、Selector、Category 的数量，可以合并或者删减一些OC类</td>
</tr>
<tr>
<td>Initializers</td>
<td>1.少在类的+load方法里做事情，尽量把这些事情推迟到+initiailize；2.减少构造器函数个数，在构造器函数里少做些事情；3.减少C++静态全局变量的个数）</td>
</tr>
</tbody></table>
<p>简单概括就是</p>
<ol>
<li>应用程序所依赖的动态库越多，启动越慢；</li>
<li>ObjC的类、方法越多，启动越慢；</li>
<li>Objc的+load()越多，或+load()中有过多的逻辑，启动越慢；</li>
<li>C的constructor函数越多，启动越慢；</li>
<li>C++静态对象越多，启动越慢。</li>
</ol>
<p>以上是对iOS App启动（主要针对冷启动）耗时的一点总结性内容，在具体的项目开发过程中，开发人员应当追求更加简洁高效的代码实现，追求高内聚，低耦合的项目架构，并有意的进行代码优化，使得App的启动耗时控制在良好的范围内，只有高效的启动，才不会再App的第一关就被Pass掉，从而为后续的业务提供良好的开端。</p>
<h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>在了解了如何进行pre-main阶段耗时治理的策略之后，你可以动手进行一系列的优化提升，这里不进行具体的代码展示，列出两个可使用的工具，有兴趣的小伙伴可以详细研读学习。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/nst/objc_cover">objc_cover</a>：一款通过对Mach-O文件进行解读，从中找到方法列表后，根据是否有对方法进行引用判定方法是否有用，可以用来删除项目中无用的方法。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jinshilaoyao/DynamicLoader/tree/5ef77c9ce819304009cf6c610b526668962dfa17">DynamicLoader</a>：一款<em>项目自启动</em>技术，实现了可插拔的函数的注册和启动等。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/413/">App Startup Time: Past, Present, and Future</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/izhangxb/GMTC/blob/master/%E5%85%A8%E7%90%83%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9AGMTC%202017%20PPT/%E6%89%8B%E6%B7%98iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2%20.pdf">手淘iOS性能优化探索</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ab47ca1518825611a406a39">探秘 Mach-O 文件</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">17 分钟读完 (大约2516个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2019-01-22-iOS_NSLog/">iOS中Log同步获取与重定向</a></h1><div class="content"><p>在iOS开发的过程中，经常会使用<code>NSLog</code>作为调试和查看相关数据的输出口，该方法连接Xcode构建项目时能够实时输出开发者在代码线中打印的日志。但是在断开Xcode并使用真机测试的时候，经常会无法查看真机的实时日志，导致一些问题难以追查和确定，导致问题的定位与解决花费较长的时间，一定程度上影响了产品开发的进度和优化。面对诸如此类的问题，我们可以通过Log信息的重定向等技术，让相关的Log信息转存到一个我们能够提取的地方，方便开发人员在出现问题的时候，得到详细的Log信息，快速的识别出问题的原因并修复和优化等。</p>
<h1 id="NSLog的输出到底在哪里？"><a href="#NSLog的输出到底在哪里？" class="headerlink" title="NSLog的输出到底在哪里？"></a>NSLog的输出到底在哪里？</h1><p>在iOS的系统API中，专门提供了一个上层函数<code>NSLog</code>以供开发者调用并打印相关的信息，<code>NSLog</code>本质上是一个C函数，它的声明如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="type">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...)</span><br></pre></td></tr></table></figure>

<p>系统对该函数的说明是：<code>Logs an error message to the Apple System Log facility</code>。简单的说就是用来输出信息到标准的Error控制台上，其内部其实是使用<code>Apple System Log（asl）</code>的API，至少iOS 10以前是这样。在调试阶段，日志会输出到Xcode中，而在真机上，会输出到系统的<code>/var/log/syslog</code>文件中。</p>
<h1 id="Apple-System-Logger"><a href="#Apple-System-Logger" class="headerlink" title="Apple System Logger"></a>Apple System Logger</h1><p>我们可以通过<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/1395074-nslogv?language=objc">官方文档</a>了解到，OC中最常见的NSLog操作会同时将标准的Error输出到控制台和系统日志(syslog)中(C语言的printf系列函数并不会，swift的printf为了保证性能也只会在模拟器环境中输出)。其内部是使用Apple System Logger(简称ASL)去实现的，ASL是苹果自己实现的用于输出日志到系统日志库的一套API接口，有点类似于SQL操作。在iOS真机设备上，使用ASL记录的log被缓存在沙盒文件中，直到设备被重启。</p>
<p>既然日志被写入系统的syslog中，那我们可以直接读取这些日志。从ASL读取日志的核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;asl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 从日志的对象aslmsg中获取我们需要的数据</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)logMessageFromASLMessage:(aslmsg)aslMessage&#123;</span><br><span class="line">    SystemLogMessage *logMessage = [[SystemLogMessage alloc] init];</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *timestamp = asl_get(aslMessage, ASL_KEY_TIME);</span><br><span class="line">    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeInterval = [@(timestamp) integerValue];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *nanoseconds = asl_get(aslMessage, ASL_KEY_TIME_NSEC);</span><br><span class="line">        <span class="keyword">if</span> (nanoseconds) &#123;</span><br><span class="line">            timeInterval += [@(nanoseconds) doubleValue] / <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logMessage.timeInterval = timeInterval;</span><br><span class="line">        logMessage.date = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *sender = asl_get(aslMessage, ASL_KEY_SENDER);</span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        logMessage.sender = @(sender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *messageText = asl_get(aslMessage, ASL_KEY_MSG);</span><br><span class="line">    <span class="keyword">if</span> (messageText) &#123;</span><br><span class="line">        logMessage.messageText = @(messageText);<span class="comment">//NSLog写入的文本内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *messageID = asl_get(aslMessage, ASL_KEY_MSG_ID);</span><br><span class="line">    <span class="keyword">if</span> (messageID) &#123;</span><br><span class="line">        logMessage.messageID = [@(messageID) longLongValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logMessage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSMutableArray</span>&lt;SystemLogMessage *&gt; *)allLogMessagesForCurrentProcess&#123;</span><br><span class="line">    asl_object_t query = asl_new(ASL_TYPE_QUERY);</span><br><span class="line">    <span class="comment">// Filter for messages from the current process. </span></span><br><span class="line">    <span class="comment">// Note that this appears to happen by default on device, </span></span><br><span class="line">    <span class="comment">// but is required in the simulator.</span></span><br><span class="line">    <span class="built_in">NSString</span> *pidString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d&quot;</span>, [[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier]];</span><br><span class="line">    asl_set_query(query, ASL_KEY_PID, [pidString UTF8String], ASL_QUERY_OP_EQUAL);</span><br><span class="line"></span><br><span class="line">    aslresponse response = asl_search(<span class="literal">NULL</span>, query);</span><br><span class="line">    aslmsg aslMessage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *logMessages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">while</span> ((aslMessage = asl_next(response))) &#123;</span><br><span class="line">        [logMessages addObject:[SystemLogMessage logMessageFromASLMessage:aslMessage]];</span><br><span class="line">    &#125;</span><br><span class="line">    asl_release(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logMessages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以上方法的好处是不会影响Xcode控制台的输出，可以用非侵入性的方式来读取日志。</p>
<h1 id="ASL在iOS10后被弃用"><a href="#ASL在iOS10后被弃用" class="headerlink" title="ASL在iOS10后被弃用"></a>ASL在iOS10后被弃用</h1><p>但是Apple从iOS 10开始，为了减弱ASL对于日志系统的侵入性，直接废弃掉了ASL<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/os/logging?language=objc">link</a>，导致在iOS 10之后的系统版本中无法使用ASL相关的API。因此为了能够在iOS 10之后的版本中同样获取日志数据，我们寻找一种版本兼容的解决方案。</p>
<h1 id="NSLog重定向"><a href="#NSLog重定向" class="headerlink" title="NSLog重定向"></a>NSLog重定向</h1><p>NSLog能输出到文件syslog中，靠的是文件IO的API的调用，那么在这些IO操作中，一定存在文件句柄。在C语言中，存在默认的三个文件句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> stdin __stdinp </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stdout __stdoutp </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stderr __stderrp</span></span><br></pre></td></tr></table></figure>

<p>其对应的三个iOS版本的文件句柄是(定义在<code>unistd.h</code>文件中):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	 STDIN_FILENO	0	<span class="comment">/* standard input file descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STDOUT_FILENO	1	<span class="comment">/* standard output file descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STDERR_FILENO	2	<span class="comment">/* standard error file descriptor */</span></span></span><br></pre></td></tr></table></figure>

<p>在使用重定向之后，NSLog就不会写到系统的syslog中了。</p>
<h2 id="dup2重定向"><a href="#dup2重定向" class="headerlink" title="dup2重定向"></a>dup2重定向</h2><p>通过重定向，可以直接截取<code>stdout,stderr</code>等标准输出的信息，然后保存在想要存储的位置，上传到服务器或者显示到View上。<br>要做到重定向，需要通过<code>NSPipe</code>创建一个管道，pipe有读端和写端，然后通过<code>dup2</code>将标准输入重定向到pipe的写端。再通过<code>NSFileHandle</code>监听pipe的读端，最后再处理读出的信息。<br>之后通过<code>printf</code>或者<code>NSLog</code>写数据，都会写到pipe的写端，同时pipe会将这些数据直接传送到读端，最后通过NSFileHandle的监控函数取出这些数据。<br>核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)redirectStandardOutput&#123;</span><br><span class="line">    <span class="comment">//记录标准输出及错误流原始文件描述符</span></span><br><span class="line">    <span class="keyword">self</span>.outFd = dup(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">self</span>.errFd = dup(STDERR_FILENO);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    stdout-&gt;_flags = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSPipe</span> *outPipe = [<span class="built_in">NSPipe</span> pipe];</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *pipeOutHandle = [outPipe fileHandleForReading];</span><br><span class="line">    dup2([[outPipe fileHandleForWriting] fileDescriptor], STDOUT_FILENO);</span><br><span class="line">    [pipeOutHandle readInBackgroundAndNotify];</span><br><span class="line"></span><br><span class="line">    stderr-&gt;_flags = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSPipe</span> *errPipe = [<span class="built_in">NSPipe</span> pipe];</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *pipeErrHandle = [errPipe fileHandleForReading];</span><br><span class="line">    dup2([[errPipe fileHandleForWriting] fileDescriptor], STDERR_FILENO);</span><br><span class="line">    [pipeErrHandle readInBackgroundAndNotify];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> </span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(redirectOutNotificationHandle:) </span><br><span class="line">                                            name:<span class="built_in">NSFileHandleReadCompletionNotification</span> </span><br><span class="line">                                            object:pipeOutHandle];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> </span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(redirectErrNotificationHandle:) </span><br><span class="line">                                            name:<span class="built_in">NSFileHandleReadCompletionNotification</span> </span><br><span class="line">                                            object:pipeErrHandle];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)recoverStandardOutput&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    dup2(<span class="keyword">self</span>.outFd, STDOUT_FILENO);</span><br><span class="line">    dup2(<span class="keyword">self</span>.errFd, STDERR_FILENO);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向之后的NSLog输出</span></span><br><span class="line">- (<span class="type">void</span>)redirectOutNotificationHandle:(<span class="built_in">NSNotification</span> *)nf&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [[nf userInfo] objectForKey:<span class="built_in">NSFileHandleNotificationDataItem</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// YOUR CODE HERE...  保存日志并上传或展示</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [[nf object] readInBackgroundAndNotify];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向之后的错误输出</span></span><br><span class="line">- (<span class="type">void</span>)redirectErrNotificationHandle:(<span class="built_in">NSNotification</span> *)nf&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [[nf userInfo] objectForKey:<span class="built_in">NSFileHandleNotificationDataItem</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// YOUR CODE HERE...  保存日志并上传或展示</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [[nf object] readInBackgroundAndNotify];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dup函数可以为我们复制一个文件描述符，传给该函数一个既有的描述符，它就会返回一个新的描述符，这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。<br>而dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。</p>
</blockquote>
<h2 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h2><p>另一种重定向的方式是利用c语言的<code>freopen</code>函数进行重定向，将写往<code>stderr</code>的内容重定向到我们制定的文件中去，一旦执行了上述代码那么在这个之后的NSLog将不会在控制台显示了，会直接输出在指定的文件中。<br>在模拟器中，我们可以使用终端的<code>tail</code>命令(tail -f xxx.log)对这个文件进行实时查看，就如同我们在Xcode的输出窗口中看到的那样，你还可以结合<code>grep</code>命令进行实时过滤查看，非常方便在大量的日志信息中迅速定位到我们要的日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * <span class="title function_">freopen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode, FILE * stream )</span>;</span><br></pre></td></tr></table></figure>

<p>核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSString</span> *documentsPath = [paths objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *loggingPath = [documentsPath stringByAppendingPathComponent:<span class="string">@&quot;/xxx.log&quot;</span>];</span><br><span class="line"><span class="comment">//redirect NSLog</span></span><br><span class="line">freopen([loggingPath cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], <span class="string">&quot;a+&quot;</span>, stderr);</span><br></pre></td></tr></table></figure>

<p>这样我们就可以把可获取的日志文件发送给服务端或者通过itunes共享出来。但是由于iOS严格的沙盒机制，我们无法知道stderr原来的文件路径，也无法直接使用沙盒外的文件，所以freopen无法重定向回去，只能使用第1点所述的dup和dup2来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向</span></span><br><span class="line"><span class="type">int</span> origin1 = dup(STDERR_FILENO);</span><br><span class="line">FILE * myFile = freopen([loggingPath cStringUsingEncoding:NSASCIIStringEncoding], <span class="string">&quot;a+&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="comment">// 恢复重定向</span></span><br><span class="line">dup2(origin1, STDERR_FILENO);</span><br></pre></td></tr></table></figure>

<h2 id="使用GCD的dispatch-Source重定向方式"><a href="#使用GCD的dispatch-Source重定向方式" class="headerlink" title="使用GCD的dispatch Source重定向方式"></a>使用GCD的dispatch Source重定向方式</h2><p>具体代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_source_t)_startCapturingWritingToFD:(<span class="type">int</span>)fd  &#123;</span><br><span class="line">    <span class="type">int</span> fildes[<span class="number">2</span>];</span><br><span class="line">    pipe(fildes);  <span class="comment">// [0] is read end of pipe while [1] is write end</span></span><br><span class="line">    dup2(fildes[<span class="number">1</span>], fd);  <span class="comment">// Duplicate write end of pipe &quot;onto&quot; fd (this closes fd)</span></span><br><span class="line">    close(fildes[<span class="number">1</span>]);  <span class="comment">// Close original write end of pipe</span></span><br><span class="line">    fd = fildes[<span class="number">0</span>];  <span class="comment">// We can now monitor the read end of the pipe</span></span><br><span class="line">    <span class="type">char</span>* buffer = malloc(<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">NSMutableData</span>* data = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    dispatch_source_t source = dispatch_source_create(</span><br><span class="line">        DISPATCH_SOURCE_TYPE_READ, fd, <span class="number">0</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>));</span><br><span class="line">    dispatch_source_set_cancel_handler(source, ^&#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ssize_t size = read(fd, buffer, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                [data appendBytes:buffer length:size];</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *aString = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="comment">//printf(&quot;aString = %s&quot;,[aString UTF8String]);</span></span><br><span class="line">            <span class="comment">//NSLog(@&quot;aString = %@&quot;,aString);</span></span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(source);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然上述的几个重定向的方法都能够获取到Log数据，但是弊端是当使用Log重定向之后，连接Xcode进行调试应用程序时，Xcode的Console中将不会打印任何Log信息，Log信息已经被重定向到了我们指定的文件中了。这些方法有一定的局限性，在具体使用的时候，需要视情况而定。当然还有其他的方式能够即重定向Log数据到指定文件，还能够在Xcode的Console中输出日志（pipe、dup2与GCD的相互协作），这样能够避免调试阶段无法实时查看日志的缺陷，进一步的提高开发调试和优化的效率。</p>
<p>另外也可以开发一个在桌面或者网页端实时展示Log信息的应用，实时从重定向的位置读取Log信息，达到实时查看信息的目的等。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>