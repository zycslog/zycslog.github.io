<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Robin&#39;s Wo</title>
  
  <subtitle>想法、故事、小思考</subtitle>
  <link href="https://zycslog.github.io/atom.xml" rel="self"/>
  
  <link href="https://zycslog.github.io/"/>
  <updated>2022-06-19T07:16:33.586Z</updated>
  <id>https://zycslog.github.io/</id>
  
  <author>
    <name>Robin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再议Objective-C 2.0 中的 Runtime</title>
    <link href="https://zycslog.github.io/2022/06/19/2022-05-25-runtime-again/"/>
    <id>https://zycslog.github.io/2022/06/19/2022-05-25-runtime-again/</id>
    <published>2022-06-19T06:47:10.914Z</published>
    <updated>2022-06-19T07:16:33.586Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="type">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>可以看到其中保存了类的实例变量，方法列表等信息。</p><p>不知道有多少读者思考过 <code>OBJC2_UNAVAILABLE</code> 意味着什么。其实早在 2006 年，苹果在 WWDC 大会上就发布了 <a href="https://en.wikipedia.org/wiki/Objective-C#Objective-C_2.0">Objective-C 2.0</a>，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。</p><p>这意味着上述代码，以及任何带有 <code>OBJC2_UNAVAILABLE</code> 标记的内容，都已经在 2006 年就永远的告别了我们，只停留在历史的文档中。</p><h2 id="Category-的原理"><a href="#Category-的原理" class="headerlink" title="Category 的原理"></a>Category 的原理</h2><p>虽然上述代码已经过时，但仍具备一定的参考意义，比如 <code>methodLists</code> 作为一个二级指针，其中每个元素都是一个数组，数组中的每个元素则是一个方法。</p><p>接下来就介绍一下 category 的工作原理，在美团的技术博客 <a href="http://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a> 中已经有了非常详细的解释，然而可能由于时间问题，其中的不少内容已经过时，我根据目前最新的版本(objc-680) 做一些简单的分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。</p><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先 runtime 依赖于 dyld 动态加载，在 objc-os.mm 文件中可以找到入口，它的调用栈简单整理如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">└──<span class="keyword">const</span> <span class="type">char</span> *map_2_images(...)</span><br><span class="line">    └──<span class="keyword">const</span> <span class="type">char</span> *map_images_nolock(...)</span><br><span class="line">        └──<span class="type">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br></pre></td></tr></table></figure><p>以上四个方法可以理解为 runtime 的初始化过程，我们暂且不深究。在 <code>_read_images</code> 方法中有如下代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">    <span class="comment">/* ||  cat-&gt;classProperties */</span>) &#123;</span><br><span class="line">    addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">        remethodizeClass(cls-&gt;ISA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释可见苹果曾经计划利用 category 来添加属性。在 <code>addUnattachedCategoryForClass</code> 方法中会找到当前类的所有 category，然后在 <code>remethodizeClass</code> 真正的去做处理。不过到目前为止还没有接触到相关的 category 处理，我们继续沿着调用栈向下走:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _read_images(header_info **hList, uint32_t hCount)</span><br><span class="line">└──<span class="keyword">static</span> <span class="type">void</span> remethodizeClass(Class cls)</span><br><span class="line">    └──<span class="keyword">static</span> <span class="type">void</span> attachCategories(Class cls, category_list *cats, <span class="type">bool</span> flush_caches)</span><br></pre></td></tr></table></figure><p>这里的 <code>attachCategories</code> 就是处理 category 的核心所在，不过在阅读这段代码之前，我们有必要先熟悉一下相关的数据结构。</p><h3 id="Category-相关的数据结构"><a href="#Category-相关的数据结构" class="headerlink" title="Category 相关的数据结构"></a>Category 相关的数据结构</h3><p>首先来了解一下一个 Category 是如何存储的，在 objc-runtime-new.h 中可以看到如下定义，我只列出了其中成员变量:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见一个 category 持有了一个 <code>method_list_t</code> 类型的数组，<code>method_list_t</code> 又继承自 <code>entsize_list_tt</code>，这是一种泛型容器:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_list_t : entsize_list_tt&lt;method_t, method_list_t, <span class="number">0x3</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 成员变量和方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List, uint32_t FlagMask&gt;</span><br><span class="line"><span class="keyword">struct</span> entsize_list_tt &#123;</span><br><span class="line">    uint32_t entsizeAndFlags;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    Element first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>entsize_list_tt</code> 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。 <code>Element</code> 表示元素类型，<code>List</code> 用于指定容器类型，最后一个参数为标记位。</p><p>虽然这段代码实现比较复杂，但仍可了解到 <code>method_list_t</code> 是一个存储 <code>method_t</code> 类型元素的容器。<code>method_t</code> 结构体的定义如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，我们还有一个结构体 <code>category_list</code> 用来存储所有的 category，它的定义如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> locstamped_category_list_t &#123;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    locstamped_category_t list[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> locstamped_category_t &#123;</span><br><span class="line">    category_t *cat;</span><br><span class="line">    <span class="keyword">struct</span> header_info *hi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> locstamped_category_list_t category_list;</span><br></pre></td></tr></table></figure><p>除了标记存储的 category 的数量外，<code>locstamped_category_list_t</code> 结构体还声明了一个长度为零的数组，这其实是 C99 中的一种写法，允许我们在运行期动态的申请内存。</p><p>以上就是相关的数据结构，只要了解到这个程度就可以继续读源码了。</p><h3 id="处理-Category"><a href="#处理-Category" class="headerlink" title="处理 Category"></a>处理 Category</h3><p>对 Category 中方法的解析并不复杂，首先来看一下 <code>attachCategories</code> 的简化版代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> attachCategories(Class cls, category_list *cats, <span class="type">bool</span> flush_caches) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="type">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，通过 while 循环，我们遍历所有的 category，也就是参数 <code>cats</code> 中的 <code>list</code> 属性。对于每一个 category，得到它的方法列表 <code>mlist</code> 并存入 <code>mlists</code> 中。</p><p>换句话说，我们将所有 category 中的方法拼接到了一个大的二维数组中，数组的每一个元素都是装有一个 category 所有方法的容器。这句话比较绕，但你可以把 <code>mlists</code> 理解为文章开头所说，旧版本的 <code>objc_method_list **methodLists</code>。</p><p>在 while 循环外，我们得到了拼接成的方法，此时需要与类原来的方法合并:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto rw = cls-&gt;data();</span><br><span class="line">rw-&gt;methods.attachLists(mlists, mcount);</span><br></pre></td></tr></table></figure><p>这两行代码读不懂是必然的，因为在 Objective-C 2.0 时代，对象的内存布局已经发生了一些变化。我们需要先了解对象的布局模型才能理解这段代码。</p><h2 id="Objective-C-2-0-对象布局模型"><a href="#Objective-C-2-0-对象布局模型" class="headerlink" title="Objective-C 2.0 对象布局模型"></a>Objective-C 2.0 对象布局模型</h2><h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p>相信读到这里的大部分读者都学习过文章开头所说的对象布局模型，因此在这一部分，我们采用类比的方法，来看看 Objective-C 2.0 下发生了哪些改变。</p><p>首先，<code>Class</code> 和 <code>id</code> 指针的定义并没有发生改变，他们一个指向类对应的结构体，一个指向对象对应的结构体:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="type">id</span>;</span><br></pre></td></tr></table></figure><p>比较有意思的一点是，<code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一点也很容易理解，早在 Objective-C 1.0 时代，我们就知道一个对象的结构体只有 <code>isa</code> 指针，指向它所属的类。而类的结构体也有 <code>isa</code> 指针指向它的元类。因此让类结构体继承自对象结构体就很容易理解了。 </p><p>可见 Objective-C 1.0 的布局模型中，<code>cache</code> 和 <code>super_class</code> 被原封不动的移过来了，而剩下的属性则似乎消失不见。取而代之的是一个 <code>bits</code> 属性，以及 <code>data()</code> 方法，这个方法调用的其实是 <code>bits</code> 属性的 <code>data()</code> 方法，并返回了一个 <code>class_rw_t</code> 类型的结构体指针。 </p><h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p>以下是简化版 <code>class_data_bits_t</code> 结构体的定义:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这个结构体只有一个 64 位的 <code>bits</code> 成员，存储了一个指向 <code>class_rw_t</code> 结构体的指针和三个标志位。它实际上由三部分组成。首先由于 Mac OS X 只使用 47 位内存地址，所以前 17 位空余出来，提供给 <code>retain/release 和</code> <code>alloc/dealloc</code> 方法使用，做一些优化。其次，由于内存对齐，指针地址的后三位都是 0，因此可以用来做标志位:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// class&#x27;s instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure><p>如果计算一下就会发现，<code>FAST_DATA_MASK</code> 这个 16 进制常量的二进制表示恰好后三位为0，且长度为47位: <code>11111111111111111111111111111111111111111111000</code>，我们通过这个掩码做按位与运算即可取出正确的指针地址。</p><p>引用 Draveness 在 <a href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a> 中的图片做一个总结:</p><p><img src="/images/runtime-again/bit.png" alt="bits 示意图"></p><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>bits</code> 中包含了一个指向 <code>class_rw_t</code> 结构体的指针，它的定义如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到有一个名字很类似的结构体 <code>class_ro_t</code>，这里的 ‘rw’ 和 ro’ 分别表示 ‘readwrite’ 和 ‘readonly’。因为  <code>class_ro_t</code> 存储了一些由编译器生成的常量。</p><blockquote><p>These are emitted by the compiler and are part of the ABI. </p></blockquote><p>正是由于 <code>class_ro_t</code> 中的两个属性 <code>instanceStart</code> 和 <code>instanceSize</code> 的存在，保证了 Objective-C2.0 的 ABI 稳定性。因为即使父类增加方法，子类也可以在运行时重新计算 ivar 的偏移量，从而避免重新编译。</p><p>关于 ABI 稳定性的问题，本文不做赘述，读者可以参考 <a href="http://www.jianshu.com/p/3b219ab86b09">Non Fragile ivars</a>。</p><p>如果阅读 <code>class_ro_t</code> 结构体的定义就会发现，旧版本实现中类结构体中的大部分成员变量现在都定义在 <code>class_ro_t</code> 和 <code>class_rw_t</code> 这两个结构体中了。感兴趣的读者可以自行对比，本文不再赘述。</p><p><code>class_rw_t</code> 结构体中还有一个 <code>methods</code> 成员变量，它的类型是 <code>method_array_t</code>，继承自 <code>list_array_tt</code>。</p><p><code>list_array_tt</code> 是一个泛型结构体，用于存储一些元数据，而它实际上是元数据的二维数组:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;&#123;</span><br><span class="line">    <span class="keyword">struct</span> array_t &#123;</span><br><span class="line">        uint32_t count;</span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> method_array_t : public list_array_tt&lt;method_t, method_list_t&gt; </span><br></pre></td></tr></table></figure><p>其中 <code>Element</code> 表示元数据的类型，比如 <code>method_t</code>，而 <code>List</code> 则表示用于存储元数据的一维数组，比如 <code>method_list_t</code>。</p><p><code>list_array_tt</code> 有三种状态:</p><ol><li>自身为空，可以类比为 <code>[[]]</code></li><li>它只有一个指针，指向一个元数据的集合，可以类比为 <code>[[1, 2]]</code></li><li>它有多个指针，指向多个元数据的集合，可以类比为 <code>[[1, 2], [3, 4]]</code></li></ol><p>当一个类刚创建时，它可能处于状态 1 或 2，但如果使用 <code>class_addMethod</code> 或者 category 来添加方法，就会进入状态 3，而且一旦进入状态 3 就再也不可能回到其他状态，即使新增的方法后来又被移除掉。</p><h2 id="方法合并"><a href="#方法合并" class="headerlink" title="方法合并"></a>方法合并</h2><p>掌握了这些 runtime 的基础只是以后就可以继续钻研剩下的 category 的代码了:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto rw = cls-&gt;data();</span><br><span class="line">rw-&gt;methods.attachLists(mlists, mcount);</span><br></pre></td></tr></table></figure><p>这是刚刚卡住的地方，现在来看，<code>rw</code> 是一个 <code>class_rw_t</code> 类型的结构体指针。根据 runtime 中的数据结构，它有一个 <code>methods</code> 结构体成员，并从父类继承了 <code>attachLists</code> 方法，用来合并 category 中的方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    uint32_t oldCount = array()-&gt;count;</span><br><span class="line">    uint32_t newCount = oldCount + addedCount;</span><br><span class="line">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">    array()-&gt;count = newCount;</span><br><span class="line">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    memcpy(array()-&gt;lists, addedLists, addedCount * <span class="keyword">sizeof</span>(array()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，其实就是先调用 <code>realloc()</code> 函数将原来的空间拓展，然后把原来的数组复制到后面，最后再把新数组复制到前面。</p><p>在实际代码中，比上面略复杂一些。因为为了提高性能，苹果做了一些优化，比如当 List 处于第二种状态(只有一个指针，指向一个元数据的集合)时，其实并不需要在原地扩容空间，而是只要重新申请一块内存，并将最后一个位置留给原来的集合即可。</p><p>这样只多花费了很少的内存空间，也就是原来二维数组占用的内存空间，但是 <code>malloc()</code> 的性能优势会更加明显，这其实是一个空间换时间的权衡问题。</p><p>需要注意的是，无论执行哪种逻辑，参数列表中的方法都会被添加到二维数组的前面。而我们简单的看一下 runtime 在查找方法时的逻辑:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123;</span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists) &#123;</span><br><span class="line">        method_t *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> method_t *search_method_list(<span class="keyword">const</span> method_list_t *mlist, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">        <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见搜索的过程是按照从前向后的顺序进行的，一旦找到了就会停止循环。因此 category 中定义的同名方法不会替换类中原有的方法，但是对原方法的调用实际上会调用 category 中的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完本文后，你应该对以下内容有比较深刻的理解，排名不分先后:</p><ol><li>定义在 runtime.h 中的数据结构，如果有 <code>OBJC2_UNAVAILABLE</code> 标记则表示已经废弃。</li><li>Objective-C 2.0 中，类结构体的结构层次: <code>objc_class</code> -&gt; <code>class_data_bits_t</code> -&gt; <code>class_rw_t</code> -&gt; <code>method_array_t</code>。</li><li><code>class_ro_t</code> 结构体的作用，与 <code>class_rw_t</code> 的区别，以及和 ABI 稳定性的关系。</li><li>category 解析过程的调用栈以及基本的流程。</li><li><code>method_array_t</code> 为什么要设计成一种类似于二维数组的数据结构，以及它的三种状态之间的关系。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></li><li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md">从源代码看 ObjC 中消息的发送</a></li><li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a></li><li><a href="http://stackoverflow.com/questions/8847146/whats-is-methodlists-attribute-of-the-structure-objc-class-for">Whats is methodLists attribute of the structure objc_class for?</a></li><li><a href="http://www.cnblogs.com/jiazhh/articles/3309085.html">Objc与C（C++）之亲缘关系（一） Class</a></li><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝大多数 iOS 开发者在学习 runtime 时都阅读过 runtime.h 文件中的这段代码:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class                                        OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;long&lt;/span&gt; version                                             OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;long&lt;/span&gt; info                                                OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;long&lt;/span&gt; instance_size                                       OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists                    OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                                 OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到其中保存了类的实例变量，方法列表等信息。&lt;/p&gt;
&lt;p&gt;不知道有多少读者思考过 &lt;code&gt;OBJC2_UNAVAILABLE&lt;/code&gt; 意味着什么。其实早在 2006 年，苹果在 WWDC 大会上就发布了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C#Objective-C_2.0&quot;&gt;Objective-C 2.0&lt;/a&gt;，其中的改动包括 Max OS X 平台上的垃圾回收机制(现已废弃)，runtime 性能优化等。&lt;/p&gt;
&lt;p&gt;这意味着上述代码，以及任何带有 &lt;code&gt;OBJC2_UNAVAILABLE&lt;/code&gt; 标记的内容，都已经在 2006 年就永远的告别了我们，只停留在历史的文档中。&lt;/p&gt;
&lt;h2 id=&quot;Category-的原理&quot;&gt;&lt;a href=&quot;#Category-的原理&quot; class=&quot;headerlink&quot; title=&quot;Category 的原理&quot;&gt;&lt;/a&gt;Category 的原理&lt;/h2&gt;&lt;p&gt;虽然上述代码已经过时，但仍具备一定的参考意义，比如 &lt;code&gt;methodLists&lt;/code&gt; 作为一个二级指针，其中每个元素都是一个数组，数组中的每个元素则是一个方法。&lt;/p&gt;
&lt;p&gt;接下来就介绍一下 category 的工作原理，在美团的技术博客 &lt;a href=&quot;http://tech.meituan.com/DiveIntoCategory.html&quot;&gt;深入理解Objective-C：Category&lt;/a&gt; 中已经有了非常详细的解释，然而可能由于时间问题，其中的不少内容已经过时，我根据目前最新的版本(objc-680) 做一些简单的分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何进行 Git 仓库瘦身</title>
    <link href="https://zycslog.github.io/2022/06/19/2022-05-20-how-to-reduce-git/"/>
    <id>https://zycslog.github.io/2022/06/19/2022-05-20-how-to-reduce-git/</id>
    <published>2022-06-19T06:18:32.204Z</published>
    <updated>2022-06-19T06:53:17.889Z</updated>
    
    <content type="html"><![CDATA[<p>对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题：</p><ul><li>理解从 Git 的历史记录中删除文件</li><li>使用 BFG 重写历史记录</li><li>可选，使用 git filter-branch 重写历史记录</li><li>垃圾回收</li></ul><p>请格外小心…..</p><p>本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 <a href="http://stackoverflow.com/questions/3959924/whats-the-difference-between-git-clone-mirror-and-git-clone-bare">–mirror</a> 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了您的仓库的关键元素，那么你可以通过备份的仓库来恢复。</p><p>请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是一个不错的主意。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。</p><h3 id="理解从-Git-的历史记录中删除文件"><a href="#理解从-Git-的历史记录中删除文件" class="headerlink" title="理解从  Git  的历史记录中删除文件"></a><strong>理解从</strong>  <strong>Git</strong>  <strong>的历史记录中删除文件</strong></h3><p>回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：</p><ul><li>从你的项目的当前的文件树中删除该文件;</li><li>从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;</li><li>删除指向旧的提交历史记录的所有 <a href="http://git-scm.com/docs/git-reflog">reflog</a> 历史记录;</li><li>重新整理仓库，使用 <a href="http://git-scm.com/docs/git-gc">git gc</a> 对现在没有使用的数据进行垃圾回收。</li></ul><span id="more"></span><p>Git 的 &quot;gc&quot;（垃圾回收）将通过你的任何一个分支或者标签来删除仓库中所有的实际没用的或者以某种方式引用的数据。为了使其发挥作用，我们需要重写包含不需要的文件的所有 Git 仓库历史记录，仓库将不再引用它—— git gc 将会丢弃所有没用的数据。</p><p>重写存储库历史是一个棘手的事情，因为每个提交都依赖它的父提交，所以任何一个很小的改变都会改变它的每一个随后的提交的提交 ID。有两个自动化的工具可以做到这：</p><ol><li><a href="http://rtyley.github.io/bfg-repo-cleaner/">BFG Repo Cleaner</a> 快速、简单且易于使用，需要 Java 6 或者更高版本的运行环境。</li><li><a href="http://git-scm.com/docs/git-filter-branch">git filter-branch</a> 功能强大、配置麻烦，用于大于仓库时速度较慢，是核心 Git 套件的一部分。</li></ol><p>切记，当你重写历史记录后，无论你是使用 BFG 还是使用 filter-branch，你都需要删除指向旧的历史记录的 reflog 条目，最后运行垃圾回收器来删除旧的数据。</p><h3 id="使用-BFG-重写历史记录"><a href="#使用-BFG-重写历史记录" class="headerlink" title="使用  BFG  重写历史记录"></a><strong>使用</strong>  <strong>BFG</strong>  <strong>重写历史记录</strong></h3><p><a href="http://rtyley.github.io/bfg-repo-cleaner/">BFG</a> 是为将像大文件或者密码这些不想要的数据从 Git 仓库中删除而专门设计的，所以它有一一个简单的标志用来删除那些大的历史文件（不在当前的提交里面）：–strip-blobs-bigger-than</p><ol><li>$ java -jar bfg.jar –strip-blobs-than 100M</li></ol><p>大小超过 100MB 的任何文件（不包含在你最近的提交中的文件——因为 BFG <a href="http://rtyley.github.io/bfg-repo-cleaner/#protected-commits">默认会保护你的最新提交的内容</a>）将会从你的 Git 仓库的历史记录中删除。如果你想用名字来指明具体的文件，你也可以这样做：</p><ol><li>$ java -jar bfg.jar –delete-files *.mp4</li></ol><p>BFG 的速度要比 git filter-branch 快 <a href="https://www.youtube.com/watch?v=Ir4IHzPhJuI">10-1000 倍</a>，而且通常更容易使用——查看完整的<a href="http://rtyley.github.io/bfg-repo-cleaner/#usage">使用说明</a>和<a href="http://rtyley.github.io/bfg-repo-cleaner/#examples">示例</a>获取更多细节。</p><h3 id="或者，使用-git-filter-branch-来重写历史记录"><a href="#或者，使用-git-filter-branch-来重写历史记录" class="headerlink" title="或者，使用  git filter-branch  来重写历史记录"></a><strong>或者，使用</strong>  <strong>git filter-branch</strong>  <strong>来重写历史记录</strong></h3><p>filter-branch 命令可以对 Git 仓库的历史记录重写，就像 BFG 一样，但是过程更慢和更手动化。如果你不知道这些大文件在哪里，那么你第一步就需要找到它们：</p><h4 id="手动查看你-Git-仓库中的大文件"><a href="#手动查看你-Git-仓库中的大文件" class="headerlink" title="手动查看你  Git  仓库中的大文件"></a><strong>手动查看你</strong>  <strong>Git</strong>  <strong>仓库中的大文件</strong></h4><p><a href="https://stubbisms.wordpress.com/2009/07/10/git-script-to-show-largest-pack-objects-and-trim-your-waist-line/">Antony Stubbs</a> 写了一个可以很好地完成这个功能的 BASH 脚本。该脚本可以检查你的包文件的内容并列出大文件。在你开始删除文件之前，请执行以下操作获取并安装此脚本：</p><p>1、 <a href="https://confluence.atlassian.com/bitbucket/files/321848291/321979854/1/1360604134990/git_find_big.sh">下载脚本</a>到你的本地的系统。</p><p>2、 将它放在一个可以访问你的 Git 仓库的易于找到的位置。</p><p>3、 让脚本成为可执行文件：</p><ol><li>$ chmod 777 git_find_big.sh</li></ol><p>4、 克隆仓库到你本地系统。</p><p>5、 改变当前目录到你的仓库根目录。</p><p>6、 手动运行 Git 垃圾回收器：</p><ol><li>git gc –auto</li></ol><p>7、 找出 .git 文件夹的大小</p><ol><li>$ du -hs .git&#x2F;objects</li><li>45M .git&#x2F;objects</li></ol><p>注意文件大小，以便随后参考。</p><p>8、 运行 git_find_big.sh 脚本来列出你的仓库中的大文件。</p><ol><li>$ git_find_big.sh</li><li>All sizes are in kB&#39;s. The pack column is the size of the object, compressed, inside the pack file.</li><li>size pack SHA                                       location</li><li>592   580   e3117f48bc305dd1f5ae0df3419a0ce2d9617336 media&#x2F;img&#x2F;emojis.jar</li><li>550   169   b594a7f59ba7ba9daebb20447a87ea4357874f43 media&#x2F;js&#x2F;aui&#x2F;aui-dependencies.jar</li><li>518   514   22f7f9a84905aaec019dae9ea1279a9450277130 media&#x2F;images&#x2F;screenshots&#x2F;issue-tracker-wiki.jar</li><li>337   92   1fd8ac97c9fecf74ba6246eacef8288e89b4bff5 media&#x2F;js&#x2F;lib&#x2F;bundle.js</li><li>240   239   e0c26d9959bd583e5ef32b6206fc8abe5fea8624 media&#x2F;img&#x2F;featuretour&#x2F;heroshot.png</li></ol><p>大文件都是 JAR 文件，包的大小列是最相关的。aui-dependencies.jar 被压缩到 169kb，但是 emojis.jar 只压缩到 500kb。emojis.jar 就是一个待删除的对象。</p><h4 id="运行-filter-branch"><a href="#运行-filter-branch" class="headerlink" title="运行  filter-branch"></a><strong>运行</strong>  <strong>filter-branch</strong></h4><p>你可以给这个命令传递一个用于重写 Git 索引的过滤器。例如，一个过滤器可以可以将每个检索的提交删除。这个用法如下：</p><ol><li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch  _pathname_ &#39; commitHASH</li></ol><p>–index-filter 选项可以修改仓库的索引，–cached 选项从索引中而不是磁盘来删除文件。这样会更快，因为你不需要在运行这个过滤器前检查每个修订版本。git rm 中的 ignore-unmatch 选项可以防止在尝试移走不存在的文件 pathname 的时候命令失败。通过指定一个提交 HASH 值，你可以从每个以这个 HASH 值开始的提交中删除pathname。要从开始处删除，你可以省略这个参数或者指定为 HEAD。</p><p>如果你的大文件在不同的分支，你将需要通过名字来删除每个文件。如果大文件都在一个单独的分支，你可以直接删除这个分支本身。</p><h4 id="选项-1-：通过文件名删除文件"><a href="#选项-1-：通过文件名删除文件" class="headerlink" title="选项  1** ：通过文件名删除文件**"></a><strong>选项</strong>  <strong>1</strong>** ：通过文件名删除文件**</h4><p>使用下面的步骤来删除大文件：</p><p>1、 使用下面的命令来删除你找到的第一个大文件：</p><ol><li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch filename&#39; HEAD</li></ol><p>2、 重复步骤 1 找到剩下的每个大文件。</p><p>3、 在你的仓库里更新引用。 filter-branch 会为你原先的引用创建一个 refs&#x2F;original&#x2F; 下的备份。一旦你确信已经删除了正确的文件，你可以运行下面的命令来删除备份文件，同时可以让垃圾回收器回收大的对象：</p><ol><li>git filter-branch –index-filter &#39;git rm –cached –ignore-unmatch filename&#39; HEAD</li></ol><h4 id="选项-2-：直接删除分支"><a href="#选项-2-：直接删除分支" class="headerlink" title="选项  2** ：直接删除分支**"></a><strong>选项</strong>  <strong>2</strong>** ：直接删除分支**</h4><p>如果你所有的大文件都在一个单独的分支上，你可以直接删除这个分支。删除这个分支会自动删除所有的引用。</p><p>1、 删除分支。</p><ol><li>$ git branch -D PROJ567bugfix</li></ol><p>2、 从后面的分支中删除所有的 reflog 引用。</p><h3 id="对不用的数据垃圾回收"><a href="#对不用的数据垃圾回收" class="headerlink" title="对不用的数据垃圾回收"></a><strong>对不用的数据垃圾回收</strong></h3><p>1、 删除从现在到后面的所有 reflog 引用（除非你明确地只在一个分支上操作）。</p><ol><li>$ git reflog expire –expire&#x3D;now –all</li></ol><p>2、 通过运行垃圾回收器和删除旧的对象重新打包仓库。</p><ol><li>$ git gc –prune&#x3D;now</li></ol><p>3、 把你所有的修改推送回仓库。</p><ol><li>$ git push –all –force</li></ol><p>4、 确保你所有的标签也是当前最新的:</p><ol><li>$ git push –tags –force</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;对 Git 仓库的维护通常是为了减少仓库的大小。如果你从另外一个版本控制系统导入了一个仓库，你可能需要在导入后清除掉不必要的文件。本文着重于从一个 Git 仓库中删除大文件，并且包含下列主题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解从 Git 的历史记录中删除文件&lt;/li&gt;
&lt;li&gt;使用 BFG 重写历史记录&lt;/li&gt;
&lt;li&gt;可选，使用 git filter-branch 重写历史记录&lt;/li&gt;
&lt;li&gt;垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请格外小心…..&lt;/p&gt;
&lt;p&gt;本文中的步骤和工具使用的高级技术涉及破坏性操作。确保您在开始之前仔细读过并备份了你的仓库，创建一个备份最容易的方式是使用 &lt;a href=&quot;http://stackoverflow.com/questions/3959924/whats-the-difference-between-git-clone-mirror-and-git-clone-bare&quot;&gt;–mirror&lt;/a&gt; 标志对你的仓库克隆，然后对整个克隆的文件进行打包压缩。有了这个备份，如果在维护期间意外损坏了您的仓库的关键元素，那么你可以通过备份的仓库来恢复。&lt;/p&gt;
&lt;p&gt;请记住，仓库维护对仓库的用户可能会是毁灭性的。与你的团队或者仓库的关注者进行沟通会是一个不错的主意。确保每个人都已经检查了他们的代码，并且同意在仓库维护期间停止开发。&lt;/p&gt;
&lt;h3 id=&quot;理解从-Git-的历史记录中删除文件&quot;&gt;&lt;a href=&quot;#理解从-Git-的历史记录中删除文件&quot; class=&quot;headerlink&quot; title=&quot;理解从  Git  的历史记录中删除文件&quot;&gt;&lt;/a&gt;&lt;strong&gt;理解从&lt;/strong&gt;  &lt;strong&gt;Git&lt;/strong&gt;  &lt;strong&gt;的历史记录中删除文件&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;回想一下，克隆仓库会克隆整个历史记录——包括每个源代码文件的所有版本。如果一个用户提交了一个较大的文件，比如一个 JAR，则随后的每次克隆都会包含这个文件。即使用户最终在后面的某次提交中删除了这个文件，但是这个文件仍然存在于这个仓库的历史记录中。要想完全的从你的仓库中删除这个文件，你必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从你的项目的当前的文件树中删除该文件;&lt;/li&gt;
&lt;li&gt;从仓库的历史记录中删除文件——重写 Git 历史记录，从包含该文件的所有的提交中删除这个文件;&lt;/li&gt;
&lt;li&gt;删除指向旧的提交历史记录的所有 &lt;a href=&quot;http://git-scm.com/docs/git-reflog&quot;&gt;reflog&lt;/a&gt; 历史记录;&lt;/li&gt;
&lt;li&gt;重新整理仓库，使用 &lt;a href=&quot;http://git-scm.com/docs/git-gc&quot;&gt;git gc&lt;/a&gt; 对现在没有使用的数据进行垃圾回收。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>《实现模式》读书小记</title>
    <link href="https://zycslog.github.io/2022/05/01/2022-05-01-iOS-implementation-patterns-tips/"/>
    <id>https://zycslog.github.io/2022/05/01/2022-05-01-iOS-implementation-patterns-tips/</id>
    <published>2022-05-01T04:00:29.953Z</published>
    <updated>2022-06-19T06:17:27.039Z</updated>
    
    <content type="html"><![CDATA[<p>《实现模式》一书作者Kent Beck，软件开发方法学的泰山北斗，是最早研究软件开发模式和重构方法论的先导者之一，是敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人。该书是一本关于如何撰写代码的书。本书中的模式，是基于 Kent 对现存代码的阅读以及他自己的编程习惯而形成的。这些模式来自他早年使用 Smalltalk 模式通过代码与其他开发人员进行沟通的过程。它们的级别相对设计模式较低，与 Larman 提出的 GRASP 模式处于同一粒度。本书中的模式试图为如何撰写大家都能看得懂的代码提供一个清晰明确的视角，并告诉你这些代码如何为人的需要和降低成本的需求提供保障。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p><strong>编程中很多决策是无法复制的，但是当决策的内容越接近技术化，其中的相似性也越多。</strong></p><p>大多数的程序都遵循一组简单的法则：</p><ul><li>更多的时候，程序是在被阅读，而不是被编写；</li><li>在软件编码中，无绝对的“完成”一说，修改程序的投入可能会远远大于最初编写程序的投入；</li><li>程序是由一组基本的语句和控制流概念组合而成的；</li><li>程序的阅读者需要理解程序 — 既从细节上，也从概念上。有时从细节开始，逐渐理解概念，有时从概念开始，逐渐理解细节。</li></ul><p>模式则是基于上述共性的法则而衍生的。而这些法则在编写程序的时候，则悄无声息的转变为编写者的压力（force），影响着每个程序的编写方式，因此模式的本质其实是<strong>压力（force）</strong>的模式。 </p><span id="more"></span><h2 id="一种编程理论"><a href="#一种编程理论" class="headerlink" title="一种编程理论"></a>一种编程理论</h2><p>在现实生活中，哪怕在巨细靡遗的模式列表，也不可能涵盖编程中所遇到的每一种情况，你避免不了（甚至经常）会遇到上穷碧落，也找不到对应现成解决方案的情况。每一种模式都承载着一点点理论，但实际编程中存在一些更加深广的影响力，是孤立的模式所不能概括的。而<code>价值观</code>、<code>原则</code>、<code>模式</code>这三种元素组成的开发方式，相对比较稳定，更能契合大多数的解决方案。</p><p>贯穿于编程中的横切概念：<strong>价值观和原则</strong>。</p><ul><li><strong>价值观：</strong> 是编程过程中的统一支配性主题。<strong>沟通、简单和灵活</strong></li><li><strong>原则：</strong> 在价值观和模式之间搭建桥梁。<strong>编程原则可以演变出解决问题的方案等</strong></li></ul><p><strong>模式表述要什么，价值观提供了动机，原则把动机转化成了实际行动。</strong></p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><p>有三种与价值观血脉相连的价值观，分别是：<code>沟通</code>、<code>简单</code>和<code>灵活</code>。看似有些互相矛盾，但是更多的时候却相得益彰，优秀的程序往往会为未来的扩展留下充分的选择余地，不包含不相关的元素，容易理解，便于阅读。</p><h4 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h4><p>如果说人类的语言是为了加强联系，那么程序的阅读难易程度便是人类与程序世界沟通的桥梁。一份更加干净易读的程序，会更加高效清晰的表达编写者的想法，减轻阅读者的压力。那些把别人当做空气一样的编程方式，使得程序以及编写者慢慢退去颜色，就算耗尽心力搭建的城堡，也会无人问津。</p><p><strong>程序应该读起来想读一本书，需要有情节和韵律，句子间应该有优雅的笑笑跌宕起伏。 — Knuth</strong></p><p>在软件的生命周期内，第一次的部署决定着软件的绝大部分成本，对既有代码的阅读要比编写全新的代码耗时更长。因此注重代码的沟通力可以帮助我们改进思想，一方面投入更多的思考，阅读的同时调用脑细胞思考原有逻辑以及编写者是怎么想的；另一方面则是由于压力的减轻，因为在改变既有代码或者按照合适的方式编写代码的时候，自己知道是在务正业，做的是对的，自我认可感强。</p><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>在代码中，有复杂的，有简单的，而却出复杂性可以让阅读者、使用者以及后来修改代码的人更加理解，避免陷入猜想（猜想是代码修改者最痛恨，也最难受的）。但是在软件开发中，有些复杂性是难以避免的，这些复杂性反映出所要解决的问题的复杂性。但是有些复杂性的产生时因为我们忙着让程序运行起来，这种多余的复杂性降低了软件的价值，正确运行的可能性也降低了，在未来的改动中，改正确的成功率也降低了，回顾自己做过的事情，<strong>把麦子和糠分开，是编程不可或缺的一部分</strong>。</p><p>秉承<strong>在各个层次上都应该要求简单。对代码进行调整，删除所有不提供信息的代码。设计中不出现无关元素。对需求提出质疑，找出最本质的概念。去掉多余的复杂性后，就好像有一束光照亮余下的代码，你就有机会用全新的视角来处理它们。</strong></p><h4 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h4><p>在三种价值观中，灵活是衡量那些低效编码与设计实践的一把标尺。例如常量不应该使用环境变量去定义等等，程序是灵活的，但只有在发生变化的时候才可能真实需要某些设计。</p><p>灵活性的提高可能以复杂性的提高为代价。例如给用户提供一个自定义配置的选择，以提高灵活性，但是因为多了一个配置文件，编程时就要考虑这一点，所以也就变得复杂了。然而简单也可以促进灵活，例如如果可以找到取消配置选项但又不丧失价值的方式，那么程序的后续改动就更加简单了。</p><p>增进软件的沟通效果同样会提高灵活性，能够快速阅读、理解和修改你代码的人越多，它将来发生变化的选择就越多，即软件的灵活度也就提升了。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>原则是另一个层次上的通用思想，比价值观更贴近与编程实际，同时又是模式的基础。原则可以解释模式背后的动机，它是有普遍意义的。</p><p>在对立模式间进行选择时，最好的方式就是用原则来说话，而不是让模式去争宠。</p><p>例如在学习新的编程语言，不必盲目的模仿现有的编程方式，更不用拘泥于其他语言中形成的习惯，可以根据自己对原则的理解快速去学习，即使在新鲜局面下仍能一以贯之。</p><h4 id="局部化影响"><a href="#局部化影响" class="headerlink" title="局部化影响"></a>局部化影响</h4><p><strong>在组织代码结构时，要保证变化只会产生局部化影响。</strong> </p><p>把修改的影响范围缩小到最小，代码就会有极佳的沟通效果，可被逐步理解，而不用一开始鸟瞰全景。</p><p>在实现模式的背后，最主要的动机就是减少变化所引起的代价，所以局部化影响这条原则也是很多模式的形成缘由之一。</p><h4 id="最小化重复"><a href="#最小化重复" class="headerlink" title="最小化重复"></a>最小化重复</h4><p><strong>最小化重复有助于保证局部化影响。</strong>   </p><p>复制代码只是重复的一种形势，并行的类层次结构也是其一，同样破坏了局部化影响。如果出现修改一处概念需要同时修改两个或更多的类层级结构，就代表变化的影响已经扩散了，此时应该及时止损，停止一味地修改，而去重新组织代码，让变化只对局部产生影响。</p><p>重复往往不易被预见到，又是在出现很长时间后才会被察觉，重复不是错误也不是罪过，只是增加了变化的开销，提高了各类成本等。</p><blockquote><p>重复解决：拆分程序为更小的单元 —- 小段语句、小段方法、小型对象和小型包等，从而慢慢消除重复。 大段逻辑很容易与其他大段逻辑出现重复的代码片段，于是就有了模式诞生的可能。</p></blockquote><h4 id="将逻辑和数据捆绑"><a href="#将逻辑和数据捆绑" class="headerlink" title="将逻辑和数据捆绑"></a>将逻辑和数据捆绑</h4><p><strong>局部化影响的必然结果就是将逻辑与数据捆绑。</strong> 把逻辑与逻辑所处理的数据放在一起，如果有可能放在一个方法中，或者放到一个对象中，最次放在一个包下，如果发生了变化，逻辑和数据很可能会同事被改动，如果放在一起，那么修改它们所造成的影响就会只停留在局部。</p><p>但是在一开始编程前，可能意识不到逻辑和数据的依赖，慢慢的演进中，发现此依赖彼，彼依赖其他的问题，此时就要考虑改如果组织代码结构，或者使用辅助类来解决依赖等。</p><blockquote><p>未完待续</p></blockquote><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><h4 id="声明式表达"><a href="#声明式表达" class="headerlink" title="声明式表达"></a>声明式表达</h4><h4 id="变化率"><a href="#变化率" class="headerlink" title="变化率"></a>变化率</h4><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h2 id="改进框架"><a href="#改进框架" class="headerlink" title="改进框架"></a>改进框架</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;《实现模式》一书作者Kent Beck，软件开发方法学的泰山北斗，是最早研究软件开发模式和重构方法论的先导者之一，是敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人。该书是一本关于如何撰写代码的书。本书中的模式，是基于 Kent 对现存代码的阅读以及他自己的编程习惯而形成的。这些模式来自他早年使用 Smalltalk 模式通过代码与其他开发人员进行沟通的过程。它们的级别相对设计模式较低，与 Larman 提出的 GRASP 模式处于同一粒度。本书中的模式试图为如何撰写大家都能看得懂的代码提供一个清晰明确的视角，并告诉你这些代码如何为人的需要和降低成本的需求提供保障。&lt;/p&gt;
&lt;h2 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;编程中很多决策是无法复制的，但是当决策的内容越接近技术化，其中的相似性也越多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数的程序都遵循一组简单的法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更多的时候，程序是在被阅读，而不是被编写；&lt;/li&gt;
&lt;li&gt;在软件编码中，无绝对的“完成”一说，修改程序的投入可能会远远大于最初编写程序的投入；&lt;/li&gt;
&lt;li&gt;程序是由一组基本的语句和控制流概念组合而成的；&lt;/li&gt;
&lt;li&gt;程序的阅读者需要理解程序 — 既从细节上，也从概念上。有时从细节开始，逐渐理解概念，有时从概念开始，逐渐理解细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模式则是基于上述共性的法则而衍生的。而这些法则在编写程序的时候，则悄无声息的转变为编写者的压力（force），影响着每个程序的编写方式，因此模式的本质其实是&lt;strong&gt;压力（force）&lt;/strong&gt;的模式。 &lt;/p&gt;</summary>
    
    
    
    <category term="读书小记" scheme="https://zycslog.github.io/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"/>
    
    
    <category term="读书小记" scheme="https://zycslog.github.io/tags/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2022-04-30</title>
    <link href="https://zycslog.github.io/2022/04/30/2022-04-30-log-md/"/>
    <id>https://zycslog.github.io/2022/04/30/2022-04-30-log-md/</id>
    <published>2022-04-30T12:55:38.000Z</published>
    <updated>2022-04-30T13:16:55.589Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/logs/log1.jpg" alt="图片来自：https://unsplash.com/photos/yR5DR_JlzQ8"></p><p>4月份最后一天了，下定决定要重启这个小博客网站了。来来回回很多次无暇顾及，也可能是自己太懒了吧，总之，庆祝重启了。👏</p><p>五一放假之前，想法很多，但是真正放假后，却觉得还是不要到处跑动了，世事难料，人生无常，此时利用闲暇时间做点一直没有时间去做的事情，也不乏是个美好的假期。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/logs/log1.jpg&quot; alt=&quot;图片来自：https://unsplash.com/photos/yR5DR_JlzQ8&quot;&gt;&lt;/p&gt;
&lt;p&gt;4月份最后一天了，下定决定要重启这个小博客网站了。来来回回很多次无暇顾及，也可能是自己太懒</summary>
      
    
    
    
    <category term="每日随想" scheme="https://zycslog.github.io/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</title>
    <link href="https://zycslog.github.io/2022/04/30/2018-08-28-coreml-vs-mlkit/"/>
    <id>https://zycslog.github.io/2022/04/30/2018-08-28-coreml-vs-mlkit/</id>
    <published>2022-04-30T06:35:13.804Z</published>
    <updated>2022-04-30T07:42:16.470Z</updated>
    
    <content type="html"><![CDATA[<p>截止2018年举行的Apple全球开发者大会（WWDC2018），Apple公司的用于iOS设备的机器学习框架CoreML走过了一年的更新迭代，迎来了首次较大规模的版本更新。在同一时期，Google也发布了其一款面向iOS和安卓设备的跨平台人工智能开发框架。这两类工具的目的均是为了优化大型人工智能模型和数据集开发的负担，使得开发者能够以轻量化的实现方式，增加移动应用程序的智能化等。但是值得思考的一点是，为什么在这个时期，Google和Apple会相继推出自家的移动端机器学习框架呢？</p><span id="more"></span><h2 id="移动端机器学习的重要性"><a href="#移动端机器学习的重要性" class="headerlink" title="移动端机器学习的重要性"></a>移动端机器学习的重要性</h2><p>机器学习无疑是一项非常实用的数据科学技术，其应用的程度正在以指数速度在增长，我们几乎每天都会看到一些发展，但是假如普通大众无法获得机器学习带来的有点，无法改善人类的生活方式，那么发展再好的技术也是不会持续下去的。面对这一情况，结合移动设备的空前普及，在移动设备端使用机器学习是最快速让机器学习应用普惠大众的方式。但是机器学习本身是一项复杂而且专业性很高的任务，普通的开发者可能难以快速的理解和应用，为了使在移动设备上进行机器学习的复杂任务变的简单，并且允许没有机器学习经验的应用开发人员实现机器学习的功能，简便而且符合开发人员编程语言习惯的异动单机器学习开发工具势的必出。</p><h2 id="Core-ML"><a href="#Core-ML" class="headerlink" title="Core ML"></a>Core ML</h2><p><img src="/images/coreml-vs-mlkit/coreml.png"></p><p>Apple在2017年WWDC上发布了Core ML，并于今年更新为Core ML 2.0。Core ML使开发人员能够将机器学习模型集成到iOS或MacOS应用程序中，这是该领域的第一次重大尝试，最初，开发人员真的很喜欢它，原因有很多。 Core ML针对移动硬件性能进行了优化，可最大限度地减少内存占用和功耗。严格地在设备上运行还可确保用户数据安全，即使没有网络连接，应用程序也会运行。</p><p>Core ML最大的有点就是使用起来非常简单，开发人员只需要几行代码就可以集成完整的机器学习模型。自Core ML发布以来，已经有大量的移动应用程序使用了。但是这里要说的是，Core ML并不是万能的，要使用它做什么是有限制的，Core ML智能帮助开发者将训练好的机器学习模型集成到应用程序中，也就意味着在你的应用程序中只能用来进行预测推理，是不可能进行模型的训练学习的。</p><p>虽然如此，Core ML也是被证明对开发人员来说，非常有意义的。Core ML 2.0的发布，更是更进了一步，Apple表示Core ML 2.0的速度快了30%，这要归功于批量处理预测机制，而且它可以将模型的大小缩小到75%。</p><p><img src="/images/coreml-vs-mlkit/coremlsturct.png"></p><h3 id="Create-ML"><a href="#Create-ML" class="headerlink" title="Create ML"></a>Create ML</h3><p><img src="/images/coreml-vs-mlkit/createml-logo.png"></p><p>Apple还在今年的WWDC上还发布了Create ML套件。 Create ML允许开发人员使用Swift和MacOS Playgrounds在Xcode中训练机器学习模型。并且号称没有ML经验的开发人员可以培训模型，而不必依赖其他开发人员。</p><p><img src="/images/coreml-vs-mlkit/createml.png"></p><p>通过形成一个完整的工具包，Create ML增强了Core ML的实用性。目前，Create ML支持三种数据类型：图像，文本和表格数据。有许多训练和测试算法，如随机森林分类器和支持向量机。创建ML还减少了训练的ML模型的大小，并提供了使用Create ML UI训练模型的方法。</p><p><img src="/images/coreml-vs-mlkit/demo.png"></p><h2 id="ML-Kit"><a href="#ML-Kit" class="headerlink" title="ML Kit"></a>ML Kit</h2><p><img src="/images/coreml-vs-mlkit/mlkit.png"></p><p>Firebase在Google I&#x2F;O 2018大会上发布了ML Kit框架。ML Kit使开发人员能够以两种方式在移动应用中使用机器学习：开发人员既可以通过API在云中运行模型推理，也可以在设备上严格运行，就像使用Core ML一样。</p><p>ML Kit提供六种基本的API，可供开发人员使用，已提供的模型有：图像标注、文本识别（OCR）、地标检测、人脸检测、条形码扫描和智能回复。如果这些API不包括您的用例，那么您还可以上传TensorFlow Lite模型，ML Kit负责托管并为您的应用提供模型。</p><p><img src="/images/coreml-vs-mlkit/mlkit-info.png"></p><p>与云版本相比，ML Kit的设备版本提供的精度较低，但同时它为用户数据提供了更高的安全性。 ML Kit提供的基本API涵盖了移动平台上机器学习的所有常规用例，并且使用自定义训练模型的选项使ML Kit成为移动平台的完整机器学习解决方案。开发人员也可以选择将机器学习模型与应用程序分离，并在运行时为它们提供服务，从而减少应用安装规模的大小，确保模型始终保持最新。</p><p><img src="/images/coreml-vs-mlkit/mlkit-dashboard.png"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>Core ML和ML Kit都使开发人员能够在他们的应用程序中利用机器学习的强大功能，从而最终使大众可以使用机器学习的功能。</p><p>与Core ML相比，ML Kit具有一些优势。 ML Kit的主要优点是它支持iOS和Android，并且可以在两个平台上使用相同的API。 ML Kit有六个基本API，易于实现，不需要任何ML专业知识。如果您使用ML Kit提供的基本API，那么由于已经存在预训练模型，使用起来更加的方便。</p><p>ML Kit的另一个优点是它提供了设备上和基于云的API。 ML Kit中的设备上API可以快速工作，即使在没有互联网连接的情况下也能提供结果。基于云的API利用Google Cloud ML平台提供更高的准确性。 ML Kit的缺点是您可能需要根据使用情况将Firebase计划升级为付费计划。</p><p>如果您只对iOS开发感兴趣，那么与Create ML配对的Core ML可能会更有用。 Apple的工具允许您使用更少的代码行在您的应用程序中训练和实现ML模型。使用Create ML的训练模型比使用TensorFlow更容易，但TensorFlow能够提供更高级的训练算法。</p><p>Core ML和ML Kit都是很棒的工具，但每个都有局限性。了解您的确切用例以及您将支持的平台可以帮助您确定哪个选项最佳。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.apple.com/documentation/coreml">Core ML官方文档</a></li><li><a href="https://developers.google.com/ml-kit/">ML Kit官方文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;截止2018年举行的Apple全球开发者大会（WWDC2018），Apple公司的用于iOS设备的机器学习框架CoreML走过了一年的更新迭代，迎来了首次较大规模的版本更新。在同一时期，Google也发布了其一款面向iOS和安卓设备的跨平台人工智能开发框架。这两类工具的目的均是为了优化大型人工智能模型和数据集开发的负担，使得开发者能够以轻量化的实现方式，增加移动应用程序的智能化等。但是值得思考的一点是，为什么在这个时期，Google和Apple会相继推出自家的移动端机器学习框架呢？&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Runtime剖析05 --- 再议iOS内存管理</title>
    <link href="https://zycslog.github.io/2022/04/30/2020-07-13-iOS-memory-manager/"/>
    <id>https://zycslog.github.io/2022/04/30/2020-07-13-iOS-memory-manager/</id>
    <published>2022-04-30T06:35:13.803Z</published>
    <updated>2022-04-30T07:44:48.743Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，iOS中进行内存管理的管理模型是<strong>引用计数</strong>，但是这属于上层应用的范畴，在系统底层，iOS会根据不同的数据结构或者不同的数据类型，进行系统内存的分区，在不同的分区中，管理着自己的内存，另外，iOS的内存管理并不直接管理硬件内存，而是管理着硬件内存之上的一个过渡内存—<strong>虚拟内存</strong>。关于虚拟内存，可参考<a href="https://robinchao.github.io/iOS-VMManage/">iOS虚拟内存管理</a>一文。</p><h2 id="iOS-内存分区"><a href="#iOS-内存分区" class="headerlink" title="iOS 内存分区"></a>iOS 内存分区</h2><p>iOS的内存管理是基于虚拟内存的管理，虚拟内存能够让每一个进程都在逻辑上<code>独占</code>整个设备的内存。iOS又将虚拟内存按照地址由低到高划分为五大区：</p><p><img src="/images/runtime/5/vm-zone"></p><p>虚拟内中，最上方是系统内核区的内存，最下方是系统保留的内存空间，中间则是程序加载的内存空间。内存按照自下而上，由低地址到高地址的拓展，程序加载到内存分为三段：</p><ol><li>未初始化数据(.bss)：存放未进行初始化的静态变量、全局变量</li><li>已初始化数据(.data)：存放已初始化的静态变量、全局变量</li><li>代码段(.text)：存放代码的二进制代码</li></ol><span id="more"></span><p>其他内存段<strong>栈区</strong>和<strong>堆区</strong>，分别用于方法或函数的调用和开发者创建的对象等内存。也就是说，开发者所管理的内存是在堆区，堆地址的分配不连续，但是整体地址是由低到高拓展。栈区的内存管理是由系统自动管理，栈区的地址是连续的，其内存地址是由高向低拓展。在程序运行时，栈区和堆区的大小是变化的，只不过栈区是由系统管理的，堆区是通过引用计数的方式管理对象的，内存的管理也是由开发者管理的。</p><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>在开发的过程中，难免会有些数字需要进行存储，而在iOS中，通常使用NSNumber对象来表示数字，对于绝大多数程序而言，所使用到的数字并不会很大，也用不到上亿的数字，同样对于字符串类型，绝大多数情况下，字符的个数也在8个字节以内。在iPhone 5s之后，iOS的寻址地址扩大到了64位，可以使用63位来表示一个数字，一位用来作为符号位。此时如果存储一个数字，例如**NSNumber *num&#x3D;@10000**，远远达不到63位的内存，这样在内存中则会留下很多无用的空位，造成内存空间的浪费。</p><p>针对上述问题，Apple引入了<strong>Tagged Pointer</strong>，一种特殊的<strong>指针</strong>，在该类型的指针中，存储的已经不是地址，而是<strong>真实的数据和一些附加信息</strong>。</p><p><strong>此部分内容不再详述，具体可查看<a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/">深入理解 Tagged Pointer</a>。</strong></p><p>在Runtime中，针对Tagged Pointer的辨别，首先需要一个标志位，用来判断当前指针是<strong>真正的指针</strong>还是<strong>Tagged Pointer</strong>，Runtime中使用了一个宏定义<strong>define _OBJC_TAG_MASK (1UL&lt;&lt;63)<strong>，表示如果64位数据中，最高位是1的话，则表明当前是一个</strong>Tagged Pointer</strong>类型。在Runtime中，不仅仅NSNumber有Tagged Pointer类型，还有NSString、NSIndexPath、NSDate等，具体如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 60-bit payloads</span></span><br><span class="line">    OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">    OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">    OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">    OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">    OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">    OBJC_TAG_NSDate            = <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 60-bit reserved</span></span><br><span class="line">    OBJC_TAG_RESERVED_7        = <span class="number">7</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 52-bit payloads</span></span><br><span class="line">    OBJC_TAG_Photos_1          = <span class="number">8</span>,</span><br><span class="line">    OBJC_TAG_Photos_2          = <span class="number">9</span>,</span><br><span class="line">    OBJC_TAG_Photos_3          = <span class="number">10</span>,</span><br><span class="line">    OBJC_TAG_Photos_4          = <span class="number">11</span>,</span><br><span class="line">    OBJC_TAG_XPC_1             = <span class="number">12</span>,</span><br><span class="line">    OBJC_TAG_XPC_2             = <span class="number">13</span>,</span><br><span class="line">    OBJC_TAG_XPC_3             = <span class="number">14</span>,</span><br><span class="line">    OBJC_TAG_XPC_4             = <span class="number">15</span>,</span><br><span class="line">    OBJC_TAG_NSColor           = <span class="number">16</span>,</span><br><span class="line">    OBJC_TAG_UIColor           = <span class="number">17</span>,</span><br><span class="line">    OBJC_TAG_CGColor           = <span class="number">18</span>,</span><br><span class="line">    OBJC_TAG_NSIndexSet        = <span class="number">19</span>,</span><br><span class="line"></span><br><span class="line">    OBJC_TAG_First60BitPayload = <span class="number">0</span>, </span><br><span class="line">    OBJC_TAG_Last60BitPayload  = <span class="number">6</span>, </span><br><span class="line">    OBJC_TAG_First52BitPayload = <span class="number">8</span>, </span><br><span class="line">    OBJC_TAG_Last52BitPayload  = <span class="number">263</span>, </span><br><span class="line"></span><br><span class="line">    OBJC_TAG_RESERVED_264      = <span class="number">264</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>0xa</strong>转换为二进制，得到<strong>1010</strong>，其中高位<strong>1xxx</strong>表明是一个<strong>Tagged Pointer</strong>,而剩下的3位<strong>010</strong>,表示是一个<strong>NSString</strong>类型，即<strong>010</strong>转换为十进制为<strong>2</strong>，对应上述定义中的<strong>OBJC_TAG_NSString &#x3D; 2</strong>。</p><p>对于字符串来说，只有小字符串会被存储为<strong>Tagged Pointer</strong>类型，那么到底要多小呢？能够想到的是，字符串在进行春初的时候，并不是存储着字符串本身，而是字符串中每个字符的ASCII码，在字符串长度增加到8个字符之前，字符串是按照小对象的方式存储的，更大的字符串则是使用传统的指针方式存储的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *test_small = <span class="string">@&quot;a&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, test_small];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSNumber</span> *number = @<span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *number_large = @<span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/runtime/5/tagged-pointer.jpg"></p><p><strong>isa</strong></p><p>从上述示例的结果中可以看到，当一个对象被存储未<strong>Tagged Pointer</strong>类型后，该对象的<strong>isa</strong>指针是<strong>0x0</strong>，指向空的，也就是说<strong>Tagged Pointer</strong>类型的对象，是没有isa属性的。在Runtime中，获取一个对象的isa指针定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line"><span class="title function_">objc_object::getIsa</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!isTaggedPointer())) <span class="keyword">return</span> ISA();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;</span><br><span class="line">    <span class="type">uintptr_t</span> slot, ptr = (<span class="type">uintptr_t</span>)this;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    slot = (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span><br><span class="line">    cls = objc_tag_classes[slot];</span><br><span class="line">    <span class="keyword">if</span> (slowpath(cls == (Class)&amp;OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) &#123;</span><br><span class="line">        slot = (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span><br><span class="line">        cls = objc_tag_ext_classes[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="type">const</span> <span class="type">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取一个对象的isa指针式，如果是tagged pointer类型，则会取出高4位的内容，进行对象类型的确定。</p><h2 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h2><p><strong>NONPOINTER_ISA</strong>是iOS中另一种内存管理的方式，即对象的isa指针，该指针用来表明对象属性和类类型。Apple同样优化了该中方式的内存管理方式，在isa中，不仅表明了属性属于那个类，还附加了引用计数<strong>extra_rc</strong>、是否weak引用<strong>weakly_referenced</strong>、是否有附加属性<strong>has_assoc</strong>等附加信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>isa指针</strong>其本质是<strong>isa_t 联合类型</strong>。联合类型的作用在于用更少的空间，表示更多可能的类型，但是类型之间是不能共存的。</p><p>在<strong>isa_t</strong>的定义中，有两个重要的成员变量<strong>cls</strong>和<strong>struct</strong>，并且<strong>struct</strong>部分是在定义了<strong>ISA_BITFIELD</strong>之后才会使用的，也就是说，只有符合ISA_BITFIELD的时候，才会使用<strong>struct</strong>结构体，即采用了优化的isa策略时，<strong>isa_t</strong>类型并不等同于<strong>Class</strong>，而是一个<strong>struct</strong>结构。这个结构共占用了64个字节，从低位的<strong>nonpointer</strong>到高位的<strong>extra_rc</strong>，定义中中**:**表示该成员占用几个字节。</p><p>各成员的含义如下表所示：</p><table><thead><tr><th>成员变量</th><th>占用位(单位：bit)</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>nonpointer</td><td>1</td><td>标志位。1 代表开启了isa优化，0 代表未开启isa优化</td><td>可根据此位判断对象是否启用了isa优化。</td></tr><tr><td>has_assoc</td><td>1</td><td>标志位。标识该对象是否有关联对象。</td><td>对象没有关联对象时，其内存释放更快。</td></tr><tr><td>has_cxx_dtor</td><td>1</td><td>标志位。标识对象是否有C++或ARC析构函数。</td><td>无析构函数时，内存释放更快。</td></tr><tr><td>shiftcls</td><td>33</td><td>类指针的非零位。</td><td></td></tr><tr><td>magic</td><td>6</td><td>“魔法”位。固定值0x1a，用于调试时区分对象是否已经初始化。</td><td></td></tr><tr><td>weakly_referenced</td><td>1</td><td>标志位。标识对象是否被别的对象弱引用。</td><td>没有弱引用的对象内存释放更快。</td></tr><tr><td>deallocating</td><td>1</td><td>标志位。标识对象是否正在被释放。</td><td></td></tr><tr><td>has_sidetable_rc</td><td>1</td><td>标志位。标识对象当前的引用计数是否过大，如果过大则需要使用sidetable存储引用计数。</td><td></td></tr><tr><td>extra_rc</td><td>19</td><td>记录当前对象的引用计数。</td><td></td></tr></tbody></table><p>其中和对象引用计数相关的有<strong>has_sidetable_rc</strong>和<strong>extra_rc</strong>，如上所述，当对象引用计数过大时，<strong>has_sidetable_rc</strong>会被设定为1，并启用sidetable来存储引用计数。</p><h3 id="SideTable"><a href="#SideTable" class="headerlink" title="SideTable"></a>SideTable</h3><p><strong>SideTable</strong>是一个全局的引用计数表，其中存储了项目中所有对象的引用计数。在弄清楚<strong>SideTable</strong>和<strong>extra_rc</strong>之间的关系之前，先了解一下Runtime是如何添加对象的引用计数的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line"><span class="title function_">objc_object::rootRetain</span><span class="params">(<span class="type">bool</span> tryRetain, <span class="type">bool</span> handleOverflow)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果是Tagged Pointer类型，直接返回this。因为TaggedPointer类型不使用引用计数管理内存</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)this;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 标记 extra_rc 是否溢出，默认false</span></span><br><span class="line">    <span class="type">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时变量，用于isa_t的存储方式切换</span></span><br><span class="line">    <span class="type">isa_t</span> oldisa;</span><br><span class="line">    <span class="type">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 先取出isa_t</span></span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// 如果没有启用isa优化，则返回对应的sidetable记录</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (rawISA()-&gt;isMetaClass()) <span class="keyword">return</span> (id)this;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (id)this : nil;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="comment">// 如果对象正在析构，则返回nil</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否溢出标记</span></span><br><span class="line">        <span class="type">uintptr_t</span> carry;</span><br><span class="line">        <span class="comment">// 调用 addc 函数 对 extra_rc 执行 ++ 操作，返回 carry</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">        <span class="comment">// 如果有溢出，则表明extra_rc已经溢出。</span></span><br><span class="line">        <span class="comment">// 1. 先将 extra_rc 减半</span></span><br><span class="line">        <span class="comment">// 2. 然后将另一半转存至sidetable</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="comment">// 如果本次不处理溢出，则递归调用一次，并设置handleOverflow为true，下次处理</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain); <span class="comment">// return rootRetain(tryRetain, true);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="comment">// 进行具体的溢出处理：</span></span><br><span class="line">            <span class="comment">// 1. 使用 RC_HALF 宏定义，对 extra_rc 进行减半操作</span></span><br><span class="line">            <span class="comment">// 2. 设置has_sidetable_rc标记为true</span></span><br><span class="line">            <span class="comment">// 3. transcribeToSideTable 标记为true</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transcribeToSideTable为true时，将extra_rc减半的一部分，转存到sidetable中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Runtime中，通过<strong>SideTable</strong>来管理对象的引用计数和弱引用。<strong>SideTable</strong>中会包含三部分内容：自旋锁、引用计数表和弱引用表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> slock; <span class="comment">// 自旋锁</span></span><br><span class="line">    RefcountMap refcnts; <span class="comment">// 引用计数表</span></span><br><span class="line">    <span class="type">weak_table_t</span> weak_table; <span class="comment">// 弱引用表</span></span><br><span class="line"></span><br><span class="line">    SideTable() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SideTable() &#123;</span><br><span class="line">        _objc_fatal(<span class="string">&quot;Do not delete SideTable.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; slock.lock(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; slock.unlock(); &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">forceReset</span><span class="params">()</span> &#123; slock.forceReset(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></span><br><span class="line"></span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span>;</span><br><span class="line">    template&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="title function_">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>SideTable</strong>本质上也是一个结构体，多个<strong>SideTable</strong>会构成一个集合，一张<strong>SideTable</strong>会管理多个对象，因此通常被称为<strong>SideTables</strong>，在系统中是全局唯一的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> StripedMap&lt;SideTable&gt;&amp; <span class="title function_">SideTables</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SideTablesMap.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SideTables</strong>被包裹在<strong>StripedMap</strong>类中，每个对象在进行引用计数管理时，都需要通过<strong>StripedMap</strong>的哈希算法，找到对应的<strong>SideTable</strong>表，之后再对引用计数进行管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StripedMap 哈希算法</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">indexForPointer</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> addr = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<strong>SideTable</strong>的定义中得知，引用计数表<strong>refcnts</strong>的数据类型为<strong>RefcountMap</strong>，而<strong>RefcountMap</strong>实际上是一个<strong>模板类 DenseMap</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="type">size_t</span>,RefcountMapValuePurgeable&gt; RefcountMap;</span><br></pre></td></tr></table></figure><p>简单理解<strong>DenseMap</strong>就是一个<strong>map</strong>，其中<strong>key</strong>是<strong>DisguisedPtr<objc_object><strong>，</strong>value</strong>是对应的引用计数，另外在该<strong>map</strong>中会检测引用计数，当引用计数为0时，会自动将对象的引用计数数据清空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shrink_and_clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> OldNumEntries = NumEntries;</span><br><span class="line">    this-&gt;destroyAll();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce the number of buckets.</span></span><br><span class="line">    <span class="type">unsigned</span> NewNumBuckets = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (OldNumEntries)</span><br><span class="line">      NewNumBuckets = <span class="built_in">std</span>::max(MIN_BUCKETS, <span class="number">1</span> &lt;&lt; (Log2_32_Ceil(OldNumEntries) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (NewNumBuckets == NumBuckets) &#123;</span><br><span class="line">      this-&gt;BaseT::initEmpty();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator <span class="title function_">delete</span><span class="params">(Buckets)</span>;</span><br><span class="line">    init(NewNumBuckets);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在Objective-C中，当要获取一个对象的引用计数时，Runtime会分为三种情况进行获取，分别对应Tagged Pointer、优化的isa和未优化的isa。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uintptr_t</span> </span><br><span class="line"><span class="title function_">objc_object::rootRetainCount</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果是Tagged Pointer，则直接返回this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="type">uintptr_t</span>)this;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    <span class="type">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="comment">// 如果是优化的isa_t</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="comment">// 如果使用了sidetable，则从sidetable中获取引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">        <span class="comment">// 总的引用计数 = rc部分 + sidetable部分</span></span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="comment">// 如果是未优化的isa_t，则返回sidetable中的数据</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取优化的isa_t类型对象的引用计数时，注意是要取两部分的记录，然后进行汇总，对应添加引用计数的步骤。在取SideTable部分记录的引用计数时，需要注意在记录中并不是直接获取，而是要根据存储的情况进行获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> </span><br><span class="line"><span class="title function_">objc_object::sidetable_getExtraRC_nolock</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line">    <span class="comment">// 找到对应的引用计数表</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    <span class="comment">// 如果表为空，则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 否则先进行移位操作，然后返回结果</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#define SIDE_TABLE_RC_SHIFT 2</strong>宏定义直接使用在引用计数的获取流程中，是因为在引用计数表的低2位的位置存储的并不是引用计数，而是记录当前对象是否有弱引用，以及是否正在deallocing。</p><h3 id="弱引用表"><a href="#弱引用表" class="headerlink" title="弱引用表"></a>弱引用表</h3><p>在<strong>SideTable</strong>的定义中，还有一个非常重要的属性<strong>weak_table_t weak_table</strong>，前文已经了解，<strong>weak_table</strong>是当前对象的弱引用表，存储着弱引用相关的信息，在Runtime中，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries; <span class="comment">// hash数组，存储弱引用对象的信息</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries; <span class="comment">// hash数组中元素个数</span></span><br><span class="line">    <span class="type">uintptr_t</span> mask; <span class="comment">// hash数组长度-1，参与hash计算 </span></span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement; <span class="comment">// 发生hash冲突的最大次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>weak_table_t</strong>中相对重要的是<strong>weak_entry_t</strong>类型的数组部分，可通过hash算法找到对应的对象在数组中的index，另外，<strong>weak_table_t</strong>具有动态扩容的特性，而<strong>sidetables</strong>的大小是固定64个。</p><p><strong>weak_entries</strong>本质上是一个hash数组，数组中存储着<strong>weak_entry_t</strong>类型的元素。<strong>weak_entry_t</strong>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEAK_INLINE_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// out_of_line_ness field overlaps with the low two bits of inline_referrers[1].</span></span><br><span class="line"><span class="comment">// inline_referrers[1] is a DisguisedPtr of a pointer-aligned address.</span></span><br><span class="line"><span class="comment">// The low two bits of a pointer-aligned DisguisedPtr will always be 0b00</span></span><br><span class="line"><span class="comment">// (disguised nil or 0x80..00) or 0b11 (any other address).</span></span><br><span class="line"><span class="comment">// Therefore out_of_line_ness == 0b10 is used to mark the out-of-line state.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent; <span class="comment">// 弱引用对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 联合体，引用该对象的对象列表。</span></span><br><span class="line">    <span class="comment">// 引用个数小于4，使用inline_referrers数组</span></span><br><span class="line">    <span class="comment">// 引用个数大于4，使用weak_referrer_t *referrers动态数组</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">weak_referrer_t</span> *referrers; <span class="comment">// 弱引用该对象的对象数组，动态</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>; <span class="comment">// 是否使用动态数组的标记</span></span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : PTR_MINUS_2; <span class="comment">// 动态数组中的元素个数</span></span><br><span class="line">            <span class="type">uintptr_t</span>        mask; <span class="comment">// 参与hash计算，大小为数组大小-1，最终确定数组index</span></span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement; <span class="comment">// 最大hash冲突次数</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">out_of_line</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span>&amp; operator=(<span class="type">const</span> <span class="type">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(this, &amp;other, <span class="keyword">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : referent(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在查找弱引用对象的时候，始终使用的是hash定位的方式，在runtime中，弱引用所使用的hash定位算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">weak_entry_t</span> *</span><br><span class="line"><span class="title function_">weak_entry_for_referent</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, objc_object *referent)</span></span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取弱引用表中所有弱引用对象</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="comment">// 确定hash值对应数组的开始索引，内部调用 ptr_hash 函数</span></span><br><span class="line">    <span class="comment">// 1. 获取到对象的hash指针</span></span><br><span class="line">    <span class="comment">// 2. 与如引用表的 mask 进行 位与 运算</span></span><br><span class="line">    <span class="comment">// 这样的目的是为了减小数值，便于计算。1000...000类型转变为 011...1 的形式</span></span><br><span class="line">    <span class="type">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历对象数组</span></span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">    <span class="comment">// 加入位与运算，防止数组下标越界</span></span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="comment">// 寻找一轮后，没有找到对应元素，触发 bad_weak_table</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        <span class="comment">// hash冲突增加</span></span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="comment">// 如果hash冲突大于最大可能冲突次数，说明目标元素不在数组中，返回nil</span></span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">ptr_hash</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    key ^= key &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    key *= <span class="number">0x8a970be7488fda55</span>;</span><br><span class="line">    key ^= __builtin_bswap64(key);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行hash定位的时候，有一个巧妙的操作语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br></pre></td></tr></table></figure><p>该语句会在当前位置的下一个相邻位置进行查找，同时当查找到最后一个位置时，会自动从数组的第一个位置开始查找，也就是巧妙的实现了数组的轮转查找，也保证了数组下表不会越界。</p><p>由于弱引用表的大小不是固定的，而是随着元素的插入和删除进行动态调整大小的，因此关键在于学习Runtime是如何对其进行动态大小调整的。</p><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>扩容主要发生在表格容量满的时候，而进行扩容前，而在Runtime中会进行提前扩容，需要先判断存储表是否需要进行扩容，判断方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE(entry) (entry-&gt;mask ? entry-&gt;mask + 1 : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grow the given zone&#x27;s table of weak references if it is full.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_grow_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow if at least 3/4 full.</span></span><br><span class="line">    <span class="keyword">if</span> (weak_table-&gt;num_entries &gt;= old_size * <span class="number">3</span> / <span class="number">4</span>) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size ? old_size*<span class="number">2</span> : <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断的依据在于 <strong>weak_table-&gt;num_entries &gt;&#x3D; old_size * 3 &#x2F; 4</strong>，即当当前存储表的容量仅剩下1&#x2F;4的时候，会进行扩容操作。具体的扩容操作是在<strong>weak_resize</strong>中进行的，也就是后文所说的<strong>容量重置</strong>部分。</p><p>进行扩容后，存储表的容量会比原有容量大一倍，这么做的目的在于，放置后序频繁的进行内存申请，以及既然这次要扩容，后序扩容的几率会更大，不如一次扩多点。</p><h4 id="动态收缩"><a href="#动态收缩" class="headerlink" title="动态收缩"></a>动态收缩</h4><p>存储表容量的压缩通常发生在删除了其中一些元素之后，此时系统会调用<strong>weak_compact_maybe</strong>判断当前存储表是否需要收缩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink the table if it is mostly empty.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_compact_maybe</span><span class="params">(<span class="type">weak_table_t</span> *weak_table)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shrink if larger than 1024 buckets and at most 1/16 full.</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= <span class="number">1024</span>  &amp;&amp; old_size / <span class="number">16</span> &gt;= weak_table-&gt;num_entries) &#123;</span><br><span class="line">        weak_resize(weak_table, old_size / <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// leaves new table no more than 1/2 full</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时判断的依据是<strong>old_size &gt;&#x3D; 1024  &amp;&amp; old_size &#x2F; 16 &gt;&#x3D; weak_table-&gt;num_entries</strong>，即容量已经超过1024字节以及存储表容量最多只使用了1&#x2F;16的时候，会进行容量收缩处理，而收缩是按照现有容量的八倍大小进行收缩的。</p><h4 id="容量重置"><a href="#容量重置" class="headerlink" title="容量重置"></a>容量重置</h4><p>无论是扩容，还是收缩，都调用了<strong>weak_resize</strong>进行容量的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_resize</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">size_t</span> new_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> old_size = TABLE_SIZE(weak_table);</span><br><span class="line">    <span class="comment">// 取出原始数据</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *old_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    <span class="comment">// 给新的容量申请内存</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *new_entries = (<span class="type">weak_entry_t</span> *)</span><br><span class="line">        <span class="built_in">calloc</span>(new_size, <span class="keyword">sizeof</span>(<span class="type">weak_entry_t</span>));</span><br><span class="line">    <span class="comment">// 重置weak_table容量相关属性</span></span><br><span class="line">    weak_table-&gt;mask = new_size - <span class="number">1</span>; <span class="comment">// 数组大小-1</span></span><br><span class="line">    weak_table-&gt;weak_entries = new_entries; <span class="comment">// 元素</span></span><br><span class="line">    weak_table-&gt;max_hash_displacement = <span class="number">0</span>; <span class="comment">// 最大hash冲突重置</span></span><br><span class="line">    weak_table-&gt;num_entries = <span class="number">0</span>;  <span class="comment">// restored by weak_entry_insert below</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (old_entries) &#123;</span><br><span class="line">        <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">        <span class="type">weak_entry_t</span> *end = old_entries + old_size;</span><br><span class="line">        <span class="comment">// 遍历元素数组，将元素重新插入到新的存储表中</span></span><br><span class="line">        <span class="keyword">for</span> (entry = old_entries; entry &lt; end; entry++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;referent) &#123;</span><br><span class="line">                weak_entry_insert(weak_table, entry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后释放掉老的内存空间</span></span><br><span class="line">        <span class="built_in">free</span>(old_entries);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的插入操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">weak_entry_insert</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *new_entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">    ASSERT(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != nil) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">        weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，弱引用存储表的容量在扩容的时候，并不是在原有存储表上进行直接扩容的，而是根据新的大小开辟了一块新的内存空间，同时将老的数据完整迁移到新的内存空间上，然后释放掉老的存储表。</p><h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h2><p>在iOS中，第三种内存管理的方式是<strong>autoreleasepool</strong>，在ARC中，通常直接使用**@autoreleasepool{}**的方式使用，其中包裹的对象的内存管理工作就交给了自动释放池进行管理。</p><p>关于<strong>autoreleasepool</strong>这里不再详述，具体可查看开源项目<a href="https://github.com/opensource-apple/objc4">objc</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们都知道，iOS中进行内存管理的管理模型是&lt;strong&gt;引用计数&lt;/strong&gt;，但是这属于上层应用的范畴，在系统底层，iOS会根据不同的数据结构或者不同的数据类型，进行系统内存的分区，在不同的分区中，管理着自己的内存，另外，iOS的内存管理并不直接管理硬件内存，而是管理着硬件内存之上的一个过渡内存—&lt;strong&gt;虚拟内存&lt;/strong&gt;。关于虚拟内存，可参考&lt;a href=&quot;https://robinchao.github.io/iOS-VMManage/&quot;&gt;iOS虚拟内存管理&lt;/a&gt;一文。&lt;/p&gt;
&lt;h2 id=&quot;iOS-内存分区&quot;&gt;&lt;a href=&quot;#iOS-内存分区&quot; class=&quot;headerlink&quot; title=&quot;iOS 内存分区&quot;&gt;&lt;/a&gt;iOS 内存分区&lt;/h2&gt;&lt;p&gt;iOS的内存管理是基于虚拟内存的管理，虚拟内存能够让每一个进程都在逻辑上&lt;code&gt;独占&lt;/code&gt;整个设备的内存。iOS又将虚拟内存按照地址由低到高划分为五大区：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/runtime/5/vm-zone&quot;&gt;&lt;/p&gt;
&lt;p&gt;虚拟内中，最上方是系统内核区的内存，最下方是系统保留的内存空间，中间则是程序加载的内存空间。内存按照自下而上，由低地址到高地址的拓展，程序加载到内存分为三段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;未初始化数据(.bss)：存放未进行初始化的静态变量、全局变量&lt;/li&gt;
&lt;li&gt;已初始化数据(.data)：存放已初始化的静态变量、全局变量&lt;/li&gt;
&lt;li&gt;代码段(.text)：存放代码的二进制代码&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Runtime" scheme="https://zycslog.github.io/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>机器学习与移动应用开发的未来</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-09-07-machine-learning-feature/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-09-07-machine-learning-feature/</id>
    <published>2022-04-30T06:35:13.802Z</published>
    <updated>2022-04-30T07:45:41.449Z</updated>
    
    <content type="html"><![CDATA[<p>移动开发者可以从设备上的机器学习（on-device machine learning）所能提供的革命性变化中获益匪浅。这是因为该技术能够支持移动应用程序，即允许通过利用强大的功能来实现更流畅的用户体验，例如提供准确的基于地理位置的建议或即时检测植物疾病等。</p><p>移动机器学习（mobile machine learning）的这种快速发展已经成为是对经典机器学习（classical machine learning）所面临的许多常见问题的回应。事实上，这些问题即将发生。未来的移动应用将需要更快的处理速度和更低的延迟。</p><p>你可能会疑问为什么人工智能优先的移动应用程序（AI-first mobile applications）不能简单地在云端中进行推理运算。首先，云技术依赖于中央节点（设想一个拥有大量存储空间和计算能力的大型数据中心）。而这种集中式的方式无法满足创建流畅的、基于机器学习驱动的移动用户体验所需的处理速度。因为数据必须在这个集中式数据中心进行处理，然后将结果发送回设备。这需要花费时间和金钱，并且很难保证数据的隐私。</p><p>在概述了移动机器学习的这些核心优势之后，下面让我们更详细地探讨为什么作为移动应用开发者，你会希望继续关注即将到来的设备机器学习革命。</p><span id="more"></span><h2 id="降低延迟"><a href="#降低延迟" class="headerlink" title="降低延迟"></a>降低延迟</h2><p><img src="/images/MLFeature/speed.jpeg"></p><p>移动应用开发者都知道，高延迟将会是导致一个 App 失败的重要原因，无论其功能有多强大或者品牌声誉如何。Android 设备的许多视频类应用在过去曾存在延迟问题，导致观看时音频和视频不同步的体验。同样，一个高延迟的社交应用也会导致非常令人沮丧的糟糕用户体验。</p><p>正是由于这些延迟问题，在移动设备上运用机器学习变得越来越重要。考虑到社交媒体图像过滤器和基于位置的用餐建议 —— 这些应用程序功能需要低延迟才能提供最高级别的结果。</p><p>如前所述，云处理的时间可能会很慢，最终，开发者需要达到零延迟才能使机器学习功能在其移动应用中正常运行。设备上的机器学习通过其数据处理能力为接近零延迟铺平了道路。</p><p><img src="/images/MLFeature/mobile.gif"></p><blockquote><p>图为实时低延迟的示例：Heartbeat 应用中实时视频的样式转换结果。</p></blockquote><p>智能手机制造商和大型科技公司正在追赶这一目标。Apple 在这方面一直处于领先地位，它正在使用其仿生系统（Bionic system）开发更先进的智能手机芯片，该系统具有一个完整的神经引擎，可帮助神经网络直接在设备上运行，并具有令人难以置信的处理速度。</p><p>Apple 还在继续迭代更新 Core ML，这是一个面向移动开发者的机器学习平台；TensorFlow Lite 增加了对 GPU 的支持；Google 继续为其自己的机器学习平台 —— ML Kit 增加预加载特性。这些技术是移动开发者用于开发能够以闪电般的速度处理数据、消除延迟和减少错误的应用程序的技术之一。</p><p>这种精确性和无缝衔接的用户体验的结合是移动开发者在创建由 ML 驱动的应用程序时需要考虑的首要因素。为了保证这一点，开发者需要拥抱并接受设备上的机器学习。</p><h2 id="增强安全性和隐私"><a href="#增强安全性和隐私" class="headerlink" title="增强安全性和隐私"></a>增强安全性和隐私</h2><p><img src="/images/MLFeature/security.jpeg"></p><p>边缘计算（edge computing）的另一个不可低估的巨大优势是它如何提高其用户的安全性和隐私性。确保应用程序数据的受保护和隐私是移动开发者工作中不可或缺的一部分，特别是考虑到需要满足<strong>通用数据保护法规</strong>（General Data Protection Regulations，GDPR），这些新的隐私相关法律肯定将会影响移动开发实践。</p><p>由于数据不需要发送到服务器或者云端进行处理，因此网络犯罪分子很少能有机会利用数据传输中的任何漏洞，从而保证了数据的不受侵犯。这使移动开发者可以更轻松地满足 GDPR 中关于数据安全的规定。</p><p>设备上的机器学习解决方案也提供了去中心化，这与区块链的做法非常相似。换句话说，与针对集中式服务器的相同攻击相比，黑客更难通过 DDOS 攻击摧毁隐藏设备的网络连接。这项技术也可被证明对无人机和未来的执法工作有用。</p><p>上述 Apple 智能手机芯片也有助于提高用户安全性和隐私性，例如这些芯片是 Face ID 的支柱。iPhone 的这一功能依赖于设备上的神经网络，它可以收集用户脸部所有不同维度的数据，作为更准确，更安全的识别方法。</p><ul><li>Apple 介绍 iPhone X 上的 Face ID 视频链接：<a href="https://www.youtube.com/watch?v=z-t1h0Y8vuM">https://www.youtube.com/watch?v=z-t1h0Y8vuM</a></li></ul><p>这类以及未来的人工智能硬件将为用户提供更安全的智能手机体验铺平道路，并为移动开发者提供额外的加密层，以保护用户的数据。</p><h2 id="无需网络连接"><a href="#无需网络连接" class="headerlink" title="无需网络连接"></a>无需网络连接</h2><p><img src="/images/MLFeature/internet.jpeg"></p><p>除了延迟问题之外，将数据发送到云端以进行推理计算还需要有效的 Internet 连接。通常，在世界上比较发达的地区，这种方式可以很容易实现。但是，在网络连接不发达的地区呢？通过设备上的机器学习，神经网络可以直接在手机上运行。这允许开发者在任何给定时间和在任何设备上使用该技术，而不用管网络连接性如何。此外，它可以使机器学习特性大众化，因为用户不需要 Internet 连接到他们的应用程序。</p><p>医疗保健是一个可以从设备上的机器学习中受益匪浅的行业，因为应用开发者能够创建医疗工具来检查生命体征，甚至可以进行远程机器人手术，而无需任何 Internet 连接。该技术还可以帮助那些需要在没有网络连接的地方访问课堂材料的学生，例如在公共交通隧道中。</p><p>设备上的机器学习最终将为移动开发者提供创建应用程序的工具，这些应用可以使世界各地的用户受益，无论他们的网络连接情况如何。即使没有互联网连接，但未来新的智能手机功能将非常强大，用户在离线环境中使用应用程序时也不会受到延迟问题的困扰。</p><h2 id="减少业务开销成本"><a href="#减少业务开销成本" class="headerlink" title="减少业务开销成本"></a>减少业务开销成本</h2><p><img src="/images/MLFeature/cost.jpeg"></p><p>设备上的机器学习还可以为您节省一笔支出，因为您不必为实现或维护这些解决方案而向外部供应商付费。如前所述，您不需要云计算或互联网来提供此类解决方案。</p><p>GPU 和人工智能专用芯片将是您可以购买的最昂贵的云服务。在设备上运行模型意味着您不需要为这些集群付费，这要归功于如今智能手机中日益复杂的神经处理单元（Neural Processing Units，NPU）。</p><p>避免移动端和云端之间繁重的数据处理噩梦，对于选择设备上的机器学习解决方案的企业来说是一个巨大的成本节省。通过这种设备上的推断计算（on-device inference）也可以降低带宽需求，最终节省大量的成本。</p><p>移动开发者还可以大大节省开发过程的开支，因为他们不必构建和维护额外的云基础设施。相反，他们可以通过一个较小的工程团队实现更多目标，从而使他们能够更有效地扩展他们的开发团队。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>毫无疑问，云计算在 2010 年代一直是数据和计算的福音，但科技行业正以指数级的速度发展，设备上的机器学习（on-device machine learning）可能很快将成为移动应用和物联网开发的标准。</p><p>由于其更低的延迟，增强的安全性，离线功能和降低成本，毫无疑问，该行业的所有主要参与者都在大力关注这项技术，它将定义移动开发者如何推进应用程序的创建。</p><p>如果你有兴趣了解移动机器学习的更多信息，它的工作原理，以及为什么它在整个移动开发领域中如此重要，这里有一些额外的资源可以帮助您入门：</p><ul><li><p>Matthijs Holleman 的博客《Machine, Think!》在 Apple 的移动机器学习框架 Core ML 方面有很多不错的教程和其他相关内容：<br><a href="https://machinethink.net/blog/">https://machinethink.net/blog/</a></p></li><li><p>边缘人工智能（Artificial Intelligence at the Edge）：<br><a href="https://youtu.be/6R5pjcqBq6Y">https://youtu.be/6R5pjcqBq6Y</a></p></li><li><p>此外，Heartbeat 在移动开发和机器学习的交叉领域也拥有越来越多的资源库：<br><a href="http://heartbeat.fritz.ai/">http://heartbeat.fritz.ai/</a></p></li></ul><blockquote><p>本文转载自：<a href="https://kangzubin.com/mobile-machine-learning/">KANGZUBIN</a></p><p>原文作者: Karl Utermohlen</p><p>原文: <a href="https://heartbeat.fritz.ai/machine-learning-and-the-future-of-mobile-app-development-13dd2aeda533">Machine Learning and the Future of Mobile App Development</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;移动开发者可以从设备上的机器学习（on-device machine learning）所能提供的革命性变化中获益匪浅。这是因为该技术能够支持移动应用程序，即允许通过利用强大的功能来实现更流畅的用户体验，例如提供准确的基于地理位置的建议或即时检测植物疾病等。&lt;/p&gt;
&lt;p&gt;移动机器学习（mobile machine learning）的这种快速发展已经成为是对经典机器学习（classical machine learning）所面临的许多常见问题的回应。事实上，这些问题即将发生。未来的移动应用将需要更快的处理速度和更低的延迟。&lt;/p&gt;
&lt;p&gt;你可能会疑问为什么人工智能优先的移动应用程序（AI-first mobile applications）不能简单地在云端中进行推理运算。首先，云技术依赖于中央节点（设想一个拥有大量存储空间和计算能力的大型数据中心）。而这种集中式的方式无法满足创建流畅的、基于机器学习驱动的移动用户体验所需的处理速度。因为数据必须在这个集中式数据中心进行处理，然后将结果发送回设备。这需要花费时间和金钱，并且很难保证数据的隐私。&lt;/p&gt;
&lt;p&gt;在概述了移动机器学习的这些核心优势之后，下面让我们更详细地探讨为什么作为移动应用开发者，你会希望继续关注即将到来的设备机器学习革命。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>思维的火花 --- 大数据与数据思维</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-08-31-mind-flower/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-08-31-mind-flower/</id>
    <published>2022-04-30T06:35:13.801Z</published>
    <updated>2022-04-30T07:45:36.919Z</updated>
    
    <content type="html"><![CDATA[<p>在电子设备飞速发展的今天，互联网、移动互联网都已经非常成熟，物联网也在搭建的过程中。对于我们来说4G时代好像还刚开始，5G就即将来临了。每个人、每时每刻都在产生着数据，面对着庞大的数据体量，却只有相对少数的人能够使用正确的方式， 在合适的时机，创造出合适的产品等等。凭借着数据，也诞生了一些新兴的企业或者行业，有人调侃能够使用数据去了解当下，预知未来的视角是先知的视角，从普通的一个广告投放，到预测并影响美国总统大选，从企业门店选址，到智能化精准医疗，数据均是主角，数据为何能够如此的神奇，好像无所不能呢？在了解其本质之前，可能需要先了解一下什么是大数据？什么是大数据时代？</p><h1 id="一、数据与大数据"><a href="#一、数据与大数据" class="headerlink" title="一、数据与大数据"></a>一、数据与大数据</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>关于什么是数据？维基百科是这样解释的：“数据（英语：data），是指未经过处理的原始记录。一般而言，数据缺乏组织及分<br>类，无法明确的表达事物代表的意义，它可能是一堆的杂志、一大叠的报纸、数种的开会记录或是整本病人的病历纪录。数据描述事物的符号记录，是可定义为意义的实体，涉及事物的存在形式。是关于事件之一组离散且客观的事实描述，是构成消息和知识的原始材料。”</p><p>而在计算机的世界里，数据并不是物理世界真实存在的客观事物，而是对客观事物的性质、状态以及相互关系进行记载的物理符号或者物理符号的组合，是可以进行鉴别的符号等。符号不仅指狭义上的数字，还可能是具有一定意义的文字、字符、数字符号的组合，以及图像、视频、音频等等，也可以是客观事物的属性、数量、位置及其相互关系的抽象表示。例如，“0、1、2…&#96;”、“阴、雨、下降、气温”“学生的档案记录、货物的运输情况”等都是数据。<br>简而言之，凡是能够被电子化记录的都是数据。</p><span id="more"></span><h2 id="大数据与大数据时代"><a href="#大数据与大数据时代" class="headerlink" title="大数据与大数据时代"></a>大数据与大数据时代</h2><p>有了上面对数据的认识，什么是大数据就明了了。大数据其实就是海量的数据或者巨量数据，这些数据来源于世界各地，每时每刻所产生的记录。那么什么又是大数据时代呢？其实大数据时代是人们对当前由于数据体量巨大，传统处理软件或者处理方式无法在可接受的时间内处理，而必须使用在数十、数百甚至数千台服务器上同时平行运行的软件（例如：计算机集群）的这种现象级事件（未来可能会有各种变数）以及处理方式的改变而起的一个应景的名称。高德纳公司（英语：Gartner，NYSE：IT），美国一家从事信息技术研究和顾问的公司分析员早在2001年指出大数据时代的挑战和机遇有三个方向：数据量（Volume）、数据输入输出的速度（Velocity）、多样性（Variety），合称为3V或者3Vs。在2012年高德纳公司修正了大数据的定义：“大数据是大量、高速、以及多变的信息资产，它需要新型的处理方式去促成更强的决策能力、洞察力与最优化处理。” </p><p>同时有机构在原有3V的基础上定义了第四个V：真实性（Veracity）为第四特点。截止目前人们认可并了解的大数据时代的四个特征，分别为：数据量（Volume）、数据输入输出的速度（Velocity）、多样性（Variety）、真实性（Veracity），一般我们称之为4V。</p><h2 id="数据的价值"><a href="#数据的价值" class="headerlink" title="数据的价值"></a>数据的价值</h2><p>数据的体量在越来越大，但是数据到底有什么价值？这么多的数据有什么用呢？我们每个人都在时刻产生着数据，对于个人来说，我们都希望数据能够帮助我们或者解决我们所遇到的问题；对于企业来说，希望数据能够提高企业在决策过程中的准确性，改善以往以人的主观意识来做决策的方式亦或提高企业的收入、降低支出或者规避风险等等。不论是个人还是企业，数据的价值核心便是通过对数据的分析研究，得到一个合适合理的结果，以解决某些业务的核心诉求。例如在广告投放领域，传统的方式是广泛撒网，想方设法的覆盖到每个平台、每个时间段，耗时耗力，看似人群覆盖大而广，应该会有很好的收入，但是往往投入产出比很低，而且整个过程耗时耗力，有了大数据的支持之后，研究人员可以通过对历史数据的分析研究，了解用户的各类喜好以及日常习惯，广告的投放就能够根据用户喜好或者场景在合适的时间进行投放，这样既能够实现广告的精准投放，也能够很快的实现转化等等。在这个例子中有一个关键的地方就是，对历史数据进行分析研究，往往比较传统的企业拥有大量的数据，但是却没办法去进行数据的分析研究或者没有想到去进行分析研究，从而错了数据中的价值。</p><h1 id="二、数据思维-—-利用数据解决问题"><a href="#二、数据思维-—-利用数据解决问题" class="headerlink" title="二、数据思维 — 利用数据解决问题"></a>二、数据思维 — 利用数据解决问题</h1><p>什么是数据思维？数据思维的核心是利用数据解决问题，利用数据解决问题的核心是了解需求、了解业务，了解真正要解决什么样       的问题，解决问题背后的真实目的是什么。在解决问题的过程中通常使用数据的方法，可称为量化的方法。即解决问题的过程要可衡量、可评估，有非常明确的定义。车品觉老师《决战大数据》一书中提出的PIMA，非常好的概述了量化分析的维度，即：</p><ul><li>需要有明确的目的(P)</li><li>在达到目的的过程中需要有清晰的定义(I)</li><li>在解决问题的过程中所使用的手段是可量化的(M) 对问题、解决问题的全过程可评估(A)</li></ul><p>通过量化的数据解决问题，就是我们所谓的数据思维。数据思维可以套用统计学科一个专有名词—回归分析的思维方式，将业务        问题转化为数据可分析问题。那么什么样的问题可以被看做是数据可分析问题呢？通常需要找到两类业务相关的变量：</p><ul><li>因变量Y：即业务的核心诉求。影响业务本身的各种因素或多个因素的组合，均是业务核心诉求的影响因素，只有找到影响业务的因素，才能进一步的确定数据范围，明确核心诉求。</li><li>自变量X：即能够对因变量Y进行解释说明的相关变量，也即影响了因变量Y变化的变量。自变量X更加的需要对业务的熟悉和理解。自变量X并不一定越多越好，而是要在众多变量中，找到影响程度较高或者直接影响因变量Y的变量，才是根本。</li></ul><p>数据思维中，难点就是确定因变量Y，即准确的定位业务的核心诉求，并找到影响核心诉求的相关因素，然后使用各种数据分析或       者人工智能的方式方法对数据进行分析研究建模等。</p><p>例如金融类行业最核心的业务诉求是风险控制。如果是简单的存取款问题，可以说是没有风险的。但是如果是信贷问题，可能就存在着一定的风险，此时核心诉求是如何在贷款过程中降低风险，尽量减少贷款个体或企业不还款的风险。这个风险越低，银行的利润空间就越大。因为整个贷款利差并不高，可能只有几个点，最多也不会超过十个点，即便是现在的小贷，也不会超过十个点。但一般一个贷款人还不了款的话，银行利润就会被大打折扣。现在整个市场上的风险率或坏账率有时会高达百分之三、百分之五，即便比较低的时候可能在很多银行有百分之一点几、百分之二点几。所以如何有效的控制这个风险对银行很重要。</p><p>因此需要了解贷款人的还款能力。而且还款能力从他贷款到还款过程中也在时时发生变化，有消费者在贷款瞬间是有还款能力的，但在还款之前的整个周期里他经历的状况其实在不断发生变化。企业更是这样子，每个企业在经营过程中的状态是瞬息万变的。所以对于银行来讲了解消费者或企业的整个经营状况、资产状况、风险状况是非常关键的，中间的每个环节都可能造成贷款人最后无法还款，银行需要评估这里面的每一个因素与最后能否发签证的关系。</p><p>“ 其实我是有一点近视眼的，我看很远处的一个广告牌，上面的文字有时我看得不是很清楚，但我的大脑是能够猜出来文字大概是讲什么的。本质上是因为在我的大脑是拥有识别低分辨率的数据，同时再把它还原推测到高分辨率的那个能力。这种能力其实也是大数据公司里面非常核心的能力。”</p><h1 id="三、数据治理——别让数据成为累赘"><a href="#三、数据治理——别让数据成为累赘" class="headerlink" title="三、数据治理——别让数据成为累赘"></a>三、数据治理——别让数据成为累赘</h1><p>当具备了数据思维，定位到了核心业务诉求之后，就需要着手对数据进行一系列的处理操作，使得数据能够更好更快的进行分析和研究，以最快的速度实现业务诉求的达成。在数据处理阶段，最为核心的工作有两大类，数据治理和数据关联。先看看数据治理或称为数据清洗。</p><p>在如今时代，每时每刻都会产生大量的数据，但如果这些数据没有办法整合到一起，没办法清洗、在线化，没办法让使用者方便取用，那即便数据量再大也不能说这个公司有大数据。所以清洗和整合数据是非常重要的。通常在技术领域有一个概念叫“ETL”，ETL其实只把数据抽取到一起，进行数据格式统一化，最后再加载到一个可应用的平台上，这是整个数据治理行业里面最核心的几个环节。但在大数据概念出来之后，跟传统ETL有一个挺大的区别在于数据格式跟以前相比更加复杂。通常我们所谓的大数据、我们处理的数据除了包括以前的结构化数据，还包括新的非结构化数据以及半结构化数据。</p><p>非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、XML, HTML、各类报表、图像和音频&#x2F;视频信息等等。数据里每一条记录之间的格式并不统一，甚至很多数据都是无效或者无用的数据。另外还有一种半结构化数据，往往在数据产生的过程中，会有多个形式的数据，多种数据在汇聚到一起时，由于格式的不统一，直接带来存储、处理等方面的压力。而如何有效清洗数据，将多种格式的数据合理清洗、在线化，方便使用者取用是对未来数据应用的关键。</p><p> “并不是所有的数据在系统里面都存在，比如说我跟我同事之间的关系，我跟我爱人之间的家庭关系，可能在公安系统里面并没有       完整的存储数据。但是很多数据可以非常快速的被发现出来。”</p><h1 id="四、数据关联——歌迷与犯罪分子"><a href="#四、数据关联——歌迷与犯罪分子" class="headerlink" title="四、数据关联——歌迷与犯罪分子"></a>四、数据关联——歌迷与犯罪分子</h1><p>前面我也提到了很多大数据客户不管是政府还是企业都有很多不同的数据，因为数据本身是需要关联起来，在数据真正联系到一起       之后，在数据内部我们可以发现很多数据和数据之间的关系，而这些关系真正的挖掘好了之后，它的实战价值是非常大的，可以起       到1+1远远大于2的作用。</p><p>例如设备和人的关联，假设某人有多个智能设备，每个设备上使用了不同的账户，进行着日常不同的事务，其中一台设备是这个人       的主力设备，当我们采集到相关的信息之后，可以将多个设备之间进行关联，并与这个人的信息以及日常的行为信息进行关联，并       最终的到完整的活动信息。否则当我们只有一部设备的信息时，是无法得到完整的活动信息的，部分数据可能就成了一个孤立的数       据，而无法发挥数据的价值。</p><p>近期，演唱会上抓犯罪分子的事件发生了不止一次。而如何准确定位到某人是否是犯罪分子，靠的就是大数据的支撑以及AI技术的        发展。在公安平台上，会有一个庞大的数据记录，存放着每个犯罪分子的各类特征数据，例如基础的身份证号、人的基本信息、居       住信息、指纹以及人脸特征等等数据，有了这些数据再加上AI技术的帮助，可以将一个人的信息与犯罪分子的信息进行了关联，从       而达到识别犯罪分子的目的。设想如果犯罪分子的备案信息和社会上活动的人之间无法建立连接，会怎样呢？</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>我们现在生活在一个和数据息息相关的时代，时刻都产生着数据，也使用着数据，数据思维提升着人们对数据的整体认知，人们通过对数据进行挖掘，解决日常问题和业务问题，帮助业务成长，提升了数据的价值。<br>在大数据时代，第一、我们要知道数据是如何获取的，了解数据产生、数据流动等问题；第二、要拥有数据思维，拥有数据思维最核心是要考虑一个事务从起因到结果的发展过程，所有数据其实是记录该过程的证据；第三、深入了解业务，尤其是核心的业务，挖掘业务背后的数据问题，将业务问题转变为数据问题。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">维基百科-数据</a></li><li>《数据思维》</li><li>《数据的本质》</li><li>《决战大数据》</li><li><a href="http://baijiahao.baidu.com/s?id=1605116987075404818&amp;wfr=spider&amp;for=pc">演唱会上抓罪犯，是如何做到的呢？</a></li><li><a href="http://bigdata.51cto.com/art/201804/569711.htm">结构化数据 vs. 非结构化数据</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在电子设备飞速发展的今天，互联网、移动互联网都已经非常成熟，物联网也在搭建的过程中。对于我们来说4G时代好像还刚开始，5G就即将来临了。每个人、每时每刻都在产生着数据，面对着庞大的数据体量，却只有相对少数的人能够使用正确的方式， 在合适的时机，创造出合适的产品等等。凭借着数据，也诞生了一些新兴的企业或者行业，有人调侃能够使用数据去了解当下，预知未来的视角是先知的视角，从普通的一个广告投放，到预测并影响美国总统大选，从企业门店选址，到智能化精准医疗，数据均是主角，数据为何能够如此的神奇，好像无所不能呢？在了解其本质之前，可能需要先了解一下什么是大数据？什么是大数据时代？&lt;/p&gt;
&lt;h1 id=&quot;一、数据与大数据&quot;&gt;&lt;a href=&quot;#一、数据与大数据&quot; class=&quot;headerlink&quot; title=&quot;一、数据与大数据&quot;&gt;&lt;/a&gt;一、数据与大数据&lt;/h1&gt;&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;p&gt;关于什么是数据？维基百科是这样解释的：“数据（英语：data），是指未经过处理的原始记录。一般而言，数据缺乏组织及分&lt;br&gt;类，无法明确的表达事物代表的意义，它可能是一堆的杂志、一大叠的报纸、数种的开会记录或是整本病人的病历纪录。数据描述事物的符号记录，是可定义为意义的实体，涉及事物的存在形式。是关于事件之一组离散且客观的事实描述，是构成消息和知识的原始材料。”&lt;/p&gt;
&lt;p&gt;而在计算机的世界里，数据并不是物理世界真实存在的客观事物，而是对客观事物的性质、状态以及相互关系进行记载的物理符号或者物理符号的组合，是可以进行鉴别的符号等。符号不仅指狭义上的数字，还可能是具有一定意义的文字、字符、数字符号的组合，以及图像、视频、音频等等，也可以是客观事物的属性、数量、位置及其相互关系的抽象表示。例如，“0、1、2…&amp;#96;”、“阴、雨、下降、气温”“学生的档案记录、货物的运输情况”等都是数据。&lt;br&gt;简而言之，凡是能够被电子化记录的都是数据。&lt;/p&gt;</summary>
    
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>\#1\ 为什么要学习数据结构与算法</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/</id>
    <published>2022-04-30T06:35:13.800Z</published>
    <updated>2022-04-30T07:45:27.134Z</updated>
    
    <content type="html"><![CDATA[<p>随机网络上有大量的程序员应该学习<strong>数据结构和算法</strong>的文章。还记得实在大学时代的时候，系统的学习过数据结构、算法相关的课程，而后几乎没有系统学习过了。工作后从一开始的各种业务逻辑的开发，慢慢深入了解到系统底层，了解了代码的执行效率以及对硬件设备资源的消耗基本上都是由数据结构和算法决定的，才开始慢慢关心起来良好的数据结构设计和良好的算法设计，才能够在数据量越来越多的时候，所设计的软件才能良好地执行等。</p><p>那么对于程序员来说，到底为什么要学习数据结构和算法呢？首先要了解的是什么是<strong>数据结构</strong>？</p><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>具体的定义这里摘录了维基百科的定义，具体如下：</p><blockquote><p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。</p><p>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p><p>大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。</p><p>数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p><p>不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。</p><p>正确的数据结构选择可以提高算法的效率（请参考算法效率）。在计算机程序设计的过程中，选择适当的数据结构是一项重要工作。许多大型系统的编写经验显示，程序设计的困难程度与最终成果的质量与表现，取决于是否选择了最适合的数据结构。</p><p>系统架构的关键因素是数据结构而非算法的见解，导致了多种形式化的设计方法与编程语言的出现。绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于用户界面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类 (计算机科学)来达到这个目的。</p><p>摘录自维基百科: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></p></blockquote><span id="more"></span><p>其中有一段个人觉得很有启发，<strong>“不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。”</strong> 个人理解是数据结构不仅仅百年不变的，不同的问题在不同的条件下，可能需要不同的数据结构设计，对于软件开发者而言，数据结构思维要时刻记载心间，根据特定的问题、所处的环境，选择或者设计那种平衡了性能和效率的数据结构。</p><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>同样摘录自维基百科，具体如下：</p><blockquote><p>算法（algorithm），在数学（算学）和计算机科学之中，为任何一系列良定义的具体计算步骤，常用于计算、数据处理和自动推理。作为一个有效方法，算法被用于计算函数，它包含了一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。</p><p>算法中的指令描述的是一个计算，当其运行时能从一个初始状态和初始输入（可能为空）开始，经过一系列有限而清晰定义的状态最终产生输出并停止于一个终态。一个状态到另一个状态的转移不一定是确定的。包括随机化算法在内的一些算法，都包含了一些随机输入。</p><p>摘录自维基百科: <a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a></p></blockquote><p>简言之，就是算法是具体的计算步骤，算法的输入和输出都需要有效。在不同的问题上，所采用的算法也不尽相同，可以说算法也是针对特定的问题和特定的环境下，进行优化设计的一种计算步骤。</p><p>由算法衍生出来一系列和算法相关的内容，例如<strong>设计模式、时间复杂度、空间复杂度</strong>等，为算法的设计和实现提供理论支撑，衡量算法的性能和效率等。具体在后续的内容中将会深入学习。</p><h2 id="为什么要学习数据结构和算法"><a href="#为什么要学习数据结构和算法" class="headerlink" title="为什么要学习数据结构和算法"></a>为什么要学习数据结构和算法</h2><p>计算数据结构和算法都是为了特定的问题在特定的环境下，设计软件开发的系统结构、代码实现方式等，那么程序员就应该熟谙其中的知识点，掌握基本的数据结构设计和算法设计，以最优化的思维编写程序代码，完成对特定功能的最优化实现，保证软件的高质量完成和执行。具体程序员为什么要学习数据结构和算法，大概有如下三点理由：</p><h3 id="1-面试"><a href="#1-面试" class="headerlink" title="1. 面试"></a>1. 面试</h3><p>毫不客气地讲，良好的数据结构和算法知识储备，是程序员或者软件开发工程师找工作的敲门砖。在工程师面试的中，几乎都会涉及到算法和数据结构的测试，具有扎实的数据结构和算法基础，越来越成为面试中是否可以继续的红线。</p><h3 id="2-工作"><a href="#2-工作" class="headerlink" title="2. 工作"></a>2. 工作</h3><p>在工作中面临巨大的数据量时，良好数据结构的设计，能够应对更加从容；使用正确地算法能够让软件的性能和效率更好。移动端应用程序将会更灵活并且耗电量低。服务端应用程序将会在少量的能耗下处理多并发请求等。</p><h3 id="3-自我提升"><a href="#3-自我提升" class="headerlink" title="3. 自我提升"></a>3. 自我提升</h3><p>技术的革新是日新月异的，作为技术从业者，我们可能要不断地进行学习，以了解技术的发展，并应对业务的发展。例如在Swift语言中，Swift标准库有一个通用的集合类型的系列，他们不需要定义所有特定的情况，通用类型即可。在不断学习之后，你才能了解到语言本身所涵盖的特性等，为了更加高效和完善的软件提供知识支援等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许每个人的学习方式和目的不尽相同，但是上述三个理由，总有一个给与你学习的充分理由的，不论是为了即将到来的面试、还是正在进行中的工作任务，抑或为了不让自己的技术落伍等，作为程序员来说，都应该重视数据结构和算法，夯实自己的基础知识，并在其上映射到你所擅长或者感兴趣的编程语言上，了解语言的特性并编写设计出良好的数据结构和算法，为自己的下一次远程储备粮草！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随机网络上有大量的程序员应该学习&lt;strong&gt;数据结构和算法&lt;/strong&gt;的文章。还记得实在大学时代的时候，系统的学习过数据结构、算法相关的课程，而后几乎没有系统学习过了。工作后从一开始的各种业务逻辑的开发，慢慢深入了解到系统底层，了解了代码的执行效率以及对硬件设备资源的消耗基本上都是由数据结构和算法决定的，才开始慢慢关心起来良好的数据结构设计和良好的算法设计，才能够在数据量越来越多的时候，所设计的软件才能良好地执行等。&lt;/p&gt;
&lt;p&gt;那么对于程序员来说，到底为什么要学习数据结构和算法呢？首先要了解的是什么是&lt;strong&gt;数据结构&lt;/strong&gt;？&lt;/p&gt;
&lt;h2 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构？&quot;&gt;&lt;/a&gt;什么是数据结构？&lt;/h2&gt;&lt;p&gt;具体的定义这里摘录了维基百科的定义，具体如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。&lt;/p&gt;
&lt;p&gt;数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。&lt;/p&gt;
&lt;p&gt;大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。&lt;/p&gt;
&lt;p&gt;数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。&lt;/p&gt;
&lt;p&gt;不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。&lt;/p&gt;
&lt;p&gt;正确的数据结构选择可以提高算法的效率（请参考算法效率）。在计算机程序设计的过程中，选择适当的数据结构是一项重要工作。许多大型系统的编写经验显示，程序设计的困难程度与最终成果的质量与表现，取决于是否选择了最适合的数据结构。&lt;/p&gt;
&lt;p&gt;系统架构的关键因素是数据结构而非算法的见解，导致了多种形式化的设计方法与编程语言的出现。绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于用户界面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类 (计算机科学)来达到这个目的。&lt;/p&gt;
&lt;p&gt;摘录自维基百科: &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;数据结构&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Data Structures &amp; Algorithms in Swift" scheme="https://zycslog.github.io/categories/Data-Structures-Algorithms-in-Swift/"/>
    
    
    <category term="Swift中的数据结构与算法" scheme="https://zycslog.github.io/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>\#5\ Linked List &amp;&amp; Swift Collection Protocol</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/</id>
    <published>2022-04-30T06:35:13.800Z</published>
    <updated>2022-04-30T07:45:33.512Z</updated>
    
    <content type="html"><![CDATA[<p>在Swift标准库（<strong>Swift standard library</strong>）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集合中，有四种关于<strong>集合的协议（collection protocols）</strong>，分别是：</p><ul><li><strong>Tier 1, Sequence：</strong>序列类型是Swift中最为朴素的协议,仅仅定义了一系列类型相同的元素，而不对这一系列元素的性质有任何额外的约定。它唯一约定了的动作，就是从序列当前位置读取下一个元素。</li><li><strong>Tier 2, Collection：</strong>集合类型是一种提供额外保证的序列类型。集合类型是有限的，允许重复的非破坏性顺序访问。</li><li><strong>Tier 3, BidirectionalColllection：</strong>集合类型可以是双向集合类型，可以允许在序列中上下双向移动。 这对于链表是不可能的，因为你只能从头到尾，而不是相反。</li><li><strong>Tier 4, RandomAccessCollection：</strong>如果它可以保证访问特定索引处的元素将花费与访问任何其他索引处的元素一样长的时间。该双向集合类型就是随机访问集合类型， 这对于链表来说是不可能的，因为访问列表前面附近的节点比列表下方的节点快得多。</li></ul><p>因此对于链表数据结构来说，<strong>Sequence</strong>和<strong>Collection</strong>两种协议是适用的。首先链表是一个序列型数据结构，适用<strong>Sequence</strong>协议，另外链表是有限序列，适用<strong>Collection</strong>协议。</p><span id="more"></span><h2 id="进化为Swift集合"><a href="#进化为Swift集合" class="headerlink" title="进化为Swift集合"></a>进化为Swift集合</h2><p>集合类型是有限序列，并提供非破坏性顺序访问。 Swift Collection还允许通过<strong>下标（subscript）</strong>进行访问, 使用索引可以映射到集合中的值。</p><p>例如Swift中Array通过下标的方式访问元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>数组的下标一律是整数类型，例如上例中5。下标被包裹在方括号内。通过下标可以获取到集合对应未知的元素。</p><h3 id="自定义集合索引"><a href="#自定义集合索引" class="headerlink" title="自定义集合索引"></a>自定义集合索引</h3><p>衡量<strong>Collection</strong>协议性能的指标是下标对应到值的速度。和其他数据类型（例如Swift的Array）不同，链表结构不能使用整数实现O(1)的下标操作。因此，自定义下标索引是对各自节点引用的索引。</p><p>在上文<a href="https://robinchao.github.io/2019/12/03/Data-Structures-&-Algorithms-in-Swift-04.html">#4\ Linked List 的Swift实现</a>的<strong>LinkedList.swift</strong>中，继续添加如下扩展程序，实现自定义索引的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">LinkedList</span>: <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义链表索引</span></span><br><span class="line">    <span class="comment">// 由于索引是一个可比较的对象，需要继承Comparable协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Index</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">var</span> node: <span class="type">Node</span>&lt;<span class="type">Value</span>&gt;?</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自定义结构体不能进行==操作, 需要自行实现</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Index</span>, <span class="params">rhs</span>: <span class="type">Index</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="comment">// 属于switch语句中使用元组</span></span><br><span class="line">            <span class="keyword">switch</span> (lhs.node, rhs.node) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> (left<span class="operator">?</span>, right<span class="operator">?</span>):</span><br><span class="line">                <span class="keyword">return</span> left.next <span class="operator">===</span> right.next</span><br><span class="line">            <span class="keyword">case</span> (<span class="literal">nil</span>, <span class="literal">nil</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个参数是否小于第二个参数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">&lt;</span>(<span class="params">lhs</span>: <span class="type">Index</span>, <span class="params">rhs</span>: <span class="type">Index</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> lhs <span class="operator">!=</span> rhs <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从链表的一个节点移动到根节点</span></span><br><span class="line">            <span class="comment">// 这里使用Swift的内联序列函数sequence(first: next:)，类似repeat...while操作</span></span><br><span class="line">            <span class="keyword">let</span> nodes <span class="operator">=</span> <span class="built_in">sequence</span>(first: lhs.node) &#123; </span><br><span class="line">                <span class="variable">$0</span><span class="operator">?</span>.next </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> nodes.contains &#123; </span><br><span class="line">                <span class="variable">$0</span> <span class="operator">===</span> rhs.node </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表的头节点索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> startIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Index</span>(node: head)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表的尾节点索引</span></span><br><span class="line">    <span class="comment">// 由于Collection协议的endIndex默认是序列最后可访问的值的索引，对于链表来说，需要制定tail节点的next</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> endIndex: <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Index</span>(node: tail<span class="operator">?</span>.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 索引是可以递增的，给定索引的下一个索引就是当前节点的next</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">index</span>(<span class="params">after</span> <span class="params">i</span>: <span class="type">Index</span>) -&gt; <span class="type">Index</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Index</span>(node: i.node<span class="operator">?</span>.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将索引映射到集合中的值。由于已经创建了自定义索引，因此可以通过引用节点的值在恒定时间内轻松实现此目的。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">subscript</span>(<span class="params">position</span>: <span class="type">Index</span>) -&gt; <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position.node<span class="operator">!</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到主Playground，编写自定义索引功能的使用操作，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;using collection&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">...</span> <span class="number">9</span> &#123;</span><br><span class="line">        list.append(i)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;List: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;First element: <span class="subst">\(list[list.startIndex])</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Array containing first 3 elements: <span class="subst">\(Array(list.prefix(<span class="number">3</span>)))</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Array containing last 3 elements: <span class="subst">\(Array(list.suffix(<span class="number">3</span>)))</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sum <span class="operator">=</span> list.reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sum of all values: <span class="subst">\(sum)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of using collection---</span></span><br><span class="line"><span class="comment">// List: 0 -&gt;1 -&gt;2 -&gt;3 -&gt;4 -&gt;5 -&gt;6 -&gt;7 -&gt;8 -&gt;9         </span></span><br><span class="line"><span class="comment">// First element: 0</span></span><br><span class="line"><span class="comment">// Array containing first 3 elements: [0, 1, 2]</span></span><br><span class="line"><span class="comment">// Array containing last 3 elements: [7, 8, 9]</span></span><br><span class="line"><span class="comment">// Sum of all values: 45</span></span><br></pre></td></tr></table></figure><h3 id="值语义和写入时复制（copy-on-write）"><a href="#值语义和写入时复制（copy-on-write）" class="headerlink" title="值语义和写入时复制（copy-on-write）"></a>值语义和写入时复制（copy-on-write）</h3><p>Swift Collection的另一个重要特性是它们具有值语义，通过<strong>写入时复制</strong>实现的，特此称为 <strong>COW</strong>。为了说明此概念，您将使用数组验证此行为。在Playground页面的底部编写以下内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;array cow&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array1 <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">var</span> array2 <span class="operator">=</span> array1</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;array1: <span class="subst">\(array1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;array2: <span class="subst">\(array2)</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- After adding 3 to array 2 ---&quot;</span>)</span><br><span class="line">    array2.append(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;array1: <span class="subst">\(array1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;array2: <span class="subst">\(array2)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of array cow---</span></span><br><span class="line"><span class="comment">// array1: [1, 2]</span></span><br><span class="line"><span class="comment">// array2: [1, 2]</span></span><br><span class="line"><span class="comment">// --- After adding 3 to array 2 ---</span></span><br><span class="line"><span class="comment">// array1: [1, 2]</span></span><br><span class="line"><span class="comment">// array2: [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>array1是不可变的常量，就算将array1赋值给了变量array2，当array2的内容改变的时候，array1也不会改变，而此时有一个关键的地方是，array2在被赋值为array1的时候，并没有开辟新的存储空间，而是指向了array1的存储空间。当对array2进行append操作时，array2才对array1的内存空间进行了一个拷贝，然后添加了元素3。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/5/array-cow.png"></p><p>了解了值语义之后，来检查我们首先的Linked List是否也具有值语义的特性，在Playground中变下如下测试代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;linked list cow test&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.append(<span class="number">1</span>)</span><br><span class="line">    list1.append(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> list2 <span class="operator">=</span> list1</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list1: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list2: <span class="subst">\(list2)</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- After adding 3 to list 2 ---&quot;</span>)</span><br><span class="line">    list2.append(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list1: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;list2: <span class="subst">\(list2)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of linked list cow test---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// --- After adding 3 to list 2 ---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 -&gt;3</span></span><br></pre></td></tr></table></figure><p>可以看到，我们实现的LinkedList并不具有值语义的特性。因为我们在基础存储的时候使用了引用类型（Node），在Swift中，结构体应该是支持值语义的，因此关于LinkedList的实现，还需要进行优化，以支持值语义特性。</p><p>使用<strong>COW</strong>实现值语义的特性相对较为简单。在更改链表的内容之前，需要对基础存储部分进行<strong>copy</strong>操作，同时将链表的所有引用（head、tail）更新到新的copy副本中。实现代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">copyNodes</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">var</span> oldNode <span class="operator">=</span> head <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    head <span class="operator">=</span> <span class="type">Node</span>(value: oldNode.value)</span><br><span class="line">    <span class="keyword">var</span> newNode <span class="operator">=</span> head</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> nextOfNode <span class="operator">=</span> oldNode.next &#123;</span><br><span class="line">        newNode<span class="operator">!</span>.next <span class="operator">=</span> <span class="type">Node</span>(value: nextOfNode.value)</span><br><span class="line">        newNode <span class="operator">=</span> newNode<span class="operator">!</span>.next</span><br><span class="line">            </span><br><span class="line">        oldNode <span class="operator">=</span> nextOfNode</span><br><span class="line">    &#125;</span><br><span class="line">    tail <span class="operator">=</span> newNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作是原有链表节点的值赋值给新建的节点，为链表的所有节点建立了一个新的副本。接下来需要修改LinkedList中的一些方法，增加<code>copyNodes()</code>方法的调用，以支持值语义特性。</p><ul><li>push</li><li>append</li><li>insert(after:)</li><li>pop</li><li>removeLast</li><li>remove(after:)</li></ul><p>完整了上述方法的修改后，回到主Playground，进行值语义特性的再次测试，得到如下结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Example of linked list cow test---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// --- After adding 3 to list 2 ---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure><p>得到的结果也符合值语义的特性，但是这里有一个问题，在加入了值语义特性后，在每一个支持<strong>mutating</strong>的方法中，都多了一个**O(n)**的copy操作，显得得不偿失。</p><h2 id="COW的优化"><a href="#COW的优化" class="headerlink" title="COW的优化"></a>COW的优化</h2><p>每一个支持<strong>mutating</strong>的方法中，都多了一个**O(n)**的copy操作，显然是不可接受的。接下来着手对其进行进一步的优化，有两种方式可以帮助解决这个问题。第一种便是当节点仅有一个拥有者的时候，避免进行复制。</p><h3 id="isKnownUniquelyReferenced"><a href="#isKnownUniquelyReferenced" class="headerlink" title="isKnownUniquelyReferenced"></a>isKnownUniquelyReferenced</h3><p>在Swift的标准库中,有一个函数<strong>isKnownUniquelyReferenced</strong>,该函数可用于检查对象是否只有一个引用。使用该函数对上述实现进行测试，在上述值语义的测试代码中的<code>var list2 = list1</code>语句前后，添加检查：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;List1 uniquely referenced: <span class="subst">\(<span class="built_in">isKnownUniquelyReferenced</span>(<span class="operator">&amp;</span>list1.head))</span>&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> list2 <span class="operator">=</span> list1</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;List1 uniquely referenced: <span class="subst">\(<span class="built_in">isKnownUniquelyReferenced</span>(<span class="operator">&amp;</span>list1.head))</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行后，打印结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List1 uniquely referenced: <span class="literal">true</span></span><br><span class="line">List1 uniquely referenced: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>使用<strong>isKnownUniquelyReferenced</strong>能够检查node对象是否被共享。验证了此函数的功能后，删除上述打印语句，在**copyNodes()**函数中添加检查性代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="operator">!</span><span class="built_in">isKnownUniquelyReferenced</span>(<span class="operator">&amp;</span>head) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加后，测试COW，打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---Example of linked list cow test---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// --- After adding 3 to list 2 ---</span></span><br><span class="line"><span class="comment">// list1: 1 -&gt;2 </span></span><br><span class="line"><span class="comment">// list2: 1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure><p>可以看到值语义特性依然运行良好。通过这个优化，LinkedList的性能将借助COW的特性恢复到之前的水平。</p><h3 id="节点共享"><a href="#节点共享" class="headerlink" title="节点共享"></a>节点共享</h3><blockquote><p>节点共享是在禁用COW的情况下的另一种方式，因此在下面的工作原理中，均属于禁用COW的范畴。</p></blockquote><p>另一种优化COW的方式是通过<strong>节点部分共享</strong>的方式。在一些情况下，并不需要完全复制整个链表，其中部分节点可以采用共享的方式实现。其工作原理如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;share nodes &quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">3</span>).forEach &#123; list1.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> list2 <span class="operator">=</span> list1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>list2</code>并未新建内存空间，而是将指针指向了list1对应的位置。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/5/share-nodes-eg1.png"></p><p>接下来向list2中添加元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list2.push(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/5/share-nodes-eg2.png"></p><p>通过上述图例可知，list1和list2两个链表共享了节点1、2、3，并且list1的头节点属于共享节点1。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1: 1 -&gt;2 -&gt;3  </span><br><span class="line">list2: 0 -&gt;1 -&gt;2 -&gt;3 </span><br></pre></td></tr></table></figure><p>如果此时向list1添加元素：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.push(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/5/share-nodes-eg3.png"></p><p>打印结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1: 100 -&gt;1 -&gt;2 -&gt;3   </span><br><span class="line">list2: 0 -&gt;1 -&gt;2 -&gt;3  </span><br></pre></td></tr></table></figure><p>可以看到两个链表依然共享节点1、2、3，list1的头节点已经改变。</p><p><strong>节点共享</strong>的方式是另一种可以实现类似COW特性的方式，在值语义的功能中可能会比Copy操作更加有效。这里不再进行具体的实现。</p><h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul><li><strong>单向链表是一个线性的、单向的数据结构</strong>，一旦将引用从一个节点移动到另一个节点，将无法返回；</li><li>链接列表具有头插入的 <strong>O（1）</strong> 时间复杂性。数组具有 <strong>O（n）</strong> 时间复杂性；</li><li>符合 Swift 集合协议（如<strong>Sequence</strong>和<strong>Collection</strong>）为相当少量的需求提供了大量有用的方法；</li><li>通过写<strong>入时复制（COW）</strong>行为，您可以实现值语义。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Swift标准库（&lt;strong&gt;Swift standard library&lt;/strong&gt;）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集合中，有四种关于&lt;strong&gt;集合的协议（collection protocols）&lt;/strong&gt;，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tier 1, Sequence：&lt;/strong&gt;序列类型是Swift中最为朴素的协议,仅仅定义了一系列类型相同的元素，而不对这一系列元素的性质有任何额外的约定。它唯一约定了的动作，就是从序列当前位置读取下一个元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tier 2, Collection：&lt;/strong&gt;集合类型是一种提供额外保证的序列类型。集合类型是有限的，允许重复的非破坏性顺序访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tier 3, BidirectionalColllection：&lt;/strong&gt;集合类型可以是双向集合类型，可以允许在序列中上下双向移动。 这对于链表是不可能的，因为你只能从头到尾，而不是相反。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tier 4, RandomAccessCollection：&lt;/strong&gt;如果它可以保证访问特定索引处的元素将花费与访问任何其他索引处的元素一样长的时间。该双向集合类型就是随机访问集合类型， 这对于链表来说是不可能的，因为访问列表前面附近的节点比列表下方的节点快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此对于链表数据结构来说，&lt;strong&gt;Sequence&lt;/strong&gt;和&lt;strong&gt;Collection&lt;/strong&gt;两种协议是适用的。首先链表是一个序列型数据结构，适用&lt;strong&gt;Sequence&lt;/strong&gt;协议，另外链表是有限序列，适用&lt;strong&gt;Collection&lt;/strong&gt;协议。&lt;/p&gt;</summary>
    
    
    
    <category term="Data Structures &amp; Algorithms in Swift" scheme="https://zycslog.github.io/categories/Data-Structures-Algorithms-in-Swift/"/>
    
    
    <category term="Swift中的数据结构与算法" scheme="https://zycslog.github.io/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>异常点检测算法小结</title>
    <link href="https://zycslog.github.io/2022/04/30/2018-08-02-novelty-detection/"/>
    <id>https://zycslog.github.io/2022/04/30/2018-08-02-novelty-detection/</id>
    <published>2022-04-30T06:35:13.799Z</published>
    <updated>2022-04-30T07:45:17.541Z</updated>
    
    <content type="html"><![CDATA[<p>异常点检测，有时也叫离群点检测，英文一般叫做Novelty Detection或者Outlier Detection,是比较常见的一类非监督学习算法，这里就对异常点检测算法做一个总结。</p><h2 id="异常点检测算法使用场景"><a href="#异常点检测算法使用场景" class="headerlink" title="异常点检测算法使用场景"></a>异常点检测算法使用场景</h2><p>什么时候我们需要异常点检测算法呢？常见的有三种情况。</p><ol><li>在做特征工程的时候需要对异常的数据做过滤，防止对归一化等处理的结果产生影响。</li><li>对没有标记输出的特征数据做筛选，找出异常的数据。</li><li>对有标记输出的特征数据做二分类时，由于某些类别的训练样本非常少，类别严重不平衡，此时也可以考虑用非监督的异常点检测算法来做。</li></ol><span id="more"></span><h2 id="异常点检测算法常见类别"><a href="#异常点检测算法常见类别" class="headerlink" title="异常点检测算法常见类别"></a>异常点检测算法常见类别</h2><p>异常点检测的目的是找出数据集中和大多数数据不同的数据，常用的异常点检测算法一般分为三类。</p><p><strong>第一类是基于统计学的方法来处理异常数据。</strong>这种方法一般会构建一个概率分布模型，并计算对象符合该模型的概率，把具有低概率的对象视为异常点。比如特征工程中的RobustScaler方法，在做数据特征值缩放的时候，它会利用数据特征的分位数分布，将数据根据分位数划分为多段，只取中间段来做缩放，比如只取25%分位数到75%分位数的数据做缩放。这样减小了异常数据的影响。</p><p><strong>第二类是基于聚类的方法来做异常点检测。</strong>这个很好理解，由于大部分聚类算法是基于数据特征的分布来做的，通常如果我们聚类后发现某些聚类簇的数据样本量比其他簇少很多，而且这个簇里数据的特征均值分布之类的值和其他簇也差异很大，这些簇里的样本点大部分时候都是异常点。比如我之前讲到的BIRCH聚类算法原理和DBSCAN密度聚类算法都可以在聚类的同时做异常点的检测。</p><p><strong>第三类是基于专门的异常点检测算法来做。</strong>这些算法不像聚类算法，检测异常点只是一个赠品，它们的目的就是专门检测异常点的，这类算法的代表是One Class SVM和Isolation Forest.</p><p>下文主要会对One Class SVM和Isolation Forest做详细的讨论分析。</p><h2 id="One-Class-SVM算法"><a href="#One-Class-SVM算法" class="headerlink" title="One Class SVM算法"></a>One Class SVM算法</h2><p>One Class SVM也是属于支持向量机大家族的，但是它和传统的基于监督学习的分类回归支持向量机不同，它是无监督学习的方法，也就是说，它不需要我们标记训练集的输出标签。</p><p>那么没有类别标签，我们如何寻找划分的超平面以及寻找支持向量呢？One Class SVM这个问题的解决思路有很多。这里只讲解一种特别的思路SVDD, 对于SVDD来说，我们期望所有不是异常的样本都是正类别，同时它采用一个超球体而不是一个超平面来做划分，该算法在特征空间中获得数据周围的球形边界，期望最小化这个超球体的体积，从而最小化异常点数据的影响。</p><p>假设产生的超球体参数为中心o和对应的超球体半径r&gt;0，超球体体积V(r) 被最小化，中心o是支持向量的线性组合；跟传统SVM方法相似，可以要求所有训练数据点xi到中心的距离严格小于r，但同时构造一个惩罚系数为 C 的松弛变量ξi，优化问题如下所示：</p><p><img src="/images/noveltydection/1.png"></p><p>在采用拉格朗日对偶求解之后，可以判断新的数据点 z 是否在类内，如果z到中心的距离小于或者等于半径r,则不是异常点，如果在超球体以外，则是异常点。</p><p>在sklearn中，我们可以用svm包里面的OneClassSVM来做异常点检测。OneClassSVM也支持核函数，所以普通SVM里面的调参思路在这里也适用。</p><h2 id="Isolation-Forest算法"><a href="#Isolation-Forest算法" class="headerlink" title="Isolation Forest算法"></a>Isolation Forest算法</h2><p>Isolation Forest(以下简称IForest)是周志华老师的学生提出来的，主要是利用集成学习的思路来做异常点检测，目前几乎成为异常点检测算法的首选项，我之前在Bagging与随机森林算法原理小结第4.3节中也简略讲解了IForest的思路，它是随机森林大家族的一员。</p><p>算法本身并不复杂，主要包括第一步训练构建随机森林对应的多颗决策树，这些决策树一般叫iTree，第二步计算需要检测的数据点x最终落在任意第t颗iTree的层数ht(x)。然后我们可以得出x在每棵树的高度平均值h(x)。第三步根据h(x)判断x是否是异常点。</p><p>对于第一步构建决策树的过程，方法和普通的随机森林不同。</p><p>首先采样决策树的训练样本时，普通的随机森林要采样的样本个数等于训练集个数。但是iForest不需要采样这么多，一般来说，采样个数要远远小于训练集个数。原因是我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来了。</p><p>另外就是在做决策树分裂决策时，由于我们没有标记输出，所以没法计算基尼系数或者和方差之类的划分标准。这里我们使用的是随机选择划分特征，然后在基于这个特征再随机选择划分阈值，进行决策树的分裂。直到树的深度达到限定阈值或者样本数只剩一个。</p><p>第二步计算要检测的样本点在每棵树的高度平均值h(x)。首先需要遍历每一颗iTree，得到检测的数据点x最终落在任意第t颗iTree的数层数ht(x)。这个ht(x)代表的是树的深度，也就是离根节点越近，则ht(x)越小，越靠近底层，则ht(x)越大，根节点的高度为0.</p><p>第三步是据h(x)判断x是否是异常点。我们一般用下面的公式计算x的异常概率分值：</p><p><img src="/images/noveltydection/2.png"></p><p>, s(x,m)的取值范围是[0,1],取值越接近于1，则是异常点的概率也越大。其中，m为样本个数。的表达式为：</p><p><img src="/images/noveltydection/3.png"></p><p>从s(x,m)表示式可以看出，如果高度h(x)→0, 则s(x,m)→1，即是异常点的概率是100%，如果高度h(x)→m−1, 则s(x,m)→0,即不可能是异常点。如果高度h(x)→c(m), 则s(x,m)→0.5，即是异常点的概率是50%，一般我们可以设置$s(x,m)的一个阈值然后去调参，这样大于阈值的才认为是异常点。</p><p>在sklearn中，我们可以用ensemble包里面的IsolationForest来做异常点检测。</p><h2 id="异常点检测算法小结"><a href="#异常点检测算法小结" class="headerlink" title="异常点检测算法小结"></a>异常点检测算法小结</h2><p>IForest目前是异常点检测最常用的算法之一，它的优点非常突出，它具有线性时间复杂度。因为是随机森林的方法，所以可以用在含有海量数据的数据集上面。通常树的数量越多，算法越稳定。由于每棵树都是互相独立生成的，因此可以部署在大规模分布式系统上来加速运算。对于目前大数据分析的趋势来说，它的好用是有原因的。</p><p>但是IForest也有一些缺点，比如不适用于特别高维的数据。由于每次切数据空间都是随机选取一个维度和该维度的随机一个特征，建完树后仍然有大量的维度没有被使用，导致算法可靠性降低。此时推荐降维后使用，或者考虑使用One Class SVM。</p><p>另外iForest仅对即全局稀疏点敏感，不擅长处理局部的相对稀疏点 ，这样在某些局部的异常点较多的时候检测可能不是很准。</p><p>而One Class SVM对于中小型的数据分析，尤其是训练样本不是特别海量的时候用起来经常会比iForest顺手，因此比较适合做原型分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;异常点检测，有时也叫离群点检测，英文一般叫做Novelty Detection或者Outlier Detection,是比较常见的一类非监督学习算法，这里就对异常点检测算法做一个总结。&lt;/p&gt;
&lt;h2 id=&quot;异常点检测算法使用场景&quot;&gt;&lt;a href=&quot;#异常点检测算法使用场景&quot; class=&quot;headerlink&quot; title=&quot;异常点检测算法使用场景&quot;&gt;&lt;/a&gt;异常点检测算法使用场景&lt;/h2&gt;&lt;p&gt;什么时候我们需要异常点检测算法呢？常见的有三种情况。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在做特征工程的时候需要对异常的数据做过滤，防止对归一化等处理的结果产生影响。&lt;/li&gt;
&lt;li&gt;对没有标记输出的特征数据做筛选，找出异常的数据。&lt;/li&gt;
&lt;li&gt;对有标记输出的特征数据做二分类时，由于某些类别的训练样本非常少，类别严重不平衡，此时也可以考虑用非监督的异常点检测算法来做。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何完成技术跃迁</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-03-23-transition/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-03-23-transition/</id>
    <published>2022-04-30T06:35:13.798Z</published>
    <updated>2022-04-30T07:45:13.181Z</updated>
    
    <content type="html"><![CDATA[<p>前言：近期又到了毕业招聘季，我作为技术分享嘉宾，回到母校参加宣讲会，做了一个主题为《如何在毕业三年完成技术跃迁》的分享，本文由此次分享整理而成，并改名为《如何完成技术跃迁》，希望能够给刚进入职场的程序员，或者卡在瓶颈期的程序员，带来一些指导，在技术的道路上少走些弯路。请注意，本文源于我的经验思考，非教条或准则，仅供参考。另由于本人主要的项目经验来源于App端（主要是iOS、Android），Web前端及后端只是稍有涉猎，因此文中的例子大多也来自App端，其他端同学可能会觉得陌生，但应该不会影响理解。</p><p>本文约1W字，阅读时长大概二十分钟，稍有啰嗦，请见谅。 </p><h1 id="1-什么是技术跃迁"><a href="#1-什么是技术跃迁" class="headerlink" title="1. 什么是技术跃迁"></a>1. 什么是技术跃迁</h1><p>首先，我们需要明确一个定义，什么是技术跃迁？在说技术跃迁之前，跟大家解释下跃迁这个词。</p><p>”跃迁“，来源于量子力学，说的是微观状态发生跳跃式变化的过程，比如从低能态跳跃到高能态，需要注意的是：因为微观粒子的状态是分立的，也即是非连续性的，所以这个变化是跳跃性的。用这个词来说明技术的成长，个人认为是非常合适的。</p><span id="more"></span><p>以个人的经验来看，程序员的技术成长曲线大抵是这样的：</p><p><img src="/images/transition/transition.png" alt="Transition"></p><p>成长阶段说明：</p><ul><li><strong>成长期</strong>：新手通过正常的学习工作积累，一般能够在一到两年成为熟手。</li><li><strong>稳定期</strong>：是程序员的舒适区，但并非停滞期，该期间，程序员会进入到比较长的学习积累期，为后续的跃迁做准备。</li><li><strong>跃迁</strong>：成长期和稳定期积累的知识点一般是离散的，点与点之间联结较少。在逐步的反思，慢慢有意识联结，一但联结成网构成了下一阶段所需具备的<strong>技术知识体系</strong>，即完成阶段的跃迁。</li></ul><p>成长路径说明：</p><ol><li><p>新手成长至熟手：从新手到熟手，只需要正常的经验积累成长即可。</p></li><li><p>熟手稳定期：大多数程序员会在熟手阶段经历较漫长的稳定期。此期间的表现为，有一定的平台开发经验，能够负责大部分需求功能的开发工作，但看问题不够全面，无法负责复杂系统的设计开发工作。</p></li><li><p>熟手跃迁至单领域专家：这是程序员的第一个跃迁，带来的变化是非常可观的。表现为，对所在领域&#x2F;平台有比较全面而深入的理解，能够负责复杂系统甚至全系统的设计开发工作。</p></li><li><p>单领域专家稳定期：经过第一次跃迁之后，单领域专家会经历更漫长的稳定期，在此阶段会经常出现多方向的分化：</p></li></ol><ul><li><strong>管理方向</strong>：成为单领域专家之后，一般被认为具备了单领域&#x2F;平台技术负责人的能力，此时部分人员会成为技术负责人或经理，走上管理路线。</li><li><strong>困于舒适区</strong>：大部分程序员成为单领域专家之后，会困于舒适区。因为他的能力已经足够把控所在领域的开发工作，此时无论朝单领域深度发展，或是跨领域发展，除了个人主观能动之外，还需要有合适的平台和实战机会；另外，成为单领域专家的程序员大多开始步入成家立业的阶段，生活会对其精力造成一定的分散。</li><li><strong>多领域专家方向</strong>：少部分人会朝多领域专家方向前进，这是一条最艰难的道路，如果只是自己主观意愿的话，即使努力学习，没有合适的机会去实战锻炼的话，很可能只是学些皮毛，拓展下视野。当然，天纵奇才不在此之列。</li></ul><ol start="5"><li>多领域专家&#x2F;宗师：成为单领域专家之后，要想成为多领域专家，甚至宗师，需要付出更多的努力。本人自认非多领域专家，更非宗师，所以这往上的阶段只是个人的臆想而已。</li></ol><p>成长曲线只是一个简化的抽象模型，让大家比较形象地理解技术成长，但实际上却是因人而异，现在也没有一个认证考试来证明你具备了某一层级的技术水平，希望大家不要直接往上去套。在技术的道路上，不排除存在某些人突然灵光乍现、醍醐灌顶而跃迁飞升；但大部分人不过是日积月累、日拱一卒，慢慢形成自己的技术知识体系。</p><h2 id="1-1-技术知识体系"><a href="#1-1-技术知识体系" class="headerlink" title="1.1 技术知识体系"></a>1.1 技术知识体系</h2><p>上文中经常提到的技术知识体系，是跃迁重要的标志。就如同本科生、研究生、博士生的知识体系一样，不同行业不同的层级也需要不同的知识体系。知识体系，这个词其实不难理解。本节用一个例子来说明，让大家有个直观的理解，什么是技术知识体系。</p><p>假如现在你所在的项目组，需要实现一个移动端（App&#x2F;H5）的登录功能，如下图：</p><p><img src="/images/transition/jgj_login.png" alt="金管家登录"></p><p>你会如何开始你的表演？</p><p>你可能会计划根据软件工程的规范，做下设计，画下流程图，然后再敲代码实现。这只是你的臆想，根据我的经验观察，80%的新手都会选择：”Talk is cheap, Let’s Code!“ 直接上手写代码，大部分人在动手之前，可能脑袋都是一团浆糊，但却盲目自信：边写代码，思维会越来越清晰。</p><p>下面，来看一个具备移动App技术知识系统的程序员的常见做法：</p><h3 id="1-1-1-设计先行"><a href="#1-1-1-设计先行" class="headerlink" title="1.1.1 设计先行"></a>1.1.1 设计先行</h3><p><img src="/images/transition/design.png" alt="设计"></p><ol><li><p><strong>确定设计目标</strong>：第一要务，是要确定功能的设计目标是什么，我现在假设登录功能的优先目标是可靠性、健壮性和安全性，以保证用户能够稳定、安全地进行登录。</p></li><li><p><strong>架构设计</strong>：如果App已有成熟的架构，登录功能的架构设计会遵循App的架构设计；如果登录需要做特殊设计，应该会考虑优先采用比较成熟稳定的架构设计模式，以保证架构成熟、稳定、可靠及易于理解，满足设计目标。</p></li><li><p><strong>详细设计</strong>：假设此次登录功能采用MVC的架构设计模型，一般Model层是比较复杂的，所以我们着重Model的设计。</p></li></ol><ul><li><strong>业务逻辑层的设计</strong>：包括接口设计、重要业务逻辑设计。此处重要业务逻辑，举了个客户端登录中非常重要的，涉及切换用户导致用户上下文切换的例子。如已登录的A用户退出登录后，B用户登录，那么必须保证A用户与B用户的之间不会窜数据。有人可能认为这个非常简单，实际不然。设想下这样的场景：A用户发出了一个拉取个人收藏的请求，而然后退出了登录，并登录了B用户；由于网络关系，可能A用户的收藏请求是在B用户登录成功之后返回的，那么此时处理不好，就会导致窜数据的问题。</li><li><strong>存储层</strong>：存储层的设计，也需要根据登录的需求，保证高效、安全、隔离。后面两个比较好理解，高效？不是所有存储层都应该高效么？是这样没错，我们当然希望存储越高效越好，甚至其他特性也是越强大越好，但明显是不符合实际情况的，任何设计都需要考虑优先级。有些功能，比如活动列表，高效并非是第一优先级。而登录将高效放在第一优先级，主要是考虑到App启动之后，就需要进行登录态的判断，如果登录态的存储不够高效，势必影响启动速度。</li><li><strong>网络</strong>：网络要求安全性、健壮性，并且还需要考虑弱网情况的下异常处理。</li><li><strong>多线程</strong>：一般登录功能包含了多次加解密过程，为了登录功能的高效，我们可能希望将其放到一个独立的线程，或者多线程上去执行，这时候需要考虑多线程的设计，以及在此之上延伸出来的数据安全和锁的问题。</li></ul><ol start="4"><li><strong>Token设计</strong>：为了安全的考虑，客户端不可能存储用户的任何加密加签的密码，而是使用具有生命周期的Token来替代，所以需要跟后台一起设计Token的机制。</li></ol><h3 id="1-1-2-实现思维"><a href="#1-1-2-实现思维" class="headerlink" title="1.1.2 实现思维"></a>1.1.2 实现思维</h3><p>完成设计之后，是否就可以直接Coding 了呢？理论上是可以的，但实现过程并非大家想象的一样可以无脑码代码。在具体编码前，还需要多种知识体系支撑的，已指导编码实现的思维，进而指导代码实现。如下图：</p><p><img src="/images/transition/imp.png" alt="实现思维"></p><ol><li><p><strong>设计模式</strong>：在动手Coding之前，我们一般会思考，是否有合适的设计模式可以使用。如一般的登录流程可能包含了多个步骤：密码验证、图形验证码、OTP验证码、Token交换等，我们可以考虑使用责任链的设计模式。</p></li><li><p><strong>OOP五大原则（SOLID）&#x2F;设计模式六大原则</strong>：在我们编写一个类、或者一个方法时，我们需要遵循SOLID原则，以保证代码模块的清晰、高效、松耦合和易于理解。</p></li><li><p><strong>重构</strong>：在编写详细的逻辑代码时，经常会增删类、接口、方法等，此时灵活使用《重构》里面的方法，保证代码逻辑的清晰，就显得特别重要。</p></li></ol><p>从上面的例子，大家应该能够很好地理解，如何运用自身技术知识体系，解构一个普通的登录功能。当然，这个例子并不全面，还有很多细节需要考虑，限于篇幅，我这边做了简化。</p><br><h1 id="2-跃迁方法"><a href="#2-跃迁方法" class="headerlink" title="2. 跃迁方法"></a>2. 跃迁方法</h1><p>上一章节，大家了解了跃迁其实就是构建个人的技术知识体系。本章节，想跟大家聊聊个人总结的跃迁的方法：持续学习基础知识体系和平台知识体系，再通过不断地经验总结织网，完成技术知识体系的搭建。</p><h2 id="2-1-基础知识体系"><a href="#2-1-基础知识体系" class="headerlink" title="2.1 基础知识体系"></a>2.1 基础知识体系</h2><p>如果大学是计算机相关专业的程序员，那么大学学习的大部分课程，都是跃迁所需的基础知识体系。下表是列举的是一般软件开发工程师所需的基础知识，而目标列则是想要三年跃迁为单领域专家必要条件。</p><table><thead><tr><th>知识点</th><th>目标</th></tr></thead><tbody><tr><td>计算机基础&#x2F;操作系统</td><td>了解计算机是怎么运作的</td></tr><tr><td>网络</td><td>HTTP1.1&#x2F;HTTP2.0&#x2F;HTTPS、TCP&#x2F;IP、TLS</td></tr><tr><td>算法</td><td>会计算时间&#x2F;空间复杂度</td></tr><tr><td>数据结构</td><td>掌握List、Set、Map、Stack、Tree</td></tr><tr><td>存储</td><td>File、数据库等各项操作开销</td></tr><tr><td>多线程</td><td>线程开销、线程池、锁</td></tr><tr><td>架构设计</td><td>基础的架构设计模式</td></tr><tr><td>编程</td><td>掌握常用设计原则、设计模式和重构方法</td></tr></tbody></table><p>上表中，除了“架构设计”这一项不涵盖在大学课程里，其他几项基本都是大学课程知识。接下来，我会一一做简单分析，基础扎实的同学可以略过。</p><ol><li><p><strong>计算机基础&#x2F;操作系统</strong>：在量子计算机真正面世应用之前，我们现在绝大部分计算机都是冯诺依曼结构。了解操作系统，了解计算机运行的机制，包括CPU（流水线、多线程、锁）、内存（虚存、物理地址、虚拟地址）、IO等等，能够让我们了解自己开发的程序运行的基本原理和机制，从而写出高效的代码，同时还能帮助快速定位问题。比如iOS开发工程师，了解iOS操作系统，对启动性能优化很有帮助。</p></li><li><p><strong>网络</strong>：在互联网时代，一个程序员不了解网络，跟厨子不懂火候、戏子不懂台词没什么区别。现在不连入网络的应用寥寥无几，每个接入网络的应用，为满足可靠性，都需要考虑网络延迟、安全等问题，所以网络基础知识是非常重要的。</p></li><li><p><strong>算法</strong>：AI的发展，让算法的应用更为广泛而流行起来。虽然现在硬件发展迅速，平台API封装的算法足够高效，需要我们实现特殊算法的状况越来越少，但基本的时间空间复杂度还是需要掌握的，不然很可能有合适的算法而不会用，导致程序执行效率低。</p></li><li><p><strong>数据结构</strong>：在一般的编程领域，数据结构的重要性比算法要高。一个很主要的原因是，数据结构在编码过程中无处不在。所以掌握常用的数据结构，知道每个数据结构的适用场景，以及在平台上的特性，如线程安全等，是非常重要的。</p></li><li><p><strong>存储</strong>：我们常用的存储（IO）系统包括了文件系统和数据库系统，当然数据库的最终落地也是以文件的形式存在的，但为简化模型，此处文件系统特指除数据库以外的文件系统。只要信息需要持久化，我们就需要用到存储系统，其重要性不言而喻。其中，重点是需要了解存储系统各种操作的开销。比如文件系统，如果要拷贝一个文件，软链接、硬链接的开销要比物理拷贝要小很多；比如数据库增加索引，会导致更新操作的额外开销等。</p></li><li><p><strong>多线程</strong>：多线程是编程中一个重要的知识点，也是很多程序员需要花比较长时间迈过去的一个坎。当然，现在各端流行框架基本上会把复杂性进行封装，包括多线程，所以在是使用框架进行开发时，不需要多线程的知识也能够完成开发任务。但我们想要的并非只是会用，想要跃迁，掌握线程的开销、线程池&#x2F;线程队列和锁是必须的。</p></li><li><p><strong>架构设计</strong>：架构设计是唯一不在大学课本上基础知识，因为没有实践，教了也没用。大部分程序员，初接触架构都是学习各端平台框架上最流行最简单的架构设计模型，如MVC、MVP、MVVM等；而后慢慢接触到分层架构模式、事件驱动架构模式、微服务架构模式等；最终才会系统地学习什么是架构，进行架构设计的方法论。我认为，一个合格的领域专家，也应该是这个领域合格的架构师。</p></li><li><p><strong>编程</strong>：编程，掌握几门不同类型编程语言（编译型、解释型、动态、静态等）是基础，在此基础上，还需掌握通用的编程技能。比如前面例子中说的SOLID设计原则、软件设计模式（GOF）以及常见的重构方法。上个例子中已经说明。</p></li></ol><h2 id="2-2-平台知识体系"><a href="#2-2-平台知识体系" class="headerlink" title="2.2 平台知识体系"></a>2.2 平台知识体系</h2><p>前面说到，基础知识体系是大学时的课程，那么平台知识体系则大部分来源于工作中的项目实战。在讨论如何积累平台知识体系之前，大家须先理解，什么是平台知识体系；而要想理解平台知识体系，需要了先解什么是平台。</p><h3 id="2-2-1-平台定义"><a href="#2-2-1-平台定义" class="headerlink" title="2.2.1 平台定义"></a>2.2.1 平台定义</h3><p>在本文定义的平台，跟计算机中定义的系统平台比较类似。在计算机中，系统平台的定义是：指在计算机里让软件运行的系统环境，包括硬件环境和软件环境。而本文平台的定义稍微狭宽泛一点：是指支持特定软件运行的相关环境，包括开发环境、软件环境和硬件环境。</p><p>假如你是一名Android开发工程师，对应的平台就是：</p><ul><li>开发环境：JAVA、Kotlin、Android Studio、Gradle、Git、LeakCanary等</li><li>软件环境：Dalvik、Android Framework、Linux等</li><li>硬件环境：屏幕（分辨率、DPI）、内存、不同手机的特性；</li></ul><p>理解了平台的定义之后，就不难理解平台知识体系了。</p><h3 id="2-2-2-平台知识体系思维图"><a href="#2-2-2-平台知识体系思维图" class="headerlink" title="2.2.2 平台知识体系思维图"></a>2.2.2 平台知识体系思维图</h3><p>平台知识体系就是基于平台进行开发所需的知识的系统集合。</p><p>以下是个人总结的平台知识体系的思维图。虽然每个平台自己的差异，但总结下来，平台知识体系大体可以按下图来划分。</p><p><img src="/images/transition/platform.png" alt="平台知识体系思维图"></p><ol><li><p><strong>编程语言</strong>：即平台相关语言，如Android平台是Java、Kotlin；Java后端则是Java等等；</p></li><li><p><strong>平台库API</strong>：即平台提供的API，如Android平台有Android的相关库和API，H5前端HTML、CSS、Javascript等的Web API。</p></li><li><p><strong>架构模式&#x2F;框架</strong>：平台一般会提供开发框架或常用的架构模式，如Apple官方推荐的iOS开发的MVC架构、Java后端的Spring框架；</p></li><li><p><strong>系统内核</strong>：应用软件都需要运行在操作系统上，而学习系统内核运行机制，能够帮助我们更好地理解程序底层运行的机制。如上一章所说的，iOS开发工程师学习iOS的系统内核，能够更好的理解iOS App的启动运行原理。而这对于Android开发更常见，有时候一些系统Bug，需要对系统内核有深入的认识，才能规避或者解决。</p></li><li><p><strong>关联系统</strong>：所谓关联系统，即是与程序有交互的其他进程或系统，如App里面的Push系统，后端开发常见的Web服务器、容器、数据库等。</p></li><li><p><strong>开发工具</strong>：就是前面所说的开发环境，主要包括了IDE、VCS代码版本控制系统、包管理、调试工具等。</p></li><li><p><strong>性能</strong>：不同的平台有不同的性能要求，如App开发会比较多考虑内存、CPU、IO、网络等比较孤立的项，而后端开发会考虑负载均衡、TPS等比较具规模的项；</p></li><li><p><strong>安全</strong>：不同的平台，安全性和安全措施都不一样。后端主要须保护服务器，防止被入侵和攻击，常用的安全措施是防火墙、防止被注入等；而App端安全性要求相对来说没那么高，主要是需要保护本地逻辑和小部分敏感数据。</p></li><li><p><strong>构建及发布</strong>：开发完成的程序想要运行在平台上的必经步骤。</p></li></ol><p>这些知识类型，大家都应该很熟悉。你可以一一对应自我评估下，看看自己各方面的水平如何。</p><h3 id="2-2-3-如何构建平台知识体系"><a href="#2-2-3-如何构建平台知识体系" class="headerlink" title="2.2.3 如何构建平台知识体系"></a>2.2.3 如何构建平台知识体系</h3><p>对平台知识体系有了大体的认识之后，你可能会疑惑，那么多知识类型，我应该怎么来学习呢？这个问题不止困扰你，同时也困扰了无数的程序员们，所以这些踩过坑的前辈们就制定了许多的学习路线图，也就是Roadmap，帮助后面的同学，按照这个学习就行了。</p><p>下面两张图分别是Web前端开发的Roadmap和iOS开发的Roadmap，供各位参考。</p><p><img src="/images/transition/fe_roadmap.png" alt="Web前端开发 Roadmap"></p><p>Web前端开发 Roadmap(图片来源于 <a href="https://codeburst.io/the-2018-web-developer-roadmap-826b1b806e8d">The 2018 Web Developer Roadmap</a>)</p><p><img src="/images/transition/ios_roadmap.png" alt="iOS开发 Roadmap"><br>iOS开发 Roadmap (图片来源于<a href="https://github.com/BohdanOrlov/iOS-Developer-Roadmap">The 2018 Web Developer Roadmap</a>)</p><p>那如何按照Roadmap来渐进式学习，以达到技术跃迁呢？总结有四点：</p><ol><li><p><strong>选择合适的Roadmap，制定规划</strong>。网络上的信息是爆炸式的，每个人的学习路线也是不一样，所以导致，在不同端不同平台有非常多的Roadmap，哪个合适你呢？我的建议是，你可以向你的导师、Leader，或者团队内的牛人寻求帮助，让他帮你选择好Roadmap，并规划好学习的计划。这样有两个好处：一是他们的经验丰富，了解你的自身情况，更能帮助你选择合适的Roadmap；二是他们选择的Roadmap一般也是他们自己认可并赞成的，很可能跟他们的技术栈是比较契合的，能够给你更深入的指导。</p></li><li><p><strong>刻意进行系统性总结和思考</strong>。大家应该都听说过一万小时定律，其中很重要的点是，练习需要有目标、专注、有反馈及走出舒适区的刻意练习。Roadmap的学习也是类似的。由于Roadmap包含了很多知识点，所以新手可能会遇到学习不全面，不扎实等问题，这就需要你定期停下来进行系统性总结和思考，这些总结和思考最好能够形成博文、分享课程等，能及时收获反馈，增强学习的积极性。</p></li><li><p><strong>优先深度</strong>：很多人为了贪快或贪全，就好像是打卡一样，草草看了几篇技术文章之后，就觉得自己掌握了某项技术，这是很不可取的。知识点的学习，最重要的是深度。优先深度，不仅学习知识点比较扎实，最重要的是学习效率高，这可能违背了很多人的直觉。举个例子，假如你需要挖一个直径10米、深10米的大坑，你会怎么做？假如你是画一个十米的圆，然后在每个点均匀的往下挖，那么你每个点做功都是一样的；还有另外一个选择，先挖一个10米深的坑，然后在中间或底部开始往四周挖，你会发现挖一点就泥沙俱下，比每一个点均匀做功往下挖要省时省力。技术知识的学习也是一样的，因为知识点之间并非孤立的，而是连结的，比如网络的知识，又会连结安全、性能和关联系统等知识点。深入学习了一个知识点，学习其他知识点的时候，就能够与之前深入理解的知识点进行印证思考，并建立连结。说句题外话，假如面试过程中，应聘者对某些知识点有深入理解，是非常重要的亮点。</p></li><li><p><strong>织网</strong>：上一节已经说了，知识点并非孤立的，织网才能让你的平台知识体系更完整。随着你知识的增长，织网是非常自然而然的，但也是最难的一环。因为连结并非是一个简单的事情，就算你已经深入理解了两个知识点，但如果没有合适的实战和深入的思索，你可能永远不会发现他们之间的特殊的连结。</p></li></ol><h2 id="2-3-沟通交流"><a href="#2-3-沟通交流" class="headerlink" title="2.3 沟通交流"></a>2.3 沟通交流</h2><p>大家可能比较奇怪，技术跃迁跟沟通交流有什么关系？</p><p>大家应该都接受过这样一个理念：沟通很重要。但实际上大部分人不太明白沟通的重要性在哪。可能工作了几年的同学感触会比较深，而如果是学生，基本不会有什么概念，因为在学校这样的关系纯粹的象牙塔里，沟通能产生的影响微乎极微。工作越长的同学越能深刻理解沟通在职场上的重要性。同一批大学生进入到同一个公司，负责同一个项目，假如大家的天分一样的话，沟通很可能是造成几年后分化的最重要因素。其实道理很简单，你的沟通能力越好，你获得的机会就会越多，也会越好，最终导致你成长越快，成就越大。 </p><p>作为程序员，在职场上的沟通主要分以下几个方面：</p><ol><li><p><strong>对上（直线Leader）沟通</strong>：很明显，对上沟通是最重要的。不仅仅是因为他是你的年终重要考核人，而且他一般还是团队内比较优秀的人，更重要的是他最了解团队目标（KPI）的人，也掌握着工作资源分配权力。因此，如果能够与上级形成非常良好的沟通，那么，你会知道团队的目标是什么，确定努力的正确方向，少走弯路；你还能够获得团队优秀人员（你的Leader）的指导，有了好的学习模范；并通过自己的主动和努力，去获得更多的资源支持；最后，你还能够通过沟通，增进与Leader的相互了解，Leader了解了你的贡献，你也了解了Leader对你的期望和满意程度，从而大大降低了年底考核与预期出入太大的概率。</p></li><li><p><strong>对内（程序员之间）沟通</strong>：团队内部，与程序员的沟通也是非常重要的。在我个人的技术成长道路上，跟同事或者其他程序员之间的沟通，让我受益良多。通过跟团队内其他程序员的交流、讨论，甚至争论，我发现了很多我不知道的知识点，这个越在初期越明显。慢慢的，我成为了一个有经验的，或者说有成见的程序员，这时每次与其他程序员讨论之后，我都会反思，自己的观点是否是错的，为什么他是这个观点看问题的，然后我会去尝试从对方的角度来思考问题，甚至去实际操作一遍，对比优劣，总结，然后提升。所以，与团队内其他程序员保持良好而有效的沟通，也许是你能够最容易获得的最长久有效的跃迁资源。</p></li><li><p><strong>对外（产品经理、项目经理、测试、设计等）沟通</strong>：当你成为一个熟手，你应该已经融入在项目里面，此时，你的工作也跳出了一个纯程序员做的事情——写代码，一般你会参与需求评审、设计评审、接口协议评审、测试用例评审、ShowCase等繁杂的流程，此时，建立一个良好的沟通渠道，能够达到事半功倍的效果，让项目高效运行。我们常说的敏捷的工作模式，其中提升沟通饱和度就是一个很重要的点。跟业务&#x2F;产品经理多沟通，可以培养你主人翁的意识，也就是说你是在切实关注业务产品的。而且有良好的沟通的话，能够形成良好的推动力，让你实现需求更加高效。如果一开始不理解需求，也不沟通或者沟通不充分，做出来的东西可能就会有错漏；但如果一开始就沟通充分，你出错的概率就大大降低；或者有持续沟通的机制，你的错误也能够及时的改正过来。跟测试沟通，你会了解你团队的质量状况，或者一些常见的bug，这样可以有效提升你的代码质量。跟项目管理沟通，让你了解项目的流程，帮助你做好工作规划等。</p></li></ol><p>上面说了沟通的重要性，那如何来做好沟通交流呢？由于本人在这方面并不太专业，无法系统讲解，只能给些个人的建议：</p><ul><li><strong>主动最重要</strong>：沟通是相互的，总有一个人需要先主动，你是那个主动的人么？</li><li><strong>空杯心态</strong>：多倾听，多反思，不要只听得见你想听的。而且沟通的目标是找到问题的最优解，而不是为了说服对方；</li><li><strong>日常多交流</strong>：沟通其实是一个持续的过程，请重视与每个人日常关系处理，因为这很可能会影响到你们的下次沟通；</li><li><strong>有原则，懂妥协</strong>：在每一次沟通中，保持底线，让人知道你是个有原则的人，能够提升下次的沟通效率。而懂的妥协，则是为了双赢的目标而努力，也为下一次沟通奠定基础。</li></ul><p>沟通是重要的，但要成长也不是单一因素所能决定的；而且职场上，大部分人的情商和沟通技巧其实没有太大的差别，主动性反而变得比较重要。与各种角色建立良好的沟通关系，确实能够让你的跃迁道路上走得更快，但绝不是让你成为交际花，或者成为圆滑世故而没有原则的人。沟通很重要，但也不要妖魔化了。</p><h2 id="2-4-经验总结"><a href="#2-4-经验总结" class="headerlink" title="2.4 经验总结"></a>2.4 经验总结</h2><p>跃迁的道路，跟游戏升级没什么区别，也是需要经验积累的，然后再总结过往的经验，不断夯实自己的技术知识体系。很多熟手，难以跃迁成为一个技术专家，很重要的原因，就是缺少经验总结的环节，导致无法搭建完整的、有深度的知识体系。</p><p>我们先来做个评测，请看以下情景：</p><ul><li>作为应聘者参加面试，对面试官的问题都能说上一部分，但问细问深就不知道怎么答了。</li><li>看一些分享讲座，你觉得讲师说的大部分你都懂，但你做分享的时候却又不知从何说起。</li><li>你掌握很多解决问题的方法，但一谈到根本原因、内在机制的时候，你却一头雾水。</li><li>需要实现相似功能时候，你习惯复制代码，而不是思考如何提炼重构。</li></ul><p>如果上述情景，你符合两条或以上，那么你应该是很少总结，个人的技术知识体系是比较薄弱的。</p><p>经验总结，分两部分，经验和总结。经验，大部分是从工作实践中来，所以需要我们比别人更加积极主动，去争取更多的机会，从而获得更快的成长。当然，能力与责任是相辅相成的，能力越大责任越大。反之，能力不够，也很难获得好的机会。但积极主动，至少比能力相同的其他人要更容易获得机会。实践经验很重要，是因为没有实践经验支持而学习的知识，很可能只是空中楼阁，很快就会被遗忘。假如实在没有合适的实践机会，可以考虑做一些个人业余项目，也是非常好的锻炼机会。</p><p>而总结，则是在实践经验的基础上，进行织网，完善相关的技术知识。关于经验的总结，本人以个人成长经验，推荐我认为比较有效果的方式：</p><ol><li><p><strong>成体系地学习</strong>：由于移动互联网大爆炸，导致我们的阅读学习越来越碎片化，从而导致我们的知识也是碎片的，难以形成体系的知识结构。相比于每天看公众号上散乱的知识点，我更推荐大家结合工作需要和工作中遇到的问题，成体系地学习某个知识点。比如学习网络知识，可以先看《图解HTTP》、《图解TCP&#x2F;IP》，然后进阶看《HTTP权威指南》、《Web性能权威指南》，还想在深入，可以看《TCP_IP详解》的三卷。这里列举的是通过阅读书本来系统学习，现在在线教育发展飞速，如“极客时间”、“GitChat”等在IT在线教育平台上，也有很多优秀的成体系的课程，而且这些课程普遍有较强的实践指导性，通过这些课程学习也是很好的方式。在学习过程中，我个人的方法是绘制思维脑图来提炼总结知识点，从而形成网络知识体系巩固下来。有成体系的书本来帮你构建个人的知识体系，会事半功倍。而平时碎片化的有时效性的阅读，则用来填充知识网里的空隙，以及拓展个人视野。</p></li><li><p><strong>写博客（公众号、专栏）</strong>：很多同学经常遇到的问题是，认为已经掌握了某个知识点，但很可能你掌握的只是其中一小点，甚至可能只是知其然而不知其所以然。比如感觉学了《计算机网络》，了解了网络七层模型，会Network API组包拆包，就觉得掌握了网络知识；但却连HTTP协议报文结构都说不明白，更不用说HTTP请求经历了哪些网络往返阶段。而写博客，则是一个很好的总结提炼知识点的方式。当你需要说明清楚一个知识点时，你必然想要去了解内在的逻辑是什么，然后你接触越多，你就会越发现你懂得越少。比如我曾经写了篇关于怎么写界面的博客，其中谈到界面的优化，为了说清楚这个知识点，去查了很多资料，包括UIView与CALayer的关系，Offscreen Render的机制等。从而形成较完整的界面优化知识。当然，现在看看还是有很多可改进的空间。</p></li><li><p><strong>做分享演讲</strong>：这个方法的成效与写博客比较类似，都是需要将知识再整理，形成一套个人的知识体系后，让更多的人能够理解。不同点在于博客通过平面文字图像，而分享演讲则是通过文字图像声音，并且能够与分享的对象进行实时的沟通反馈，更有利于知识的传播交流。</p></li></ol><p>上述的三个方法，是我自己认为比较有效的经验积累的方式。三个方法与工作相结合，可以形成良好的有机循环：</p><ul><li>工作实践中需要的解决的问题，或者需要的技术储备，可以通过成体系地学习，掌握比较完整的知识点；</li><li>将这些知识点运用到工作中，解决实际问题，获得实战经验加成；</li><li>将经验和知识点串联，形成博客，或者做分享演讲，这是一个知识加工的过程，可以让你掌握的知识更加系统。</li></ul><br># 4. 跃迁规划 <p>为更好的完成技术跃迁，本章节为刚毕业的同学准备了一份跃迁规划，仅供参考。主要点在于构建平台知识体系，粗略分三阶段：</p><p><img src="/images/transition/my_transition_roadmap.png" alt="跃迁规划"></p><ol><li><p><strong>入门</strong>：入门大概需要半年的时间，该阶段主要需要完成心态上的转化：从一个学生角色转换成一位职员的角色。另外，还需要适应公司文化，学习团队开发过程中常用的系统、工具等。入门完成之后，应该可以完成基础功能的开发。</p></li><li><p><strong>熟练</strong>：熟练的阶段，也就是要锻炼成熟手的阶段，这个阶段大概需要两年。在这个阶段前期，主要学习编程语言初级特性、平台API、开发工具和关联系统，主要目的是为了能够高质高效地完成开发任务；而在熟练阶段后期，则需要学习所在平台的编程语言的高级特性，高级API，以及常用的架构模式和框架。熟练阶段不存在什么难度，只要保持积极主动、好学好问，勤于思考，基本能够达成。完成之后，应该可以独当一面，开发一个中型系统不在话下。</p></li><li><p><strong>进阶</strong>：进阶，也就是为最后的跃迁做准备的阶段。该阶段需要学习系统内核、平台性能和安全、以及构建发布等相关知识，拼上平台知识体系最后一块拼图。图上画的是半年，但实际情况因人而异，有些同学进展缓慢，主要的原因可能是受限于项目团队规模，无法获得良好的技术指导和实践经验，此时需要多发挥主观能动性，积极发掘项目中可改进和实践的点，或者启动个人项目，进行实践。</p></li></ol><p>而其余两点，构建基础知识体系和经验总结，则是一个持续学习、总结的过程，此处不展开讲。</p><br>## 5. 结语<p>非常感谢你耐着性子，阅读到了这里，相信你一定有所收获，而这也是我写下这篇文字最大的期许。曾经年少时，好为人师，跟没小几岁的后辈大谈人生道理，历数惨痛教训，以为他必鉴往知来，前程一片坦途；后面慢慢明白，所谓的良苦用心，还不如让他碰上几块墙壁，跌上几个跟头。等你明白了舍身取义，你自然会回来跟我唱这首歌的。</p><p>当我们从婴儿，成长为少年、青年，我们一直都在蓬勃向上成长；慢慢的，我们的身体成长转而停滞，而此时知识、阅历还会继续不断成长壮大，建筑我们强大的内心。能感受成长，是一件很美好的事情。我相信，不管任何阶段，任何年龄，只要你坚持主动学习、思考，成长和跃迁是非常自然的事情。</p><blockquote><p>原作者：jaminzzhang</p><p>原文链接：<a href="http://oncenote.com/2018/12/25/Transition/">http://oncenote.com/2018/12/25/Transition/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;前言：近期又到了毕业招聘季，我作为技术分享嘉宾，回到母校参加宣讲会，做了一个主题为《如何在毕业三年完成技术跃迁》的分享，本文由此次分享整理而成，并改名为《如何完成技术跃迁》，希望能够给刚进入职场的程序员，或者卡在瓶颈期的程序员，带来一些指导，在技术的道路上少走些弯路。请注意，本文源于我的经验思考，非教条或准则，仅供参考。另由于本人主要的项目经验来源于App端（主要是iOS、Android），Web前端及后端只是稍有涉猎，因此文中的例子大多也来自App端，其他端同学可能会觉得陌生，但应该不会影响理解。&lt;/p&gt;
&lt;p&gt;本文约1W字，阅读时长大概二十分钟，稍有啰嗦，请见谅。 &lt;/p&gt;
&lt;h1 id=&quot;1-什么是技术跃迁&quot;&gt;&lt;a href=&quot;#1-什么是技术跃迁&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是技术跃迁&quot;&gt;&lt;/a&gt;1. 什么是技术跃迁&lt;/h1&gt;&lt;p&gt;首先，我们需要明确一个定义，什么是技术跃迁？在说技术跃迁之前，跟大家解释下跃迁这个词。&lt;/p&gt;
&lt;p&gt;”跃迁“，来源于量子力学，说的是微观状态发生跳跃式变化的过程，比如从低能态跳跃到高能态，需要注意的是：因为微观粒子的状态是分立的，也即是非连续性的，所以这个变化是跳跃性的。用这个词来说明技术的成长，个人认为是非常合适的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础介绍</title>
    <link href="https://zycslog.github.io/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/"/>
    <id>https://zycslog.github.io/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/</id>
    <published>2022-04-30T06:35:13.796Z</published>
    <updated>2022-04-30T07:45:05.377Z</updated>
    
    <content type="html"><![CDATA[<p><strong>机器学习是一门从数据中提取知识的技术。</strong> 它是统计学、人工智能和计算机科学的交叉研究领域，被常被称为<strong>预测分析</strong>、<strong>统计学习</strong>。机器学习方法的应用近年来在日常生活中无处不在。从自动推荐看哪部电影、点什么食物或买什么东西，到个性化的在线收音机、智能化在线教育，再到从照片中找到你的朋友等等需要现代网站和设备的核心都是机器学习算法。当你查看例如Facebook、Amazon、Netflix、Weibo、Twitter等复杂网站时，很可能网站的每个部分都包含了多个机器学习模型。</p><p>除了商业应用之外，机器学习已经对数据驱动的研究方式产生了巨大的影响。机器学习相关的技术、工具已经应用于各种科学问题，例如理解恒星、发现遥远的行星、发现新的粒子、分析DNA序列以及提供个性化的癌症治疗等。</p><p>但是，为了从机器学习中获益，你的应用程序可能并不需要大规模。在本部分，将解释为什么机器学习变的如此的流行，并讨论使用机器学习可以解决哪些问题。然后，将展示如何构建你的第一个机器学习模型等。</p><h2 id="为什么是机器学习？"><a href="#为什么是机器学习？" class="headerlink" title="为什么是机器学习？"></a>为什么是机器学习？</h2><p>较早期的“智能”应用程序，许多的系统使用“if”和“else”硬编码规则来处理数据或者根据用户的输入进行调整。想象一个垃圾邮件过滤器，其工作是适当的移动电子邮件到垃圾邮件文件夹。你可以构造一个垃圾邮件词库黑名单，并返回垃圾邮件标记 <em>1</em>。这是一个使用专家设计的规则来实现“智能”应用程序的例子。手工创建决策规则对于一些应用程序是可行的，特别是那些人类对建模过程有很好理解的应用程序，然而，使用手工编码的规则进行决策有两点主要缺点：</p><ul><li>做出决策所需的规则逻辑是针对特定的单个域和任务的，一些业务改变，整个系统可能都需要重写；</li><li>设计规则需要深刻理解人类专家应该如何做出决定。</li></ul><span id="more"></span><p>这种编码方法失败的一个典型例子是检测图像中的人脸。如今，每个智能手机都能在图像中检测出人脸，然而，这项技术直到2001年，面部检测才有了进展。这项技术之前面临的主要问题是，像素被计算机“感知”的方式与人类感知面部的方式非常不同，这种表现上的差异使得人类基本不可能想出一套好的规则来描述数字图像中人脸的构成。</p><p>然而，使用机器学习，仅仅呈现具有大量面部图像的程序就足以让算法确定识别面部需要什么特征。</p><h2 id="机器学习能解决的问题"><a href="#机器学习能解决的问题" class="headerlink" title="机器学习能解决的问题"></a>机器学习能解决的问题</h2><p>最成功的机器学习算法是那些通过从已知例子中归纳出来使决策过程自动化的算法。在称为<strong>监督学习</strong>的设定中，用户向算法提供一对输入和期望的输出，算法会自动找到一种方法，在给定输入的情况下产生期望的输出。特别地，这种算法能够在没有人帮助的情况下为它以前从未遇见的输入创建输出。例如上述垃圾邮件分类的示例，使用机器学习，用户向算法提供大量历史电子邮件（输入），以及关于这些电子邮件中是否有垃圾邮件的信息（期望的输出），算法变回找到一种分别是否为垃圾邮件的方法，当给定一个新的电子邮件，该算法将产生一个关于新邮件是否是垃圾邮件的预测输出。</p><p>从输入&#x2F;输出对中学习的机器学习算法被称为<strong>监督学习</strong>算法，因为“教师”以他们学习的每个示例的期望输出向算法提供监督。虽然创建输入和输出的数据集常常是费时费力的手工过程，但是对于受监督的学习算法来说，却是易于理解的，并且它们的性能易于测量。如果你的应用程序可以被描述为受监督的学习问题，并且你能够创建包含所需结果的数据集，则机器学习可能能够解决你的问题。</p><p>有监督的机器学习任务示例包括但不限于如下几种：</p><ul><li><em>从信封上手写的数字中识别邮政编码</em></li></ul><p>这里的输入是手写数字的扫描，所需的输出时邮政编码中的实际数字。要创建用于构建机器学习模型的数据集，需要收集需要的信封。然后可以自己读取邮政编码，并将数字存储为你想要的结果。</p><ul><li><em>基于医学图像判断肿瘤是否良性</em></li></ul><p>这的输入是图像，输出时肿瘤是否良性。要创建用于构建模型的数据集，需要一个医学图像数据库，还需要专家的意见，所以需要查看所有的图像，并决定哪些肿瘤是良性的，哪些不是，甚至可能需要做出超出图像内容的附加诊断，以确定图像中的肿瘤是否是癌性的。</p><ul><li><em>信用卡交易中欺诈行为的侦测</em></li></ul><p>这里的输入是信用卡交易的记录，输出是该交易是否可能欺诈。假设你是分发信用卡的金融机构，收集数据意味着需要存储所有的交易事务，并且如果出现欺诈的事务，需要进行记录。</p><p>以上示例需要注意的一件有趣的事情是，尽管输入和输出看起来都非常简单，易于理解，但是这三个任务的数据收集过程却大不相同。虽然阅读信封是费力的，但是却是容易和廉价的；另一方面，获得医学成像和诊断不仅需要昂贵的机器，而且需要稀有和昂贵的专家知识，更不用说伦理问题和隐私问题了；在检测信用卡欺诈的例子中，数据收集简单的多，你的客户会提供给你想要的输出，因为他们会报告欺诈行为，你必须要做的是获得欺诈性和非欺诈性的输入&#x2F;输出对。</p><p><strong>无监督算法</strong> 是另一种机器学习算法。在无监督学习中，只有输入数据是已知的，并且没有已知的输出数据被赋予算法。虽然这些方法有很多成功的应用，但他们通常难以理解和评估。</p><p>无监督学习的例子包括：</p><ul><li><em>在一组博客文章中识别主题</em></li></ul><p>如果你用大量的文本数据集合，你可能需要总结它们并找到其中的流行主题，你可能实现并不知道这些主题是什么，或者可能有多少主题，因此，没有已知的输出。</p><ul><li><em>将客户细分为具有相似偏好的群体</em></li></ul><p>给定一组客户记录，你可能希望识别哪些客户是相似的，以及是否具有相似的偏好。例如一个购物网站，客户可能是“父母”、“书虫”、“玩家”等，因为你事先不知道这些群体可能是什么，甚至不知道有多少群体，所以你没有已知的输出。</p><ul><li><em>检测网站的异常访问模式</em></li></ul><p>为了识别滥用和错误，找到与规范不同的访问模式通常对于网站来说是有益的。每个异常模式可能是非常不同的，并且你可能没有任何异常行为的记录实例，因为在这个例子中，你只能观察流量，并且你不知道什么构成了正常和异常的行为，所以这是一个无监督的问题。</p><p>对于有监督和无监督的学习任务，计算机能够理解的输入数据的表示是至关重要的，通常把数据看做表格是有帮助的。你想要推理的每个数据点（每个电子邮件、每个客户、每个事务）都是一行，描述该数据点（例如，客户的年龄或者事务的数量或者位置）的每个属性都是一列，你可以根据用户的年龄、性别、创建账号时间以及从网上购买的频率来描述用户，你可以通过每个像素的灰度值来描述肿瘤的图像，或者可以使用肿瘤的大小、形状和颜色等。</p><p>这里的每个实体或者行都称之为机器学习中的示例或数据点，而列（描述这些实体的属性）称之为特征。</p><h2 id="了解你的任务，认识你的数据"><a href="#了解你的任务，认识你的数据" class="headerlink" title="了解你的任务，认识你的数据"></a>了解你的任务，认识你的数据</h2><p>在机器学习过程中最重要的部分是理解你正在处理的数据以及这些数据与你想要解决的任务之间的关系。随机选择一个算法并把数据丢给算法通常是无效的，在开始构建模型之前，必须了解数据集中发生的事情。每个算法在什么样的数据和什么样的问题设置下的表现是不同的，当你正在构建一个机器学习解决方案时，首先你必须回答一下几个问题或者至少要记住一下几个问题：</p><ul><li>我想要解决什么样的问题？所收集的数据能回答这个问题吗？</li><li>将我的问题作为机器学习问题的最佳方式是什么？</li><li>我收集了足够的数据来表示我想解决的问题吗？</li><li>我提取了数据的哪些特征，这些特征会是正确的预测成为可能吗？</li><li>我如何衡量机器学习在我的应用程序中是成功的？</li><li>机器学习解决方案将如何与我的研究或商业产品的其他部分交互？</li></ul><p>在较大的场景中，机器学习中的算法和方法只是解决特定问题的的一小部分，并且始终要牢记全局。很多人花费大量的时间构建复杂的机器学习解决方案，结果却发现他们没有解决正确的问题。</p><p>当深入研究机器学习的技术时，很容易忽略最终的目标，虽然我们在这里不会详述这些问题，但是仍然鼓励在开始构建机器学习模型时，记住可能正在显示或者隐式做出的所有假设。</p><h2 id="为什么选择Python？"><a href="#为什么选择Python？" class="headerlink" title="为什么选择Python？"></a>为什么选择Python？</h2><p>Python语言已经成为了一种通用语言，能够处理很多应用的科学数据。它结合了通用编程语言的优势和易于在特定领域使用的特定脚本语言，如MATLAB或R。Python具有用于数据加载、可视化、统计、自然语言处理、图像处理等库，这个庞大的工具库为数据科学提供了大量的通用和专用的功能，使用python的主要优点之一是能够直接与代码进行交互，使用终端或者其他工具，例如<strong>Jupyter Notebook</strong>。机器学习和数据分析都是不断的迭代过程，也被称为数据驱动分析，因此对于这样的过程来说，有必要有一些快速迭代和易于交互的工具。</p><p>作为一种通用编程语言，Python还允许创建复杂的用户图形界面（GUI）和Web服务，以及集成到现有的系统中等。</p><h2 id="scikit-learn"><a href="#scikit-learn" class="headerlink" title="scikit-learn"></a>scikit-learn</h2><p><em>scikit-learn</em> 是一个开放的源码项目，这意味着它可以自由使用和开发，任何人都可以轻松获得其源代码，以及了解内部的核心。<em>scikit-learn</em> 项目在不断地被开发和改进，并且它有一个非常活跃的用户社区，包含许多先进的机器学习算法，以及关于每个算法的<a href="http://scikit-learn.org/stable/documentation">综合文档</a>。<em>scikit-learn</em> 是一个非常流行的工具，也是最著名的机器学习Python库，被广泛应用于工业和学术界，网路上有大量的教程和代码片段，<em>scikit-learn</em> 可以与其他Python工具一起工作。</p><p>在阅读本书时，建议你浏览<em>scikit-learn</em> 的<a href="http://scikit-learn.org/stable/user_guide.html">用户指南</a>和API文档，了解关于每个算法的更多细节和更多选项。在线文档非常全面，本书将为你提供机器学习中的所有先决条件，以详细了解它。</p><h2 id="安装-scikit-learn"><a href="#安装-scikit-learn" class="headerlink" title="安装 scikit-learn"></a>安装 scikit-learn</h2><p><em>scikit-learn</em> 依赖两个其他的Python库， <em>NumPy</em> 和 <em>SciPy</em>。为了绘图和交互开发，你还应该安装 <em>matplotlib</em>、<em>IPython</em> 和 <em>Jupyter Notebook</em>。这里建议你使用以下某一种Python环境管理工具：</p><p><strong><a href="https://store.continuum.io/cshop/anaconda/">Anaconda</a></strong></p><p>Python能够用于大规模数据处理、预测分析和科学计算，<em>Anaconda</em> 可与 <em>NumPy</em>、<em>SciPy</em>、<em>matplotlib</em>、<em>Pandas</em>、<em>IPython</em> 、<em>Jupyter Notebook</em>、<em>scikit-learn</em>一起工作，可以在Mac OS、Windows和Linux上安装，它是一个非常方便的集成解决方案，是我们没有进行科学安装Python经验的人的建议解决方案。</p><p><strong><a href="https://www.enthought.com/product/canopy/">Enthought Canopy</a></strong></p><p>另一种用于科学计算的集成Python管理工具，可与<em>NumPy</em>、<em>SciPy</em>、<em>matplotlib</em>、<em>Pandas</em>、<em>IPython</em> 一起工作，但是其免费版本不能与<em>scikit-learn</em>一起工作，如果需要使用<em>scikit-learn</em>则需要付费或者申请学术许可证，便可获得其免费访问付费订阅版本的Enthought Canopy，Enthought Canopy目前仅支持Python2.7.x，能够工作在Mac OS、Windows、Linux上。</p><p><strong><a href="http://python-xy.github.io/">Python(x,y)</a></strong></p><p>一个免费的Python管理工具，用于科学计算，特别是Windows上。<em>Python（X，Y）</em> 可与  <em>NumPy</em>、<em>SciPy</em>、<em>matplotlib</em>、<em>Pandas</em>、<em>IPython</em> 、<em>Jupyter Notebook</em>、<em>scikit-learn</em>一起工作。</p><p>如果你已经安装好了Python，也可以使用<strong>pip</strong>安装所有需要的包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy scipy matplotlib ipython scikit-learn pandas</span><br></pre></td></tr></table></figure><h2 id="基本库和工具"><a href="#基本库和工具" class="headerlink" title="基本库和工具"></a>基本库和工具</h2><p>了解了什么是 <em>scikit-learn</em> 以及如何使用它很重要，但是还有一些其他的类库可以提高使用体验。<em>scikit-learn</em> 是建立在 <em>NumPy</em> 和 <em>SciPy</em> 之上的，除了<em>NumPy</em> 和 <em>SciPy</em> ，我们还将使用 <em>Pandas</em>、<em>matplotlib</em> 以及 <em>Jupyter Notebook</em>，<em>Jupyter Notebook</em> 是一个基于浏览器的交互式编程环境，简言之，以下这些工具是应该了解的内容，以便能够在<em>scikit-learn</em> 的使用中获得更多的益处。</p><h3 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h3><p><em>Jupyter Notebook</em> 是一个基于浏览器的交互式编程环境。它是进行探索性数据分析的一个很好的工具，被数据科学家广泛的使用。虽然 <em>Jupyter Notebook</em> 支持需要的编程语言，但是我们只需要Python支持即可。<em>Jupyter Notebook</em> 使得合并代码、文本和图像变的很容易，而且这本书实际上是在 <em>Jupyter Notebook</em> 中编写的。</p><h3 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h3><p><em>NumPy</em> 是Python中科学计算的基本包之一，它包含多维数组的功能、高级数学函数，如线性代数和傅里叶变换，以及随机数发生器等等。</p><p>在 <em>scikit-learn</em> 中，<em>NumPy</em> 数组是基本的额数据结构，<em>scikit-learn</em> 以 <em>NumPy</em> 数组的形式获取数据，你所使用的任何数据都必须转换为 <em>NumPy</em> 数组。<em>NumPy</em> 的核心功能是 <strong>ndarray</strong> 类，一个多维数组结构，数组中的所有元素必须是相同类型的，一个<em>NumPy</em>数组看起来是如下样子的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x))</span><br></pre></td></tr></table></figure><pre><code>x:[[1 2 3] [4 5 6]]</code></pre><p>在本书中，将多次使用<em>NumPy</em>，我们将把<em>NumPy</em> 的 <strong>ndarray</strong> 类的对象称为 “NumPy 数组” 或仅仅是 “数组”。</p><h3 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h3><p><em>SciPy</em> 是Python中的科学计算功能的集合，它提供了高级线性代数程序、数学函数优化、信号处理、特殊数学函数和统计分析功能等，<em>scikit-learn</em> 从 <em>SciPy</em> 的功能集合中提取用于实现其算法的功能。<em>SciPy</em> 对于我们来说最重要的部分是 <strong>scipy.sparse</strong>，它提供了稀疏矩阵的运算，这是<em>scikit-learn</em>中用于数据的另一种表示，每当我们想要存储一个包含零点的二维数组时，便于使用稀疏矩阵，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个具有对角线的2D NumPy数组，并且在其他任何地方创建零点</span></span><br><span class="line">eye = np.eye(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;NumPy array: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(eye))</span><br></pre></td></tr></table></figure><pre><code>NumPy array: [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将NUMPY数组转换成CSR格式中的一个SISPY稀疏矩阵。</span></span><br><span class="line"><span class="comment"># 仅存储非零项</span></span><br><span class="line"></span><br><span class="line">sparse_matrix = sparse.csr_matrix(eye)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nSciPy sparse CSR matrix:\n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(sparse_matrix))</span><br></pre></td></tr></table></figure><pre><code>SciPy sparse CSR matrix:  (0, 0)1.0  (1, 1)1.0  (2, 2)1.0  (3, 3)1.0</code></pre><p>通常不可能创建稀疏数据的密集表示（因为它们不适合于内存），所以我们需要直接创建稀疏表示。下面是使用COO格式创建与以前一样的稀疏矩阵的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = np.ones(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">row_indices = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;row_indices: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(row_indices))</span><br><span class="line">col_indices = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;col_indices: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(col_indices))</span><br><span class="line">eye_coo = sparse.coo_matrix((data, (row_indices, col_indices)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;eye_coo: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(eye_coo))</span><br></pre></td></tr></table></figure><pre><code>data: [1. 1. 1. 1.]row_indices: [0 1 2 3]col_indices: [0 1 2 3]eye_coo:   (0, 0)1.0  (1, 1)1.0  (2, 2)1.0  (3, 3)1.0</code></pre><p><em>SciPy</em> 稀疏矩阵的更多细节可以在<a href="http://www.scipy-lectures.org/">SciPy讲义</a>中找到。</p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p><em>matplotlib</em> 是Python的主要科学绘图库，它提供了用于制作高质量可视化的功能，如线形图、直方图、散点图等。可视化数据和分析的不同在于可视化可以给你提供更加直观的数据理解。我们使用<em>matplotlib</em> 进行所有的可视化，在 <em>Jupyter Notebook</em> 中工作时，可以使用 <em>%matplotlib notebook</em> 和 <em>%matplotlib inline</em> 在浏览器中直接使用可视化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate a sequence of numbers from -10 to 10 with 100 steps in between</span></span><br><span class="line">x = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># Create a second array using sine</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line"><span class="comment"># The plot function makes a line chart of one array against another</span></span><br><span class="line">plt.plot(x, y, marker = <span class="string">&#x27;x&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>[&lt;matplotlib.lines.Line2D at 0x111be57b8&gt;]</code></pre><p><img src="/images/Introduction_Of_Machine_Learning/output_18_1.png" alt="png"></p><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p><em>pandas</em> 是一个用于数据处理和分析的Python库，它围绕了一个叫做<strong>DataFrame</strong>的数据结构进行构建。简单的说，<em>pandas</em> 数据文件是一个表，类似于Excel电子表格，<em>pandas</em> 提供了大量的方法来修改和操作这个表，特别是，<em>pandas</em> 允许类似SQL的查询和连接。与 <em>NumPy</em> 不同，要求数组中的所有条目都具有相同的类型，<em>pandas</em> 允许每个列具有单独的类型（例如整数、日期、浮点数和字符串）。<em>pandas</em> 提供的另一个有价值的工具是它能够从各种文件格式和数据库中获取信息，如SQL、Excel文件和逗号分隔值（CSV）文件等。详细介绍<em>pandas</em> 的功能不再本书的范围之内，然而Wes McKinney (O’Reilly, 2012)的<a href="http://shop.oreilly.com/product/0636920023784.do">Python数据分析</a>提供了一个很好的指南。下面是使用字典数据创建数据文件的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a simple dataset of people</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>, <span class="string">&#x27;Peter&#x27;</span>, <span class="string">&#x27;Linda&#x27;</span>],</span><br><span class="line">       <span class="string">&#x27;Location&#x27;</span>:[<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>, <span class="string">&#x27;Berlin&#x27;</span>, <span class="string">&#x27;London&#x27;</span>],</span><br><span class="line">       <span class="string">&#x27;Age&#x27;</span>:[<span class="number">24</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">33</span>]&#125;</span><br><span class="line"></span><br><span class="line">data_pandas = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># IPython.display allows &quot;pretty printing&quot; of dataframes </span></span><br><span class="line"><span class="comment"># in the Jupyter notebook</span></span><br><span class="line">display(data_pandas)</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Name</th>      <th>Location</th>      <th>Age</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>John</td>      <td>New York</td>      <td>24</td>    </tr>    <tr>      <th>1</th>      <td>Anna</td>      <td>Paris</td>      <td>14</td>    </tr>    <tr>      <th>2</th>      <td>Peter</td>      <td>Berlin</td>      <td>53</td>    </tr>    <tr>      <th>3</th>      <td>Linda</td>      <td>London</td>      <td>33</td>    </tr>  </tbody></table></div><p>查询此表有几种可能的方式。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select all rows that have an age column greater than 30</span></span><br><span class="line">display(data_pandas[data_pandas.Age &gt; <span class="number">30</span>])</span><br><span class="line"><span class="comment"># Select all rows that have an age column equal 53</span></span><br><span class="line">display(data_pandas[data_pandas[<span class="string">&#x27;Age&#x27;</span>] == <span class="number">53</span>])</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Name</th>      <th>Location</th>      <th>Age</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>Peter</td>      <td>Berlin</td>      <td>53</td>    </tr>    <tr>      <th>3</th>      <td>Linda</td>      <td>London</td>      <td>33</td>    </tr>  </tbody></table></div><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th &#123;    vertical-align: top;&#125;.dataframe thead th &#123;    text-align: right;&#125;</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Name</th>      <th>Location</th>      <th>Age</th>    </tr>  </thead>  <tbody>    <tr>      <th>2</th>      <td>Peter</td>      <td>Berlin</td>      <td>53</td>    </tr>  </tbody></table></div><h2 id="本书所用类库的版本"><a href="#本书所用类库的版本" class="headerlink" title="本书所用类库的版本"></a>本书所用类库的版本</h2><p>本书使用了如下一些类库，各个类库的版本信息如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Python version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sys.version))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pandas version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pd.__version__))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;matplotlib version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(matplotlib.__version__))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;numpy version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(np.__version__))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;scipy version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sp.__version__))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> IPython</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;IPython version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(IPython.__version__))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sklearn version: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(sklearn.__version__))</span><br></pre></td></tr></table></figure><pre><code>Python version: 3.6.6 |Anaconda, Inc.| (default, Jun 28 2018, 11:07:29) [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)]pandas version: 0.23.3matplotlib version: 2.2.2numpy version: 1.14.5scipy version: 1.1.0IPython version: 6.4.0sklearn version: 0.19.1</code></pre><p>虽然使用精确匹配的版本并不重要，但是需要注意的是尽量保持你的<em>scikit-learn</em>版本最新。</p><p>既然我们已经设置好了开发环境，让我们深入研究及其学习的第一个应用吧。</p><h2 id="第一个机器学习应用：鸢尾花分类"><a href="#第一个机器学习应用：鸢尾花分类" class="headerlink" title="第一个机器学习应用：鸢尾花分类"></a>第一个机器学习应用：鸢尾花分类</h2><p>在本部分，我们将实现一个简单的机器学习应用以及构建机器学习模型。在这个过程中，我们将介绍一些核心的概念和术语等。</p><p>假设一个植物爱好者有兴趣区分他所发现的一些鸢尾花的种类，他收集了一些与每个鸢尾花相关的测量数据：花瓣的长度和宽度、萼片的长度和宽度，均已厘米为单位。</p><p><img src="/images/Introduction_Of_Machine_Learning/iris_petal_sepal.png"></p><p>收集到的数据经过植物专家的鉴定属于刚毛鸢尾、云彩鸢尾或维珍鸢尾。对于这些测量，他可以确定每个鸢尾属属于哪种。</p><p>我们的目标是建立一个机器学习模型，可以这些鸢尾花已知物种的测量数据，最终能够预测新的鸢尾花的物种。</p><p>因为我们有测量了的鸢尾花所属的种类，这是一个有监督的学习问题。在这个问题中，我们要预测几种选择中的一个（具体所属的种类），这是一个分类问题的例子，可能的输出（不同种类的鸢尾）被称为<em>类</em>，由于数据集中每个鸢尾都可能属于三个种类中的一个，因此这是一个三分类的问题。</p><p>单个数据点的期望输出时这种花的种类，对于一个特定的数据点，它所属的五种种类被称为它的<em>标签</em>。</p><h3 id="遇见数据"><a href="#遇见数据" class="headerlink" title="遇见数据"></a>遇见数据</h3><p>在这个例子中我们将使用iris数据集，机器学习和数据统计中经典的数据集，该数据集包含在了<em>scikit-learn</em>中，我们可以直接使用 <em>load_iris</em> 函数加载它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris_dataset = load_iris()</span><br></pre></td></tr></table></figure><p>由函数 <em>load_iris</em> 加载的数据集返回的iris对象是一个堆对象，比较类似于字典。它包含的键和值如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Keys of iris_dataset: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(iris_dataset.keys()))</span><br></pre></td></tr></table></figure><pre><code>Keys of iris_dataset: dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;])</code></pre><p>其中 <em>DESCR</em> 字段是对数据集的简要描述，我们可以简要的查看一下其描述内容（这里仅仅查看部分内容，你可以查看全部内容）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(iris_dataset[<span class="string">&#x27;DESCR&#x27;</span>][:<span class="number">470</span>] + <span class="string">&#x27;\n...&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Iris Plants Database====================Notes-----Data Set Characteristics:    :Number of Instances: 150 (50 in each of three classes)    :Number of Attributes: 4 numeric, predictive attributes and the class    :Attribute Information:        - sepal length in cm        - sepal width in cm        - petal length in cm        - petal width in cm        - class:                - Iris-Setosa                - Iris-Versicolour                - Iris-Virginic...</code></pre><p><em>target_names</em> 的值是一个字符串数组，包含了我们想要预测的花的种类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Target names: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;target_names&#x27;</span>]))</span><br></pre></td></tr></table></figure><pre><code>Target names: [&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]</code></pre><p><em>feature_names</em> 是一个字符串列表，给出了每个特征的描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Feature names: \n&#123;&#125;&quot;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;feature_names&#x27;</span>]))</span><br></pre></td></tr></table></figure><pre><code>Feature names: [&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]</code></pre><p>数据集本身包含了目标和数据，数据包含了萼片长度、萼片宽度、花瓣长度、花瓣宽度的测量数字，保存在一个 <em>NumPy</em> 数组中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Type of data: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(iris_dataset[<span class="string">&#x27;data&#x27;</span>])))</span><br></pre></td></tr></table></figure><pre><code>Type of data: &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>数据阵列中的行对应着花的种类，而列表示针对每个花采取的四个度量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Shape of data: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;data&#x27;</span>].shape))</span><br></pre></td></tr></table></figure><pre><code>Shape of data: (150, 4)</code></pre><p>我们看到阵列包含150种不同花的测量，在机器学习中也被称为<strong>样本</strong>，他们的属性称为<strong>特征</strong>。数据阵列的形状是样本的数量乘以特征的数量，这是<em>Scikit-learn</em>中的一个约定，你的数据将始终假定为该形状。以下是前5个样本的特征值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First five columns of data: \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;data&#x27;</span>][:<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><pre><code>First five columns of data: [[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2]]</code></pre><p>从这些数据中，我们可以看出，所有前五朵花的花瓣宽度都是0.2厘米，而第一朵花的萼片最长，为5.1厘米。</p><p>目标数据阵列中包含被测量的每一朵花所属的种类，也是一个<em>NumPy</em>数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Type of target: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(iris_dataset[<span class="string">&#x27;target&#x27;</span>])))</span><br></pre></td></tr></table></figure><pre><code>Type of target: &lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><p>目标（target）是一个关于每一朵花所属种类的一维的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Shape of target: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;target&#x27;</span>].shape))</span><br></pre></td></tr></table></figure><pre><code>Shape of target: (150,)</code></pre><p>该目标数据被编码为从0到2的整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Target:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iris_dataset[<span class="string">&#x27;target&#x27;</span>]))</span><br></pre></td></tr></table></figure><pre><code>Target:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]</code></pre><p>该目标值与<em>target_names</em>值所对应：0表示setosa、1表示versicolor、2表示virginica。</p><h3 id="衡量成功：训练集与测试集"><a href="#衡量成功：训练集与测试集" class="headerlink" title="衡量成功：训练集与测试集"></a>衡量成功：训练集与测试集</h3><p>我们希望建立一个机器学习模型，使用这个数据集，可以预测鸢尾花的种类。但是在将模型应用在新的预测之前，我们需要知道模型是否真的有效，也就是说，我们是否应该相信模型的预测。</p><p>不好的是，我们不能直接使用我们的数据集来构建模型并评估模型，因为我们的模型总是可以简单的记住整个数据集，并且总是会正确的预测训练数据集中任何数据点的正确标签。这种“记忆”并不表明我们的模型能够很好的泛化（也就是说，模型是否也会在新数据上同样表现良好。）。</p><p>为了评估模型的性能，我们展示了我们有标签的新数据（以前没有见过的数据），通常情况下会分裂我们收集的标记数据（在这里，就是150个花的测量）分为两个部分，一部分用于构建我们的机器学习模型，被称为训练数据或者训练集，其余的数据将用来评估模型的工作如何，被称为测试数据或测试集。</p><p><em>scikit-learn</em> 中包含一个函数，它可以将数据集拆分为训练集和测试集：<em>train_test_split</em> 函数。该函数会将数据集中的75%行作为训练集，并连同这些数据所对应的标签一起提取，剩下的25%的数据，连同剩下的标签，被声明为测试集。当然你也可以自定义训练集和测试集所占比例，但是25%的测试集比例是一个很好的经验法则。</p><p>在<em>scikit-learn</em> 中，数据通常使用大写字母<em>X</em>表示，而标签测用小写字母<em>y</em>表示。这其实是受到标准公式 <em>f(x) &#x3D; y</em> 的启发，其中<em>x</em>是函数的输入，<em>y</em>是函数的输出，遵循数学中的更多约定，我们使用大写字母<em>X</em>，因为数据是二维数组（矩阵），小写字母<em>y</em>是因为目标是一维数组（向量）。</p><p>让我们在数据上调用 <em>train_test_split</em>，并使用上述命名规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X = iris_dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">y = iris_dataset[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在实际进行数据集拆分之前，<em>train_test_split</em> 函数内部会使用伪随机数发生器对数据进行洗牌操作。如果我们仅仅只是使用数据集中的后25%作为测试集，那么所有的数据将只具有标签2，因为数据点是按照标签来排序的。使用只包含三个类之一的测试集，并不能评估出我们的模型泛化能力，因此对数据进行洗牌操作，以确保测试数据集包含来自所有类的数据。</p><p>为了确保如果多次运行相同的函数，我们将获得相同的输出，这里使用<em>random_state</em>参数为伪随机数发生器提供一个固定的种子，这会使得输出确定。</p><p><em>train_test_split</em>函数的输出是 <em>X_train, X_test, y_train, y_test</em>，均为<em>NumPy</em>数组，<em>X_train</em>包含数据集的75%行，<em>X_test</em>包含剩下的25%行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train shape: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(X_train.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_train shape: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(y_train.shape))</span><br></pre></td></tr></table></figure><pre><code>X_train shape: (112, 4)y_train shape: (112,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X_test shape: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(X_test.shape)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_test shape: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(y_test.shape))</span><br></pre></td></tr></table></figure><pre><code>X_test shape: (38, 4)y_test shape: (38,)</code></pre><h2 id="第一件事：看看你的数据"><a href="#第一件事：看看你的数据" class="headerlink" title="第一件事：看看你的数据"></a>第一件事：看看你的数据</h2><p>在建立机器学习模型之前通常的一个好的思路是检查数据，看看所面临的问题是否不使用机器学习可以解决，或者查看期望的输出信息是否可能不包含在数据中等。</p><p>除此之外，检查数据是发现数据异常和数据某些特殊性等的一个很好的方法，也许在你的鸢尾花数据集中有一些数据是以英寸为单位而不是厘米为单位的。在现实世界中，数据的不一致和意外的测量都是非常普遍的。</p><p>检查数据最好的方式之一就是可视化数据，其中一种可视化方法就是使用散点图。数据的散点图沿着x轴放置一个特征，另一个沿y轴放置一个特征，并为每个数据点画一个点，但是不好的是，计算机屏幕只有两个维度，这使得我们一次只能绘制两个或三个特征，如果要绘制超过三个特征的数据集是困难的。解决这个问题的一个方法是绘制一对图，它查看所有可能的特征对，如果你有一小部分特征，比如我们这里的四个，这是相当合理的。但是，您应该记住，配对图不会同时显示所有特性的交互，因此以这种方式可视化数据时，可能不会显示数据的一些有趣方面。</p><p>下图是数据集中特征的对图，数据点根据鸢尾花所属的种类进行着色，为了创建该图，首先将<em>NumPy</em>数据转换为<em>Pandas</em>数据文件，<em>Pandas</em>有一个功能，创建配对图称为散射矩阵。该矩阵的对角线填充有每个特征的直方图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create dataframe from data in X_train</span></span><br><span class="line"><span class="comment"># label the columns using the strings in iris_dataset.feature_names</span></span><br><span class="line">iris_dataframe = pd.DataFrame(X_train, columns=iris_dataset.feature_names)</span><br><span class="line"><span class="comment"># create a scatter matrix from the dataframe, color by y_train </span></span><br><span class="line">pd.plotting.scatter_matrix(iris_dataframe, c=y_train, figsize=(<span class="number">15</span>, <span class="number">15</span>), marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">                           hist_kwds=&#123;<span class="string">&#x27;bins&#x27;</span>: <span class="number">20</span>&#125;, s=<span class="number">60</span>, alpha=<span class="number">.8</span>, cmap=mglearn.cm3)</span><br></pre></td></tr></table></figure><pre><code>array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c160d2550&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c160f8e80&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16127940&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16153400&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c1617ae80&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c1617aeb8&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c161d5400&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c161fce80&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16229940&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16258400&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c1627ee80&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c162ad940&gt;],       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c162dc400&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16301e80&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c1632f940&gt;,        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x1c16361400&gt;]],      dtype=object)</code></pre><p><img src="/images/Introduction_Of_Machine_Learning/output_56_1.png" alt="png"></p><p><strong>对角线部分：</strong> 每个特征的直方图。体现每个特征的密度分布情况。</p><p><strong>非对角线部分：</strong> 两个变量之间分布的关联散点图。将任意两个变量进行配对，以其中一个为横坐标，另一个为纵坐标，将所有的数据点绘制在图上，用来衡量两个变量的关联度（Correlation）。</p><p>从图中我们可以看到，通过萼片和花瓣的测量数据似乎可以很好的区分鸢尾花的种类，这意味着机器学习模型能够学会如何分类它们。</p><p>为了能够更加直观的解释为什么通过该图可以确定机器学习模型能够分类它们，让我们通过创建一个散布矩阵中花瓣的长度（Petal Length）和花瓣宽度（Petal Width）的散点图来展开这一扩展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(iris_dataset.data, columns=iris_dataset.feature_names) </span><br><span class="line">df[<span class="string">&#x27;Target&#x27;</span>] = pd.DataFrame(iris_dataset.target) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.figure(figsize = (<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">names = iris_dataset.target_names</span><br><span class="line">colors = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">label = (iris_dataset.target).astype(np.<span class="built_in">int</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Petal Width vs Petal Length&#x27;</span>)</span><br><span class="line">plt.xlabel(iris_dataset.feature_names[<span class="number">2</span>])</span><br><span class="line">plt.ylabel(iris_dataset.feature_names[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"> bucket = df[df[<span class="string">&#x27;Target&#x27;</span>] == i]</span><br><span class="line"> bucket = bucket.iloc[:,[<span class="number">2</span>,<span class="number">3</span>]].values</span><br><span class="line"> plt.scatter(bucket[:, <span class="number">0</span>], bucket[:, <span class="number">1</span>], label=names[i]) </span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>&lt;Figure size 432x288 with 0 Axes&gt;</code></pre><p><img src="/images/Introduction_Of_Machine_Learning/output_58_1.png" alt="png"></p><p>乍一看，我们可以看到蓝色的点(Setosa类)可以很容易地通过画一条线来分隔，并将其与其他类隔离开来。但是其他两个类呢?</p><p>让我们检查另一种更确定的方法。</p><p><strong>计算几何学</strong></p><p>在这种方法中，我们将使用凸包（Convex Hull）来检查一个特定的类是否是线性可分的。简而言之，凸包代表了一组数据点(类)的外边界，这就是为什么有时它被称为凸包。</p><p>当测试线性可分性时使用凸包的逻辑是相当直接的，可以这样说:</p><blockquote><p>如果X和Y的凸包的交点是空的，那么两个类X和Y是线性可分的。</p></blockquote><p>一种快速的方法来查看它是如何工作的，就是将每个类的凸包的数据点可视化。我们将绘制凸包边界，以直观地检查交点。我们将使用Scipy库来帮助我们计算凸包。更多信息请参阅下方Scipy文档地址。</p><ul><li>地址：<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> ConvexHull</span><br><span class="line"> </span><br><span class="line">plt.clf()</span><br><span class="line">plt.figure(figsize = (<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">names = iris_dataset.target_names</span><br><span class="line">label = (iris_dataset.target).astype(np.<span class="built_in">int</span>)</span><br><span class="line">colors = [<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;g&#x27;</span>]</span><br><span class="line">plt.title(<span class="string">&#x27;Petal Width vs Petal Length&#x27;</span>)</span><br><span class="line">plt.xlabel(iris_dataset.feature_names[<span class="number">2</span>])</span><br><span class="line">plt.ylabel(iris_dataset.feature_names[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line"> bucket = df[df[<span class="string">&#x27;Target&#x27;</span>] == i]</span><br><span class="line"> bucket = bucket.iloc[:,[<span class="number">2</span>,<span class="number">3</span>]].values</span><br><span class="line"> hull = ConvexHull(bucket)</span><br><span class="line"> plt.scatter(bucket[:, <span class="number">0</span>], bucket[:, <span class="number">1</span>], label=names[i]) </span><br><span class="line"> <span class="keyword">for</span> j <span class="keyword">in</span> hull.simplices:</span><br><span class="line">     plt.plot(bucket[j,<span class="number">0</span>], bucket[j,<span class="number">1</span>], colors[i])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>&lt;Figure size 432x288 with 0 Axes&gt;</code></pre><p><img src="/images/Introduction_Of_Machine_Learning/output_60_1.png" alt="png"></p><p>至少从直观上看，Setosa是一个线性可分的类。换句话说，我们可以很容易地画出一条直线，将Setosa类与非Setosa类分开。Versicolor类和Versicolor类都不是线性可分的，因为我们可以看到它们两个之间确实有一个交集。</p><h2 id="构建你的第一个模型：K-最近邻模型（k-Nearest-Neighbors，kNN）"><a href="#构建你的第一个模型：K-最近邻模型（k-Nearest-Neighbors，kNN）" class="headerlink" title="构建你的第一个模型：K-最近邻模型（k-Nearest Neighbors，kNN）"></a>构建你的第一个模型：K-最近邻模型（k-Nearest Neighbors，kNN）</h2><p>了解了数据之后，我们现在开始构建一个实际的机器学习模型。在<em>scikit-learn</em>中有很多的分类算法可以使用，这里我们使用易于理解的 <em>k-Nearest Neighbors</em> 分类器。该分类器仅需要存储的训练集，为了能够对新的数据点进行预测，该算法在训练集中找到距离新数据点最接近的点，然后，将这个训练点的标签分配给新的数据点。</p><p><em>kNN</em> 中的 <em>k</em> 表示在训练中我们可以考虑多少固定数目的数据点（例如最近的3个或者5个），而不是仅仅使用距离新数据点最新的点，然后，我们可以使用这些距离较近的数据点指点的多数进行最终的标签分配，为了简单起见，这里我们仅仅使用一个距离最近的点。</p><p><em>scikit-learn</em> 中的所有机器学习模型都在自己的类中实现的，通常被称为 <em>估计器类</em>。<em>kNN</em> 分类算法是在 <em>neighbors</em> 模块的 <em>KNeighborsClassifier</em> 类中实现的。在我们实现模型之前，需要将类实例化为一个对象，当我们设置模型参数的额时候，会将 <em>KNeighborsClassifier</em> 分类器最终的参数邻居数设置为1（即 <em>k&#x3D;1</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><em>knn</em> 对象封装了用于根据训练数据集建立机器学习模型的算法，以及用于对新数据进行预测的算法，它还保存了算法从训练数据中提取的信息。</p><p>为了在训练集上建立模型，我们只需要调用 <em>knn</em> 的 <em>fit</em> 函数，该函数包含训练数据的 <em>NumPy</em> 数组 <em>X_train</em> 和对应的训练标签 <em>NumPy</em> 数组 <em>y_train</em> 数组作为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=1, p=2,           weights=&#39;uniform&#39;)</code></pre><p><em>fit</em> 函数返回 <em>knn</em> 对象本身（其内部已经根据设定进行修改），因为我们得到了我们的分类器的字符串表示，表明我们在创建模型的时候使用了哪些参数。几乎所有的这些都是默认值，但是你也能够找到 <em>n_neighbors&#x3D;1</em>，这是我们设定的参数。<em>scikit-learn</em> 中的大多数模型都需要很多的参数，但是大多数都是速度优化或者用于非常特殊的用例，不必担心在该表示中显示的其他参数。</p><h2 id="进行预测"><a href="#进行预测" class="headerlink" title="进行预测"></a>进行预测</h2><p>有了模型之后，我们就可以使用该模型对新的数据进行预测了。假设我们有一个新的鸢尾花的测量数据：萼片长度5cm、萼片宽度2.9cm、花瓣长度1cm、花瓣宽度0.2cm。该鸢尾花属于哪个类呢？我们可以将这些数据放在 <em>NumPy</em> 数组中，并计算数组形状 – 数组形状应该为样本数 1，特征数 4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_new = np.array([[<span class="number">5</span>, <span class="number">2.9</span>, <span class="number">1</span>, <span class="number">0.2</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_new.shaple: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(X_new.shape))</span><br></pre></td></tr></table></figure><pre><code>X_new.shaple: (1, 4)</code></pre><p>你可能注意到了，在构建 <em>NumPy</em> 数组的时候，我们使用的是二维的形式，这是因为在 <em>scikit-learn</em> 中的数据总是希望具有二维性。</p><p>为了进行预测，我们只需要调用 <em>knn</em> 对象的 <em>predict</em> 函数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction = knn.predict(X_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Prediction: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(prediction))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predicted target name: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(iris_dataset.target_names[prediction]))</span><br></pre></td></tr></table></figure><pre><code>Prediction: [0]Predicted target name: [&#39;setosa&#39;]</code></pre><p>如果你需要查看属于各个分类的概率，可以调用 <em>knn</em> 对象的 <em>predict_proba</em> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prediction_prob = knn.predict_proba(X_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Prediction prob: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(prediction_prob))</span><br></pre></td></tr></table></figure><pre><code>Prediction prob: [[1. 0. 0.]]</code></pre><p>可以看到概率的输出和标签的输出是一致的。</p><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>在之前我们进行了数据集的拆分，分为了训练集和测试集，训练集我们用来训练模型，而测试集的作用便是评估模型了。在测试集中我们已经知道了每个鸢尾花的种类，因此我们可以对测试集数据调用预测函数，并将预测结果和实际的结果进行比较，已确定模型的性能。可以通过计算模型预测的精确度来测量模型的工作情况，精确度是预测正确种类的花朵的比例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test set predictions: \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(y_pred))</span><br></pre></td></tr></table></figure><pre><code>Test set predictions: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 2]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test set score: &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(y_pred == y_test)))</span><br></pre></td></tr></table></figure><pre><code>Test set score: 0.97</code></pre><p>上述方法是计算模型预测的精确度，统计所有预测正确的数目进行去均值计算。你也可以直接调用 <em>knn</em> 对象的 <em>score</em> 函数进行计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test set score: &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br></pre></td></tr></table></figure><pre><code>Test set score: 0.97</code></pre><p>对于这个模型，测试集的精确度为 0.97，这意味着我们对测试机中的 97% 的鸢尾花进行了正确的预测，在一些数据假设下，意味着我们可以预期我们的鸢尾花分类模型对新的鸢尾花的识别精确度为 97%。对于一个植物爱好者来说，这种高精度意味着我们的模型具有很高的可信赖度。</p><h2 id="总结与回归"><a href="#总结与回归" class="headerlink" title="总结与回归"></a>总结与回归</h2><p>让我们总结一下我们在这章学到的内容。首先我们介绍了机器学习及其应用，然后讨论了监督学习和无监督学习的区别，并给出了我们将在本书中使用的工具的概述，之后，我们通过对鸢尾花的物理测定，确定了一种预测鸢尾花所属种类的预测任务。我们使用了一个带有正确标签的鸢尾花数据集建立了一个分类模型。</p><p>鸢尾花数据集由两个 <em>NumPy</em> 数组组成，一个包含数据，在 <em>scikit-learn</em> 中称为 <em>X</em>，另一个包含正确或期望额输出，称为 <em>y</em>，数组 <em>y</em> 是一个一维数组，仅包含一个类标签，每个示例的证书范围是0到2。</p><p>我们将数据集拆分为训练集和测试集，训练集用于构建我们的模型，测试集用于评估我们的模型。</p><p>我们选择了 <em>k-最近邻</em> 分类算法，该算法通过考虑训练集中的最近邻来对新的数据点进行预测，该算法在类 <em>KNeighborsClassifier</em> 中实现，该类包含构建模型的算法和使用模型进行预测的算法，使用前需要先实例化类并设置参数。然后通过调用拟合函数 <em>fit</em> 进行模型的构建，将训练数据 <em>X_train</em> 和训练标签 <em>y_train</em> 作为参数传递。我们使用评分法对模型进行评估，计算模型的准确性。我们使用测试集和测试标签进行模型的评估，发现我们的模型准确率在97%左右，意味着在测试集上有97%的数据是预测正确的。这给了我们将模型应用到新的数据上的信心，并且相信模型在大约97%的事件内都是正确的。</p><p>下面是整个代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">iris_dataset = load_iris()</span><br><span class="line">X = iris_dataset.data</span><br><span class="line">y = iris_dataset.target</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(knn))</span><br><span class="line"></span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test set score: &#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(np.mean(y_pred == y_test)))</span><br></pre></td></tr></table></figure><pre><code>KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;minkowski&#39;,           metric_params=None, n_jobs=1, n_neighbors=1, p=2,           weights=&#39;uniform&#39;)Test set score: 0.97</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;机器学习是一门从数据中提取知识的技术。&lt;/strong&gt; 它是统计学、人工智能和计算机科学的交叉研究领域，被常被称为&lt;strong&gt;预测分析&lt;/strong&gt;、&lt;strong&gt;统计学习&lt;/strong&gt;。机器学习方法的应用近年来在日常生活中无处不在。从自动推荐看哪部电影、点什么食物或买什么东西，到个性化的在线收音机、智能化在线教育，再到从照片中找到你的朋友等等需要现代网站和设备的核心都是机器学习算法。当你查看例如Facebook、Amazon、Netflix、Weibo、Twitter等复杂网站时，很可能网站的每个部分都包含了多个机器学习模型。&lt;/p&gt;
&lt;p&gt;除了商业应用之外，机器学习已经对数据驱动的研究方式产生了巨大的影响。机器学习相关的技术、工具已经应用于各种科学问题，例如理解恒星、发现遥远的行星、发现新的粒子、分析DNA序列以及提供个性化的癌症治疗等。&lt;/p&gt;
&lt;p&gt;但是，为了从机器学习中获益，你的应用程序可能并不需要大规模。在本部分，将解释为什么机器学习变的如此的流行，并讨论使用机器学习可以解决哪些问题。然后，将展示如何构建你的第一个机器学习模型等。&lt;/p&gt;
&lt;h2 id=&quot;为什么是机器学习？&quot;&gt;&lt;a href=&quot;#为什么是机器学习？&quot; class=&quot;headerlink&quot; title=&quot;为什么是机器学习？&quot;&gt;&lt;/a&gt;为什么是机器学习？&lt;/h2&gt;&lt;p&gt;较早期的“智能”应用程序，许多的系统使用“if”和“else”硬编码规则来处理数据或者根据用户的输入进行调整。想象一个垃圾邮件过滤器，其工作是适当的移动电子邮件到垃圾邮件文件夹。你可以构造一个垃圾邮件词库黑名单，并返回垃圾邮件标记 &lt;em&gt;1&lt;/em&gt;。这是一个使用专家设计的规则来实现“智能”应用程序的例子。手工创建决策规则对于一些应用程序是可行的，特别是那些人类对建模过程有很好理解的应用程序，然而，使用手工编码的规则进行决策有两点主要缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做出决策所需的规则逻辑是针对特定的单个域和任务的，一些业务改变，整个系统可能都需要重写；&lt;/li&gt;
&lt;li&gt;设计规则需要深刻理解人类专家应该如何做出决定。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发隐藏技能如何开启</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-03-08-iOS_Tips/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-03-08-iOS_Tips/</id>
    <published>2022-04-30T06:35:13.795Z</published>
    <updated>2022-04-30T07:44:58.501Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS的开发过程中，我们经常会遇到一些需要关心但是无法直接得到的信息，本文记录了一些能够开启IDE隐藏功能的方法，帮助开发者了解更多的信息等。</p><h2 id="1-在-Xcode-中追踪构建时间"><a href="#1-在-Xcode-中追踪构建时间" class="headerlink" title="1. 在 Xcode 中追踪构建时间"></a>1. 在 Xcode 中追踪构建时间</h2><p>在使用Xcode进行项目的编译和打包的时候，总是耗时的，而这个时间Xcode本身是具有统计功能的。如果需要查看此时间，需要开启Xcode的<code>ShowBuildOperationDuration</code>选项，打开命令行工具，直接输入如下命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES</span><br></pre></td></tr></table></figure><p>开启后，Xcode的构建完成后，会在Xcode的状态栏显示本次构建的耗时。</p><span id="more"></span><p><img src="/images/ios-jq/Track-build-time-in-Xcode.png"></p><h2 id="2-改善-Swift-项目构建时间"><a href="#2-改善-Swift-项目构建时间" class="headerlink" title="2. 改善 Swift 项目构建时间"></a>2. 改善 Swift 项目构建时间</h2><p>在 Xcode 9.2 的发布说明中提到了一个可以改进Swift项目构建时间的实验性功能，可以通过开启<code>BuildSystemScheduleInherentlyParallelCommandsExclusively</code>来实现提速。</p><p><img src="/images/ios-jq/Xcode-New-Features.png"></p><p>开启方式也是通过命令行工具，输入如下命令开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively -bool NO</span><br></pre></td></tr></table></figure><p>如果要关闭此功能，输入如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.dt.Xcode BuildSystemScheduleInherentlyParallelCommandsExclusively</span><br></pre></td></tr></table></figure><blockquote><p>！！！重要：根据发布说明，这是一个实验性功能，会在项目构建期间增加内存使用量。</p></blockquote><h2 id="3-在全屏模式下同时使用Xcode和模拟器"><a href="#3-在全屏模式下同时使用Xcode和模拟器" class="headerlink" title="3. 在全屏模式下同时使用Xcode和模拟器"></a>3. 在全屏模式下同时使用Xcode和模拟器</h2><p>在Xcode全屏的情况下，如果需要同时使用模拟器在Xcode 9以前是很难实现的，但是在Xcode 9 以上，我们可以做到这样。我们只需要在命令行中输入如下的命令来开启这个功能即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES</span><br></pre></td></tr></table></figure><p>完成后，如果我们在全屏模式下使用Xcode + 模拟器就很轻松了。如下：</p><p><img src="/images/ios-jq/full-screen.png"></p><p>如果你想在模拟器中使用更多的Apple为公开的隐藏功能，你需要启用Apple隐藏的内部菜单。为此，您需要在根目录中创建一个名称为“AppleInternal”的空文件夹（<a href="https://www.theiphonewiki.com/wiki//AppleInternal">详解</a>）。只需在下面运行此命令并重新启动模拟器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /AppleInternal</span><br></pre></td></tr></table></figure><p>如果上述命令输入后，出现权限问题。可参考下图中的步骤：</p><p><img src="/images/ios-jq/AppleInternal_os_setting.png"></p><p>最终你可以在模拟器菜单中发现一些新的功能特性（下图仅为部分功能）：</p><p><img src="/images/ios-jq/more-features-simu.png"></p><p>更多关于sdsds的介绍可参考：<a href="https://sspai.com/post/42038">一条命令让您的 macOS 用 Touch ID 授权 sudo！</a></p><h2 id="4-捕获iOS模拟器视频"><a href="#4-捕获iOS模拟器视频" class="headerlink" title="4. 捕获iOS模拟器视频"></a>4. 捕获iOS模拟器视频</h2><p>如果需要针对模拟器视图进行截图或者录视频，你可以使用<code>xcrun command-line</code>工具，其命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl io booted recordVideo &lt;filename&gt;.&lt;file extension&gt;.</span><br></pre></td></tr></table></figure><p>例如，如果要录视频，对应的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl io booted recordVideo appvideo.mov</span><br></pre></td></tr></table></figure><p>在录制的过程中，你可以按下<code>Control + c</code> 来停止录制，文件保存的位置就在当前的目录中。</p><h2 id="5-从Finder将文件共享到Simulator"><a href="#5-从Finder将文件共享到Simulator" class="headerlink" title="5. 从Finder将文件共享到Simulator"></a>5. 从Finder将文件共享到Simulator</h2><p>从 Xcode 9 开始，所有的模拟器便具有了Finder的扩展功能，可以让你从Mac的Finder直接共享文件到模拟器，对应的菜单在文件上右键 -&gt; 分享 中：</p><p><img src="/images/ios-jq/share-file-to-sim.png"></p><p>当然，还有一种更为简单的共享方式，直接拖拽文件到模拟器即可完成共享。另外也可以使用下面的simctl命令对图像&#x2F;视频文件做类似的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl addmedia booted &lt;PATH TO IMAGE/VIDEO&gt;</span><br></pre></td></tr></table></figure><h2 id="6-使用指纹授权sudo"><a href="#6-使用指纹授权sudo" class="headerlink" title="6. 使用指纹授权sudo"></a>6. 使用指纹授权sudo</h2><p>本方式仅针对具有Touch Bar的Macbook Pro。如果你想使用你的指纹来授权sudo，可以在命令行中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">&quot;.bak&quot;</span> <span class="string">&#x27;2s/^/auth       sufficient     pam_tid.so\&#x27;</span>$<span class="string">&#x27;\n/g&#x27;</span> /etc/pam.d/sudo</span><br></pre></td></tr></table></figure><p>然后输入管理员密码，回车即可。现在可以使用你的指纹进行sudo了，想象都激动。</p><h2 id="7-使用声音通知调试AutoLayout约束"><a href="#7-使用声音通知调试AutoLayout约束" class="headerlink" title="7. 使用声音通知调试AutoLayout约束"></a>7. 使用声音通知调试AutoLayout约束</h2><p>在调试AutoLayout约束的时候，你可以通过声音通知的方式来提醒AutoLayout约束是否合规。使用此项功能，只需要在Xcode项目中增加<code>UIConstraintBasedLayoutPlaySoundOnUnsatisfiable</code>参数即可，增加后，如果AutoLayout约束出现异常或者冲突，会有提示声音：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-_UIConstraintBasedLayoutPlaySoundOnUnsatisfiable YES</span><br></pre></td></tr></table></figure><p><img src="/images/ios-jq/AutoLayout-sound.png"></p><h2 id="8-从Xcode中移除不可用的模拟器"><a href="#8-从Xcode中移除不可用的模拟器" class="headerlink" title="8. 从Xcode中移除不可用的模拟器"></a>8. 从Xcode中移除不可用的模拟器</h2><p>这个命令将从Xcode中删除所有不可用的模拟器。这里的“不可用”表示模拟器和Xcode的xcode-select版本不相符导致的模拟器不可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl delete unavailable</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在iOS的开发过程中，我们经常会遇到一些需要关心但是无法直接得到的信息，本文记录了一些能够开启IDE隐藏功能的方法，帮助开发者了解更多的信息等。&lt;/p&gt;
&lt;h2 id=&quot;1-在-Xcode-中追踪构建时间&quot;&gt;&lt;a href=&quot;#1-在-Xcode-中追踪构建时间&quot; class=&quot;headerlink&quot; title=&quot;1. 在 Xcode 中追踪构建时间&quot;&gt;&lt;/a&gt;1. 在 Xcode 中追踪构建时间&lt;/h2&gt;&lt;p&gt;在使用Xcode进行项目的编译和打包的时候，总是耗时的，而这个时间Xcode本身是具有统计功能的。如果需要查看此时间，需要开启Xcode的&lt;code&gt;ShowBuildOperationDuration&lt;/code&gt;选项，打开命令行工具，直接输入如下命令即可。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;开启后，Xcode的构建完成后，会在Xcode的状态栏显示本次构建的耗时。&lt;/p&gt;</summary>
    
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="开发知识 iOS" scheme="https://zycslog.github.io/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS虚拟内存管理</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-01-22-iOS_VMManage/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-01-22-iOS_VMManage/</id>
    <published>2022-04-30T06:35:13.794Z</published>
    <updated>2022-04-30T07:44:53.482Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p><h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p><p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p><p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p><p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p><span id="more"></span><h2 id="虚拟内存的限制"><a href="#虚拟内存的限制" class="headerlink" title="虚拟内存的限制"></a>虚拟内存的限制</h2><p>在iOS开发的过程中，难免手动去申请内存，目前大多数的移动设备都是ARM64的设备，即使用的是64位寻址空间，而且在iOS上通过malloc申请的内存只是虚拟内存，不是真正的物理内存，那么在iOS设备上为什么会出现申请了2-3G就会出现申请失败呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buffer = <span class="built_in">malloc</span>(<span class="number">2000</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>: *** mach_vm_map(size=<span class="number">2097152000</span>) failed (error code=<span class="number">3</span>)</span><br><span class="line">*** error: can<span class="number">&#x27;</span>t allocate region</span><br></pre></td></tr></table></figure><p>当申请分配一个超大的内存时，iOS系统会按照<code>nano_zone</code>和<code>scalable_zone</code>的设计理念进行内存的申请，申请原理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *    <span class="title function_">szone_malloc_should_clear</span><span class="params">(<span class="type">szone_t</span> *szone, <span class="type">size_t</span> size, <span class="type">boolean_t</span> cleared_requested)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">msize_t</span> msize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= SMALL_THRESHOLD) &#123;</span><br><span class="line">        <span class="comment">// tiny size: &lt;1024 bytes (64-bit), &lt;512 bytes (32-bit)</span></span><br><span class="line">        <span class="comment">// think tiny</span></span><br><span class="line">        msize = TINY_MSIZE_FOR_BYTES(size + TINY_QUANTUM - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!msize) &#123;</span><br><span class="line">            msize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = tiny_malloc_should_clear(szone, msize, cleared_requested);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= szone-&gt;large_threshold) &#123;</span><br><span class="line">        <span class="comment">// small size: &lt;15k (&lt;1GB machines), &lt;127k (&gt;1GB machines)</span></span><br><span class="line">        <span class="comment">// think small</span></span><br><span class="line">        msize = SMALL_MSIZE_FOR_BYTES(size + SMALL_QUANTUM - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!msize) &#123;</span><br><span class="line">            msize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = small_malloc_should_clear(szone, msize, cleared_requested);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// large: all other allocations</span></span><br><span class="line">        <span class="type">size_t</span> num_kernel_pages = round_page_quanta(size) &gt;&gt; vm_page_quanta_shift;</span><br><span class="line">        <span class="keyword">if</span> (num_kernel_pages == <span class="number">0</span>) &#123; <span class="comment">/* Overflowed */</span></span><br><span class="line">            ptr = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr = large_malloc(szone, num_kernel_pages, <span class="number">0</span>, cleared_requested);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_MALLOC</span></span><br><span class="line">    <span class="keyword">if</span> (LOG(szone, ptr)) &#123;</span><br><span class="line">        malloc_printf(<span class="string">&quot;szone_malloc returned %p\n&quot;</span>, ptr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If requested, scribble on allocated memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((szone-&gt;debug_flags &amp; MALLOC_DO_SCRIBBLE) &amp;&amp; ptr &amp;&amp; !cleared_requested &amp;&amp; size) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ptr, SCRIBBLE_BYTE, szone_size(szone, ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小于1k的走 tiny_malloc</li><li>小于15k或者127k的走 small_malloc （视具体不同的设备内存上限不同）</li><li>剩下的走 large_malloc</li></ul><p>由于我们分配的非常大，我们可以确定我们的逻辑是落入<code>large_malloc</code>中。需要特别注意的是： <code>large_malloc</code>分配内存的基本单位是一页大小，而对于其他的几种分配方式，则不是必须按照页大小进行分配。</p><p>由于 <code>large_malloc</code> 这个函数本身并没有特殊需要注意的地方，我们直接关注其真正分配内存的地方，即 <code>allocate_pages</code> ，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vm_addr = vm_page_quanta_size;</span><br><span class="line">kr = mach_vm_map(mach_task_self(), &amp;vm_addr, allocation_size, allocation_mask, alloc_flags, MEMORY_OBJECT_NULL, <span class="number">0</span>, FALSE,</span><br><span class="line">            VM_PROT_DEFAULT, VM_PROT_ALL, VM_INHERIT_DEFAULT);</span><br><span class="line"><span class="keyword">if</span> (kr) &#123;</span><br><span class="line">    szone_error(szone, <span class="number">0</span>, <span class="string">&quot;can&#x27;t allocate region&quot;</span>, <span class="literal">NULL</span>, <span class="string">&quot;*** mach_vm_map(size=%lu) failed (error code=%d)\n&quot;</span>, size, kr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">addr = (<span class="type">uintptr_t</span>)vm_addr;</span><br></pre></td></tr></table></figure><p>从上不难看出，如果分配失败，就是提示报错。而 <code>mach_vm_map</code> 则是整个内存的分配核心。</p><p><img src="/images/vm/virtual.png"></p><p>概括来说，<code>vm_map</code> 代表就是一个进程运行时候涉及的虚拟内存， <code>pmap</code> 代表的就是和具体硬件架构相关的物理内存。（这里我们暂时先不考虑 <code>submap</code> 这种情况）。</p><p><code>vm_map</code>本身是进程（或者从Mach内核的角度看是task的地址分布图）。这个地址分布图维护着一个 <strong>双向列表</strong> ，列表的每一项都是 <code>vm_entry_t</code> ，代表着虚拟地址上连续的一个范围。而 <code>pmap</code> 这个结构体代表了个硬件相关的内存转换：即利用 <code>pmap</code> 这个结构体来描述抽象的物理地址访问和使用。</p><h2 id="进程（任务）的创建"><a href="#进程（任务）的创建" class="headerlink" title="进程（任务）的创建"></a>进程（任务）的创建</h2><p>对于在iOS上的进程创建和加载执行Mach-O过程，有必要进行一个简单的介绍，在类UNIX系统本质上是不会无缘无故创建出一个进程的，基本上必须通过<code>fork</code>的形式来创建。无论是用户态调用<code>posix</code>相关的API还是别的API，最终落入内核是均是通过函数<code>fork_create_child</code>来创建属于Mach内核的任务。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_t</span></span><br><span class="line"><span class="title function_">fork_create_child</span><span class="params">(<span class="type">task_t</span> parent_task, <span class="type">proc_t</span> child, <span class="type">int</span> inherit_memory, <span class="type">int</span> is64bit)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">thread_t</span>child_thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">task_t</span>child_task;</span><br><span class="line"><span class="type">kern_return_t</span>result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new task for the child process */</span></span><br><span class="line">result = task_create_internal(parent_task,</span><br><span class="line">inherit_memory,</span><br><span class="line">is64bit,</span><br><span class="line">&amp;child_task);</span><br><span class="line"><span class="keyword">if</span> (result != KERN_SUCCESS) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;execve: task_create_internal failed.  Code: %d\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the child task to the new task */</span></span><br><span class="line">child-&gt;task = child_task;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set child task proc to child proc */</span></span><br><span class="line">set_bsdtask_info(child_task, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Propagate CPU limit timer from parent */</span></span><br><span class="line"><span class="keyword">if</span> (timerisset(&amp;child-&gt;p_rlim_cpu))</span><br><span class="line">task_vtimer_set(child_task, TASK_VTIMER_RLIM);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set/clear 64 bit vm_map flag */</span></span><br><span class="line"><span class="keyword">if</span> (is64bit)</span><br><span class="line">vm_map_set_64bit(get_task_map(child_task));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">vm_map_set_32bit(get_task_map(child_task));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line"><span class="comment">/* Update task for MAC framework */</span></span><br><span class="line"><span class="comment">/* valid to use p_ucred as child is still not running ... */</span></span><br><span class="line">mac_task_label_update_cred(child-&gt;p_ucred, child_task);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set child scheduler priority if nice value inherited from parent */</span></span><br><span class="line"><span class="keyword">if</span> (child-&gt;p_nice != <span class="number">0</span>)</span><br><span class="line">resetpriority(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new thread for the child process */</span></span><br><span class="line">result = thread_create(child_task, &amp;child_thread);</span><br><span class="line"><span class="keyword">if</span> (result != KERN_SUCCESS) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;execve: thread_create failed. Code: %d\n&quot;</span>, result);</span><br><span class="line">task_deallocate(child_task);</span><br><span class="line">child_task = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bad:</span><br><span class="line">thread_yield_internal(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(child_thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要注意的就是<strong>Mach内核里面没有进程的概念，只有任务</strong>，进程是属于BSD之上的抽象。它们之间的联系就是通过指针建立， <code>child_proc-&gt;task = child_task</code>。</li></ul><p><code>fork</code>出来的进程像是一个空壳，需要利用这个进程壳去执行科执行文件编程有意义的<strong>程序进程</strong>。从XNU上看，可执行文件的类型有如下分类：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; exec_mach_imgact,        <span class="string">&quot;Mach-o Binary&quot;</span> &#125;,</span><br><span class="line">&#123; exec_fat_imgact,        <span class="string">&quot;Fat Binary&quot;</span> &#125;,</span><br><span class="line">&#123; exec_shell_imgact,    <span class="string">&quot;Interpreter Script&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>常用的通常是<code>Mach-o</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">exec_mach_imgact(<span class="keyword">struct</span> image_params *imgp)</span><br><span class="line">&#123;</span><br><span class="line">    ... 省略无数</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mach_header-&gt;magic == MH_CIGAM) ||</span><br><span class="line">        (mach_header-&gt;magic == MH_CIGAM_64)) &#123;</span><br><span class="line">        error = EBADARCH;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;</span><br><span class="line">        (mach_header-&gt;magic != MH_MAGIC_64)) &#123;</span><br><span class="line">        error = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mach_header-&gt;filetype != MH_EXECUTE) &#123;</span><br><span class="line">        error = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imgp-&gt;ip_origcputype != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Fat header previously had an idea about this thin file */</span></span><br><span class="line">        <span class="keyword">if</span> (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||</span><br><span class="line">            imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) &#123;</span><br><span class="line">            error = EBADARCH;</span><br><span class="line">            <span class="keyword">goto</span> bad;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imgp-&gt;ip_origcputype = mach_header-&gt;cputype;</span><br><span class="line">        imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task = current_task();</span><br><span class="line">    thread = current_thread();</span><br><span class="line">    uthread = get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)</span><br><span class="line">        imgp-&gt;ip_flags |= IMGPF_IS_64BIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If posix_spawn binprefs exist, respect those prefs. */</span></span><br><span class="line">    psa = (<span class="keyword">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa;</span><br><span class="line">    <span class="keyword">if</span> (psa != <span class="literal">NULL</span> &amp;&amp; psa-&gt;psa_binprefs[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> pr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (pr = <span class="number">0</span>; pr &lt; NBINPREFS; pr++) &#123;</span><br><span class="line">            <span class="type">cpu_type_t</span> pref = psa-&gt;psa_binprefs[pr];</span><br><span class="line">            <span class="keyword">if</span> (pref == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No suitable arch in the pref list */</span></span><br><span class="line">                error = EBADARCH;</span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pref == CPU_TYPE_ANY) &#123;</span><br><span class="line">                <span class="comment">/* Jump to regular grading */</span></span><br><span class="line">                <span class="keyword">goto</span> grade;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pref == imgp-&gt;ip_origcputype) &#123;</span><br><span class="line">                <span class="comment">/* We have a match! */</span></span><br><span class="line">                <span class="keyword">goto</span> grade;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        error = EBADARCH;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">grade:</span><br><span class="line">    <span class="keyword">if</span> (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) &#123;</span><br><span class="line">        error = EBADARCH;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy in arguments/environment from the old process */</span></span><br><span class="line">    error = exec_extract_strings(imgp);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">    AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, </span><br><span class="line">        imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);</span><br><span class="line">    AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,</span><br><span class="line">        imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset local idea of thread, uthread, task */</span></span><br><span class="line">    thread = imgp-&gt;ip_new_thread;</span><br><span class="line">    uthread = get_bsdthread_info(thread);</span><br><span class="line">    task = new_task = get_threadtask(thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意点：</span></span><br><span class="line">    lret = load_machfile(imgp, mach_header, thread, &amp;<span class="built_in">map</span>, &amp;load_result);</span><br><span class="line"></span><br><span class="line">    ... 省略无数</span><br></pre></td></tr></table></figure><p>上面的代码基本上都是在对文件进行各种检查，然后分配一个预使用的进程壳，之后使用<code>load_machfile</code>加载真正的二进制文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">load_return_t</span></span><br><span class="line"><span class="title function_">load_machfile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> image_params    *imgp,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> mach_header    *header,</span></span><br><span class="line"><span class="params">    <span class="type">thread_t</span>         thread,</span></span><br><span class="line"><span class="params">    <span class="type">vm_map_t</span>         *mapp,</span></span><br><span class="line"><span class="params">    <span class="type">load_result_t</span>        *result</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... 省略一大堆</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (macho_size &gt; file_size) &#123;</span><br><span class="line">        <span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result-&gt;is64bit = ((imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) == IMGPF_IS_64BIT);</span><br><span class="line"></span><br><span class="line">    <span class="type">task_t</span> ledger_task;</span><br><span class="line">    <span class="keyword">if</span> (imgp-&gt;ip_new_thread) &#123;</span><br><span class="line">        ledger_task = get_threadtask(imgp-&gt;ip_new_thread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ledger_task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意点1</span></span><br><span class="line">    pmap = pmap_create(get_task_ledger(ledger_task),</span><br><span class="line">               (<span class="type">vm_map_size_t</span>) <span class="number">0</span>,</span><br><span class="line">               result-&gt;is64bit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意点2</span></span><br><span class="line">    <span class="built_in">map</span> = vm_map_create(pmap,</span><br><span class="line">,</span><br><span class="line">            vm_compute_max_offset(result-&gt;is64bit),</span><br><span class="line">            TRUE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm64__)</span></span><br><span class="line">    <span class="comment">// 注意点三</span></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;is64bit) &#123;</span><br><span class="line">        <span class="comment">/* enforce 16KB alignment of VM map entries */</span></span><br><span class="line">        vm_map_set_page_shift(<span class="built_in">map</span>, SIXTEENK_PAGE_SHIFT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm_map_set_page_shift(<span class="built_in">map</span>, page_shift_user32);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>利用 <code>pmap_create</code> 创建硬件相关的物理内存抽象。</li><li>利用 <code>vmap_create</code> 创建虚拟内存的地址图。</li><li>ARM64下的页是16k一个虚拟页对应一个物理页。</li></ul><p>这里需要重点关注 <code>vm_map_create 0</code> 和 <code>vm_compute_max_offset(result-&gt;is64bit)</code>，代表着当前任务分配的虚拟内存地址的上下限， <code>vm_compute_max_offset</code>函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vm_map_offset_t</span></span><br><span class="line"><span class="title function_">vm_compute_max_offset</span><span class="params">(<span class="type">boolean_t</span> is64)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm__) || defined(__arm64__)</span></span><br><span class="line">    <span class="keyword">return</span> (pmap_max_offset(is64, ARM_PMAP_MAX_OFFSET_DEVICE));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> (is64 ? (<span class="type">vm_map_offset_t</span>)MACH_VM_MAX_ADDRESS : (<span class="type">vm_map_offset_t</span>)VM_MAX_ADDRESS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pmap_max_offset</code>函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vm_map_offset_t</span> <span class="title function_">pmap_max_offset</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">boolean_t</span>    is64 __unused,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span>    option)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>    max_offset_ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm64__)</span></span><br><span class="line">    assert (is64);</span><br><span class="line">    <span class="type">vm_map_offset_t</span> min_max_offset = SHARED_REGION_BASE_ARM64 + SHARED_REGION_SIZE_ARM64 + <span class="number">0x20000000</span>; <span class="comment">// end of shared region + 512MB for various purposes</span></span><br><span class="line">    <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEFAULT) &#123;</span><br><span class="line">        max_offset_ret = arm64_pmap_max_offset_default;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MIN) &#123;</span><br><span class="line">        max_offset_ret = min_max_offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_MAX) &#123;</span><br><span class="line">        max_offset_ret = MACH_VM_MAX_ADDRESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_DEVICE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arm64_pmap_max_offset_default) &#123;</span><br><span class="line">            max_offset_ret = arm64_pmap_max_offset_default;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) &#123;</span><br><span class="line">            max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="comment">// Max offset is 12.375GB for devices with &gt; 3GB of memory</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) &#123;</span><br><span class="line">            max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="comment">// Max offset is 8.375GB for devices with &gt; 1GB and &lt;= 3GB of memory</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max_offset_ret = min_max_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == ARM_PMAP_MAX_OFFSET_JUMBO) &#123;</span><br><span class="line">        max_offset_ret = <span class="number">0x0000000518000000</span>ULL;     <span class="comment">// Max offset is 20.375GB for pmaps with special &quot;jumbo&quot; blessing</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;pmap_max_offset illegal option 0x%x\n&quot;</span>, option);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(max_offset_ret &gt;= min_max_offset);</span><br><span class="line">    <span class="keyword">return</span> max_offset_ret;</span><br></pre></td></tr></table></figure><p>这里的关键点代码是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (max_mem &gt; <span class="number">0xC0000000</span>) &#123;</span><br><span class="line">    max_offset_ret = <span class="number">0x0000000318000000</span>ULL;     <span class="comment">// Max offset is 12.375GB for devices with &gt; 3GB of memory</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (max_mem &gt; <span class="number">0x40000000</span>) &#123;</span><br><span class="line">    max_offset_ret = <span class="number">0x0000000218000000</span>ULL;     <span class="comment">// Max offset is 8.375GB for devices with &gt; 1GB and &lt;= 3GB of memory</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max_offset_ret = min_max_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>max_offset_ret</code> 这个值就代表了我们任务对应的 <code>vm_map_t</code> 的最大地址范围，比如说这里是8.375GB。</p><h2 id="虚拟内存分配的限制"><a href="#虚拟内存分配的限制" class="headerlink" title="虚拟内存分配的限制"></a>虚拟内存分配的限制</h2><p>之前提到了 <code>large_malloc</code> 会走入到最后的 <code>vm_map_enter</code> ，那么我们来看看 <code>vm_map_enter</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">vm_map_enter(</span><br><span class="line">    <span class="type">vm_map_t</span>        <span class="built_in">map</span>,</span><br><span class="line">    <span class="type">vm_map_offset_t</span>        *address,    <span class="comment">/* IN/OUT */</span></span><br><span class="line">    <span class="type">vm_map_size_t</span>        size,</span><br><span class="line">    <span class="type">vm_map_offset_t</span>        mask,</span><br><span class="line">    <span class="type">int</span>            flags,</span><br><span class="line">    <span class="type">vm_map_kernel_flags_t</span>    vmk_flags,</span><br><span class="line">    <span class="type">vm_tag_t</span>        alias,</span><br><span class="line">    <span class="type">vm_object_t</span>        object,</span><br><span class="line">    <span class="type">vm_object_offset_t</span>    offset,</span><br><span class="line">    <span class="type">boolean_t</span>        needs_copy,</span><br><span class="line">    <span class="type">vm_prot_t</span>        cur_protection,</span><br><span class="line">    <span class="type">vm_prot_t</span>        max_protection,</span><br><span class="line">    <span class="type">vm_inherit_t</span>        inheritance)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">    <span class="comment">// 注意点1:检查页的权限</span></span><br><span class="line">    <span class="keyword">if</span> (cur_protection &amp; VM_PROT_WRITE)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur_protection &amp; VM_PROT_EXECUTE) &amp;&amp; !entry_for_jit)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;EMBEDDED: %s: curprot cannot be write+execute. &quot;</span></span><br><span class="line">                   <span class="string">&quot;turning off execute\n&quot;</span>,</span><br><span class="line">                   __FUNCTION__);</span><br><span class="line">            cur_protection &amp;= ~VM_PROT_EXECUTE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resilient_codesign || resilient_media) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE)) ||</span><br><span class="line">            (max_protection &amp; (VM_PROT_WRITE | VM_PROT_EXECUTE))) &#123;</span><br><span class="line">            <span class="keyword">return</span> KERN_PROTECTION_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取任务的可用的地址最小值和最大值</span></span><br><span class="line">    effective_min_offset = <span class="built_in">map</span>-&gt;min_offset;</span><br><span class="line">    effective_max_offset = <span class="built_in">map</span>-&gt;max_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;pmap == kernel_pmap) &#123;</span><br><span class="line">        user_alias = VM_KERN_MEMORY_NONE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        user_alias = alias;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    RETURN(value)    &#123; result = value; goto BailOut; &#125;</span></span><br><span class="line"></span><br><span class="line">    assert(page_aligned(*address));</span><br><span class="line">    assert(page_aligned(size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!VM_MAP_PAGE_ALIGNED(size, VM_MAP_PAGE_MASK(<span class="built_in">map</span>))) &#123;</span><br><span class="line">        clear_map_aligned = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">StartAgain: ;</span><br><span class="line"></span><br><span class="line">    start = *address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anywhere) &#123;</span><br><span class="line">        vm_map_lock(<span class="built_in">map</span>);</span><br><span class="line">        map_locked = TRUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; effective_min_offset)</span><br><span class="line">            start = effective_min_offset;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; effective_max_offset)</span><br><span class="line">            RETURN(KERN_NO_SPACE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( FALSE ) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) &#123;</span><br><span class="line">                hole_entry = (<span class="type">vm_map_entry_t</span>)<span class="built_in">map</span>-&gt;holes_list;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hole_entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * No more space in the map?</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    result = KERN_NO_SPACE;</span><br><span class="line">                    <span class="keyword">goto</span> BailOut;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean_t</span> found_hole = FALSE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hole_entry-&gt;vme_start &gt;= start) &#123;</span><br><span class="line">                            start = hole_entry-&gt;vme_start;</span><br><span class="line">                            found_hole = TRUE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hole_entry-&gt;vme_end &gt; start) &#123;</span><br><span class="line">                            found_hole = TRUE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        hole_entry = hole_entry-&gt;vme_next;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">while</span> (hole_entry != (<span class="type">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (found_hole == FALSE) &#123;</span><br><span class="line">                        result = KERN_NO_SPACE;</span><br><span class="line">                        <span class="keyword">goto</span> BailOut;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    entry = hole_entry;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (start == <span class="number">0</span>)</span><br><span class="line">                        start += PAGE_SIZE_64;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">            <span class="type">vm_map_entry_t</span>    next;</span><br><span class="line"></span><br><span class="line">            end = ((start + mask) &amp; ~mask);</span><br><span class="line">            end = vm_map_round_page(end,</span><br><span class="line">                        VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end &lt; start)</span><br><span class="line">                RETURN(KERN_NO_SPACE);</span><br><span class="line"></span><br><span class="line">            start = end;</span><br><span class="line">            end += size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((end &gt; effective_max_offset) || (end &lt; start)) &#123;</span><br><span class="line">                RETURN(KERN_NO_SPACE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            next = entry-&gt;vme_next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;vme_end &gt;= end)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next == vm_map_to_entry(<span class="built_in">map</span>))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next-&gt;vme_start &gt;= end)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entry = next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry == (<span class="type">vm_map_entry_t</span>) <span class="built_in">map</span>-&gt;holes_list) &#123;</span><br><span class="line">                    result = KERN_NO_SPACE;</span><br><span class="line">                    <span class="keyword">goto</span> BailOut;</span><br><span class="line">                &#125;</span><br><span class="line">                start = entry-&gt;vme_start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = entry-&gt;vme_end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start = vm_map_round_page(start,</span><br><span class="line">                          VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;holelistenabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, entry-&gt;vme_start, &amp;entry)) &#123;</span><br><span class="line">                panic(<span class="string">&quot;Found an existing entry (%p) instead of potential hole at address: 0x%llx.\n&quot;</span>, entry, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)entry-&gt;vme_start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *address = start;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><ul><li>注意点1：基本上就是检查页的权限等，iOS上不允许可写和可执行并存。</li><li>剩下的就是作各种前置检查。</li></ul><p>如果上述代码不够清晰明了，如下这段代码可以更加的简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">entry = <span class="built_in">map</span>-&gt;first_free;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entry == vm_map_to_entry(<span class="built_in">map</span>)) &#123;</span><br><span class="line">    entry = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (entry-&gt;vme_next == vm_map_to_entry(<span class="built_in">map</span>))&#123;</span><br><span class="line">            entry = <span class="literal">NULL</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; (entry-&gt;vme_next)-&gt;vme_start ) &#123;</span><br><span class="line">                start = entry-&gt;vme_end;</span><br><span class="line">                start = vm_map_round_page(start,</span><br><span class="line">                              VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                entry = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="type">vm_map_entry_t</span>    tmp_entry;</span><br><span class="line">    <span class="keyword">if</span> (vm_map_lookup_entry(<span class="built_in">map</span>, start, &amp;tmp_entry)) &#123;</span><br><span class="line">        assert(!entry_for_jit);</span><br><span class="line">        start = tmp_entry-&gt;vme_end;</span><br><span class="line">        start = vm_map_round_page(start,</span><br><span class="line">                      VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    entry = tmp_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>整个这段代码的意思是，就是要我们要找个一个比我们这个 <code>start</code> 地址大的 <code>vm_entry_t</code> 。最终的目的是为了在两个已经存在 <code>vm_entry_t</code> 之间尝试插入一个能包含从 <code>start</code> 到 <code>start + size</code> 的新的 <code>vm_entry_t</code>。</li><li>如果没找到的话，就尝试利用 <code>vm_map_lookup_entry</code> 找一个 <code>preceding</code> 我们地址的的 <code>vm_entry_t</code> 。</li></ul><p>当找到了一个满足 <code>start</code> 地址条件的 <code>vm_entry_t</code> 后，剩下就是要满足分配大小 size 的需求了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">vm_map_entry_t</span>    next;</span><br><span class="line"></span><br><span class="line">    end = ((start + mask) &amp; ~mask);</span><br><span class="line">    end = vm_map_round_page(end,</span><br><span class="line">                VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line">    <span class="keyword">if</span> (end &lt; start)</span><br><span class="line">        RETURN(KERN_NO_SPACE);</span><br><span class="line"></span><br><span class="line">    start = end;</span><br><span class="line">    end += size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((end &gt; effective_max_offset) || (end &lt; start)) &#123;</span><br><span class="line">        RETURN(KERN_NO_SPACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next = entry-&gt;vme_next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空的头</span></span><br><span class="line">    <span class="keyword">if</span> (next == vm_map_to_entry(<span class="built_in">map</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个的start </span></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;vme_start &gt;= end)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    entry = next;</span><br><span class="line">    start = entry-&gt;vme_end;</span><br><span class="line">    start = vm_map_round_page(start,</span><br><span class="line">                  VM_MAP_PAGE_MASK(<span class="built_in">map</span>));</span><br><span class="line">&#125;</span><br><span class="line">*address = start;</span><br><span class="line">assert(VM_MAP_PAGE_ALIGNED(*address,</span><br><span class="line">               VM_MAP_PAGE_MASK(<span class="built_in">map</span>)));</span><br></pre></td></tr></table></figure><ul><li>判断 <code>start + size</code> 是不是可以正好插入在 <code>vm_entry_t</code> 代表的地址范围的空隙内，如果一直遍历到最后的任务地址上限都找不到，那就说明不存在我们需求的连续的虚拟内存空间用于作分配了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了本文说明的虚拟内存分配的连续性限制以外，虚拟内存作为堆内存分配的一种，在布局范围上也有限制。更多详细的信息可参考如下链接。</p><ul><li><a href="https://github.com/opensource-apple/xnu">XNU</a></li><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/MemoryManagement.html">Memory management</a></li><li><a href="https://www.jianshu.com/p/4f49c5c81021">iOS内存管理</a></li><li><a href="https://blog.devtang.com/2016/07/30/ios-memory-management/">理解 iOS 的内存管理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。&lt;/p&gt;
&lt;h2 id=&quot;虚拟内存概述&quot;&gt;&lt;a href=&quot;#虚拟内存概述&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存概述&quot;&gt;&lt;/a&gt;虚拟内存概述&lt;/h2&gt;&lt;p&gt;就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。&lt;/p&gt;
&lt;p&gt;如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。&lt;/p&gt;
&lt;p&gt;在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。&lt;/p&gt;
&lt;p&gt;无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。&lt;/p&gt;</summary>
    
    
    
    <category term="开发知识" scheme="https://zycslog.github.io/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="开发知识 iOS" scheme="https://zycslog.github.io/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"/>
    
  </entry>
  
  <entry>
    <title>What is Event Modeling?</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-10-23-what-is-event-modeling/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-10-23-what-is-event-modeling/</id>
    <published>2022-04-30T06:34:32.167Z</published>
    <updated>2022-04-30T06:34:32.168Z</updated>
    
    <content type="html"><![CDATA[<p>Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the clearest communication of the system’s workings to the largest possible cross-section of roles in an organization. The system can be checked for completeness by following the single thread of data propagation through it.</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Moore’s-Law"><a href="#Moore’s-Law" class="headerlink" title="Moore’s Law"></a>Moore’s Law</h3><p>Digitized Information Systems are a relatively new concept. Humans have been working with information systems for thousands of years. Over centuries banks, insurance companies and many other large scale organizations have managed to succeed.</p><p>With the advent of the transistor, the speed and accuracy of processing information increased by orders of magnitude. What did not gain the same quantum leap is digital storage. This imbalance caused information systems to be optimized for a very small amount of online information. You can see this in the advent of RDBMS technology. What it mean is that the compromise was to throw information away.</p><h3 id="Human-Memory"><a href="#Human-Memory" class="headerlink" title="Human Memory"></a>Human Memory</h3><p>Story telling is something that enables humans to pass knowledge on to subsequent generations and relies heavily on how we store memories - whether logical, visual, auditory or other. This is important because there is a parallel with how information systems were constructed. There is a “memory” of all your visits to the doctor. It’s the ledger of the forms that are filled in with each visit.</p><p>Specifications by example are a way to show how something is supposed to work. This can be seen in successful practices in software such as Behaviour Driven Development. This works well because we communicate by stories more effectively. It ties back to story telling as a way to keep information in society. Our brains are built for it more than they are built for flow-charts and other formats. </p><h2 id="Life-After-the-Dawn-of-the-Computer-Age"><a href="#Life-After-the-Dawn-of-the-Computer-Age" class="headerlink" title="Life After the Dawn of the Computer Age"></a>Life After the Dawn of the Computer Age</h2><p>In recent decades, Moore’s Law from the side of online storage has caught up. This means that after the initial few decades of living with computer systems, our information systems that are now digitized can use the mechanics that made them effective throughout history.</p><p>This means we have enough storage to not throw away information. The ability to be able to keep a history of all that has happened allows systems to be more reliable by means of audit and specification by example that literally translates to how the system is implemented.</p><p>We also have enough storage to have a cache of different views into what has happened in the system. This is important as we now have made the task of trying to fit all our concerns into one model an unnecessary constraint. In 1956, an IBM harddrive that stored 10MB cost $1M and required $30K monthly budget.</p><h3 id="Reality-of-Current-Tooling"><a href="#Reality-of-Current-Tooling" class="headerlink" title="Reality of Current Tooling"></a>Reality of Current Tooling</h3><p>So we are now at a cross-roads where we have very mature tooling, but that tooling is made for solving a problem we no longer have - being efficient with storage constraints. The new tooling that we see on the rise is what information systems always had: a ledger of what happened - storage is not a major issue anymore. There are many benefits to keeping ledger. They represent the natural way we think about systems - digital or not.</p><h2 id="The-Model-That-Works"><a href="#The-Model-That-Works" class="headerlink" title="The Model That Works"></a>The Model That Works</h2><p><img src="/images/event-modeling/blueprint_large.jpg" alt="blueprint"></p><p>Time is a concept that is now a core piece of describing a system. The components and classes that we saw in computing are not as important. We can show, by example, what a system is supposed to do from start to finish, on a time line and with no branching - again to make use of that memory aspect of our brains. This is the Event Model. It is used to follow all field values in the UI to the storage of those value to where they finally end up on a report or a screen. It’s generally done with sticky notes on a wall or whiteboard - or an online version of a whiteboard. We’ll see that simplicity is at the heart of the approach as we will only use 3 types of building blocks as well as traditional wireframes or mockups. Further to keep things simple, we will rely on only 4 patterns of how we structure the diagram.</p><h3 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h3><p>When we want to adopt certain practices or processes to help one another understand and communicate, it is inversely proportional to the amount of learning individuals must do to be proficient in those methods. Put in another way, if an organization chooses to adopt a process called “X”, and X requires one book and a workshop that takes a week to go through, it nullifies the effectiveness of X, and here’s the worst part, <strong>no matter how good X is</strong>.</p><p>When the book is a required reading by the people in an organization, everyone will say they have read it; only half will have actually read it; half of those will claim they understood it; and only half of those will have understood it; and half of those will be able to apply it.</p><p>This is why Event Modeling only uses 3 moving pieces and 4 patterns based on 2 ideas. It takes a few minutes to explain and the rest of the learning is done in practice, transparently where any deficiencies in the understanding of even those few core ideas are quickly corrected.</p><p>This is how you get to an understanding in an organization.</p><h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Let’s say we want to design a hotel website for a hotel chain for allowing our customers to book rooms online and for us to schedule cleaning and any other hotel concerns. We can show what events, or facts, are stored on a timeline of the year in that business. We can pretend we have the system already and ask ourselves what facts were stored as we move forward through time.</p><h3 id="Wireframes"><a href="#Wireframes" class="headerlink" title="Wireframes"></a>Wireframes</h3><p>To bring in the visual part of story-telling we show wireframes or web page mockups across the top. These can be organized in swim-lanes to show different people (or sometimes systems) interacting with our system. We also show any automation here with a symbol like gears to illustrate that the system is doing something. This has an easy to understand set of mechanics of a todo list that a process goes and does and marks items as done. In our hotel example, this could be a payment system or notification system.</p><p><img src="/images/event-modeling/innovate_large.jpg" alt="innovation"></p><p>At this point we have enough to be able to design some systems with some UX&#x2F;UI people. But there are 2 very fundamental pieces that must be added to the blueprint which show 2 core features of any information system: Empowering the user and informing the user.</p><h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p>Most information systems must give an ability for a user to affect state of the system. In our example, we must allow the booking of a room to change the system so that we don’t over-book and when that person arrives at that future date, they have a room ready for them.</p><p>Intentions to change the system are encapsulated in a command. As opposed to simply saving form data to a table in a database, this allows us to have a non-technical way to show the intentions while allowing any implementation - although certain ones have advantages as we will see.</p><p><img src="/images/event-modeling/empower_large.jpg" alt="empower"></p><p>From the UI and UX perspective this drives a “command based UI” which goes a long way into helping make composable UIs. With this pattern, it’s a lot clearer what the transactional boundaries are both from the technical and business perspectives. The hotel guest either registered successfully or not.</p><p>When there are nuances to what the prerequisites are for having a command succeed, they are elaborated on “Given-When-Then” style specifications. This is, again, a way to tell a story of what success looks like. There may be a few of these stories to show how a command can and cannot succeed.</p><p>An example might be “<strong>Given</strong>: We have registered, and added a payment method, <strong>When</strong>: We try to book a room, <strong>Then</strong>: a room is booked.” This form of specification is also referred to as “Arrange, Act, Assert” and in the UX&#x2F;UI world “Situation, Motivation, Value”.</p><h3 id="Views-or-Read-Models"><a href="#Views-or-Read-Models" class="headerlink" title="Views (or Read Models)"></a>Views (or Read Models)</h3><p>The second part of any information system is the ability to inform the user about the state of the system. Our hotel guest should know about what days are available for certain types of rooms they are interested in staying in. There are usually many of these and support the multi-model aspect of information systems.</p><p><img src="/images/event-modeling/inform_large.jpg" alt="inform"></p><p>A view into the facts already in the system has been changing as these new events were being stored. In our hotel system, this calendar view was being updated as new events that affected inventory were happening. Other views may be for the cleaning staff to see which rooms are ready to be cleaned as events about guests checking out are being stored.</p><p>Specifying how a view behaves is very similar to the way we specify how we accept commands with one difference. The views are passive and cannot reject an event after it’s been stored in the system. We have “<strong>Given</strong>: hotel is set up with 12 ocean view rooms, ocean view room was booked from April 4th - 12th X 12, <strong>Then</strong>: the calendar should show all dates except April 4th - 12th for ocean view availability”.</p><h3 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h3><p>We just covered the first 2 patterns of the 4 that are needed to describe most systems. Systems can get information from other systems and send information to other systems. It would be tempting to force these 2 patterns to be an extension of the first 2 and share the same space. However, these interactions are harder to communicate as they don’t have that human-visible aspect to them and require some higher level patterns.</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>When we have an external system that’s providing us with information, it’s helpful to translate that information into a form that is more familiar in our own system. In our hotel system, we may get events from guests’ GPS coordinates if they opted in to our highly reactive cleaning crew. We would not want to use longitude and latitude pairs as events to specify preconditions in our system. We would rather have events that mean something to us like “Guest left hotel”, “Guest returned to hotel room”.</p><p><img src="/images/event-modeling/understand_large.jpg" alt="understand"></p><p>Often, translations are simple enough to represent as views that get their information from external events. If we don’t use them as any “Given” parts of tests, the values they store in that view model are simply represented in the command parameters in our state change tests.</p><h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h3><p>Our system is going to need to communicate with external services. When the guests in our hotel are paying for their stay when they check out, our system makes a call to a payment processor. We can make the concept of how this occurs with the idea of a “todo list” for some processor in our system. This todo list shows tasks we need to complete. Our processor goes through that list from time to time (could be milliseconds or days) and sends out a command to the external system to process the payment, as an example. The reply from the external system is then translated into an event that we store back in our system. This way we keep the building blocks that we use in our system as something that’s meaningful to us.</p><p><img src="/images/event-modeling/automate_large.jpg" alt="automate"></p><p>We show this by putting a processor in the top of our blueprint which has the wireframes. This shows that there are things not evident on the screen but are happening behind the scenes. A user may expect a spinning icon to indicate a delay due to background tasks needing to finish. The specification for this has the form of “<strong>Given</strong>: A view of the tasks to do, <strong>When</strong> This command is launched for each item, <strong>Then</strong> These events are expected back.”</p><p>In reality, these may be implemented in many different ways such as queues, reactive or real-time constructs. They may even actually be manual todo lists that our employees use. The goal here is to communicate how our system communicates with the outside world when it needs to affect it. </p><h2 id="Workshop-Format-The-7-Steps"><a href="#Workshop-Format-The-7-Steps" class="headerlink" title="Workshop Format - The 7 Steps"></a>Workshop Format - The 7 Steps</h2><p>Event Modeling is done in 7 steps. We explained the end-goal already. So let’s rewind to the beginning and show how to build up to the blueprint:</p><h3 id="1-Brain-Storming"><a href="#1-Brain-Storming" class="headerlink" title="1. Brain Storming"></a>1. Brain Storming</h3><p><img src="/images/event-modeling/Step-1_large.jpg" alt="Step 1"></p><p>We have someone explain the goals of the project and other information. The participants then envision what system would look and behave like. They put down all the events that they can conceive of having happened. Here we gently introduce the concept that only state-changing events are to be specified. Often, people will name “guest viewed calendar for room availability”. We put those aside for now - they are not events.</p><h3 id="2-The-Plot"><a href="#2-The-Plot" class="headerlink" title="2. The Plot"></a>2. The Plot</h3><p><img src="/images/event-modeling/Step-2_large.jpg" alt="Step 2"></p><p>Now the task is to create a plausible story made of these events. So they are arranged in a line and everyone reviews this time line to understand that this makes sense as events that happen in order.</p><h3 id="3-The-Story-Board"><a href="#3-The-Story-Board" class="headerlink" title="3. The Story Board"></a>3. The Story Board</h3><p><img src="/images/event-modeling/Step-3_large.jpg" alt="Step 3"></p><p>Next, the wireframes or mockups of the story are needed to address those that are visual learners. More importantly, each field must be represented so that the blueprint for the system has the source of and destination of the information represented from the user’s perspective.</p><h4 id="3-1-UX-Concurrency"><a href="#3-1-UX-Concurrency" class="headerlink" title="3.1 UX Concurrency"></a>3.1 UX Concurrency</h4><p>The wireframes are generally put at the top of the blueprint. They can be divided into separate swimlanes to show what each user sees if there is more than one. There are no screens that appear above one another as we need to capture each change in the system state as a separate vertical slice of the blueprint. The different ordering can be shown in the various specifications. If it is core to the system or very important to communicate, alternate workflows will need to be added to the blueprint. This is part of the last step that shows organization but can be done earlier if helpful.</p><h3 id="4-Identify-Inputs"><a href="#4-Identify-Inputs" class="headerlink" title="4. Identify Inputs"></a>4. Identify Inputs</h3><p><img src="/images/event-modeling/Step-4_large.jpg" alt="Step 4"></p><p>From the earlier section we saw that we need to show how we enable the user to change the state of the system. This is usually the step in which we do this introduction of these blue boxes. Each time an event is stored due to a users action, we link that to the UI by a command that shows what we are getting from the screen or implicitly from client state if it’s a web application.</p><h3 id="5-Identify-Outputs"><a href="#5-Identify-Outputs" class="headerlink" title="5. Identify Outputs"></a>5. Identify Outputs</h3><p><img src="/images/event-modeling/Step-5_large.jpg" alt="Step 5"></p><p>Again looking back at our goals for the blueprint, we now have to link information accumulated by storing events back into the UI via views (aka read-models). These may be things like the calendar view in our hotel system that will show the availability of rooms when a user is looking to book a room. </p><h3 id="6-Apply-Conway’s-Law"><a href="#6-Apply-Conway’s-Law" class="headerlink" title="6. Apply Conway’s Law"></a>6. Apply Conway’s Law</h3><p><img src="/images/event-modeling/Step-6_large.jpg" alt="Step 6"></p><p>Now that we know how information gets in and out of our system, we can start to look at organizing the events themselves into swimlanes. We need to do this to allow the system to exist as a set of autonomous parts that separate teams can own. This allows specialization to happen to a level that we control instead of falling out of the composition of teams. See <a href="http://melconway.com/Home/Conways_Law.html">Conway’s Law</a> by Mel Conway.</p><h3 id="7-Elaborate-Scenarios"><a href="#7-Elaborate-Scenarios" class="headerlink" title="7. Elaborate Scenarios"></a>7. Elaborate Scenarios</h3><p>Each workflow step is tied to either a command or a view&#x2F;read-model. The specifications were explained earlier on. How we make them is still collaboratively with all participants in the same space. A Give-When-Then or Given-Then can be constructed one after the other very rapidly while being reviewed by multiple role representatives. This allows what is traditionally done as user story writing by a dedicated product owner in isolation in a text format, to be done visually in a very small amount of time collaboratively. What’s very critical here, is that each specification is tied to exactly one command or view.</p><h3 id="Completeness-Check"><a href="#Completeness-Check" class="headerlink" title="Completeness Check"></a>Completeness Check</h3><p>At this time the event model should have every field accounted for. All information has to have an origin and a destination. Events must facilitate this transition and hold the necessary fields to do so. This rigor is what is required to get the most benefits of the technique.</p><p>A variation of this is where we don’t do this final check and rely on absorbing the rework costs. There are scenarios where this is desired.</p><h2 id="Project-Management"><a href="#Project-Management" class="headerlink" title="Project Management"></a>Project Management</h2><p>The final output of the exercise if done to completion is a set of very small projects defined by all the scenarios for each workflow step. They are in a format that allows them to be directly translated to what developers will use to make their unit tests. They are also coupled to the adjacent workflow steps by only the contract.</p><p><img src="/images/event-modeling/parallel_large.jpg" alt="parallel effort"></p><h3 id="Strong-Contracts"><a href="#Strong-Contracts" class="headerlink" title="Strong Contracts"></a>Strong Contracts</h3><p>Many project management, business and coordination issues are mitigated by the fact that we have made explicit contracts as to the shape of the information of when we start a particular step of the workflow and what is the shape of the data when it’s finished. These pre- and post-conditions are what allows the work to be completed in relative isolation and later snap together with the adjoining steps as designed.</p><h4 id="Flat-Cost-Curve"><a href="#Flat-Cost-Curve" class="headerlink" title="Flat Cost Curve"></a>Flat Cost Curve</h4><p>The biggest impact of using Event Modeling is the flat cost curve of the average feature cost. This is due to the fact that the effort of building each workflow step is not impacted by the development of other workflows. One important thing to understand, is that a workflow step is considered to be repeated on the event model if it uses the same command or view. </p><p><img src="/images/event-modeling/flat-cost-curve.jpg" alt="flat cost curve"></p><p>The impact of this is very far reaching because it is what changes software development back into an engineering practice. It’s what makes creating an information system work like the construction of a house. Features can be created in any order. Traditional development cannot rely on estimates because whether the feature gets developed early on versus later in the project impacts the amount of work required. Reprioritizing work makes any previous estimates unreliable.</p><h4 id="Done-is-Done-Done-Right"><a href="#Done-is-Done-Done-Right" class="headerlink" title="Done is Done Done Right"></a>Done is Done Done Right</h4><p>When a workflow step is implemented, the act of implementing any other workflow step does not cause the need to revisit this already complete workflow step. It’s the reason that the constant feature cost curve can be realized.</p><h4 id="Estimates-without-Estimating"><a href="#Estimates-without-Estimating" class="headerlink" title="Estimates without Estimating"></a>Estimates without Estimating</h4><p>With a constant cost curve, the effort for an organization to implement can simply be measured over many features over time. This is an impartial way to empirically determine the velocity of teams. These numbers are then used to scope, schedule and cost out future projects.</p><h5 id="Technical-Side-Note-About-Test-Driven-Development"><a href="#Technical-Side-Note-About-Test-Driven-Development" class="headerlink" title="Technical Side-Note About Test Driven Development"></a>Technical Side-Note About Test Driven Development</h5><p>This is the impact of the adoption of Agile practices in the industry to put band-aids over the core issue of lack of design. Because the scope of each set of requirements is now per workflow step, the refactoring step of TDD does not impact other workflow steps in the event model. When we don’t have an event model, refactoring goes unrestricted and previously completed pieces of work have to be adjusted. The more work is already completed, the more that has to be reviewed and adjusted with each new addition as we build the solution.</p><h4 id="Subcontracting"><a href="#Subcontracting" class="headerlink" title="Subcontracting"></a>Subcontracting</h4><p>The constant cost curve gives the opportunity to do fixed-cost projects. Once there is a velocity established for a team, you have the cost of the software for your organization. With this number, you now can price out what you are willing to give contractors in pay for each workflow step they complete.</p><h5 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h5><p>Since each workflow step is protected from being affected by other workflow steps, any deficiencies are to be guaranteed by who is delivering them with non-billable work. So in the case of a subcontractor doing a bad job just to get more billable items done quickly, they will have to have the next hours of work dedicated to fixing deficiencies of work already done before. This evens out their effective rate of pay because they are not working on new delivarables.</p><p>This can be carried out over longer periods within an employee engagement by making these metrics available through different checkpoints for performance.</p><p>Due to the effective pay self-adjusting to the capability of the individual, it is also a way to on-board new employees and pay them fairly while they are in the probation stage of the engagement. This contract-to-hire process removes the subjective and largely ineffective interview process for technical positions.</p><h4 id="Prioritization"><a href="#Prioritization" class="headerlink" title="Prioritization"></a>Prioritization</h4><p>Moving work on a schedule as to what steps are going to be implemented first is done without changing the estimated costs of each item. This ensures that prioritization of work has no impact in the total cost also. The constant cost curve is required to allow this “agility” of reprioritizing features.</p><h4 id="Change-Management"><a href="#Change-Management" class="headerlink" title="Change Management"></a>Change Management</h4><p>When the plans change, we simply adjust the event model. This is usually done by just copying the current one and adjusting. Now we can see where the differences are. If a new piece of information is added to one event, that constitutes a new version of the workflow that creates it. Same with the views. If these have not been implemented yet, they don’t change our estimate. If they are already implemented, they add another unit of work to our plan because it’s considered a replacement. There are a few more rules around this. The end result is a definitive guide for change management.</p><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p><img src="/images/event-modeling/arrows_large.jpg" alt="security arrows"></p><p>With an event model, the solution shows exactly where, and equally importantly, when sensitive data crosses boundaries. With traditional audits, the number of interviews with staff was time consuming and at risk of missing important areas. Security concerns are addressed most responsibly when the applications have an event model to reference.</p><h2 id="Legacy-Systems"><a href="#Legacy-Systems" class="headerlink" title="Legacy Systems"></a>Legacy Systems</h2><p>Most of the scenarios that real organizations face is where a system is already in place. The main way to deal with a system that is hard to manage because of complexity and lack of understanding is to either rewrite it or to refactor it while it runs. Both of these are very costly.</p><p>A third, less risky option exists: Freeze the old system. With proper buy-in, the organization can agree to not alter the existing system. Instead, dealing with bugs and adding new functionality is done on the side as a side-car solution.</p><p>Events can be gathered from the database of the old system and make views of that state - employing the <a href="#translation">translate</a> pattern described previously. Y-valve redirection of user action can add new functionality in the side solution. An example which fixes a bug (notice that we use the <a href="./#automation">external integration pattern</a> and extends the old system to add profile pictures is shown here:</p><p><img src="/images/event-modeling/event-modeling-legacy-side-car.jpg" alt="legacy side car event model"></p><p>This pattern allows an organization to stop putting energy into the sub-optimal existing system and get unblocked from delivering value via the patterns that enable the benefits of the Event Model.</p><h2 id="Conclusion-for-Now"><a href="#Conclusion-for-Now" class="headerlink" title="Conclusion for Now"></a>Conclusion for Now</h2><p>Event Modeling is changing how information systems are built. With simple repeatable patterns, information systems are as predicable as engineering efforts should be.</p><h2 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h2><p>This content reprinted from <a href="https://eventmodeling.org/posts/what-is-event-modeling/">Event Modeling: What is it?</a></p><p>Thanks.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the cleares</summary>
      
    
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="技术人生" scheme="https://zycslog.github.io/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>\#9\ 一般树与树节点遍历</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/</id>
    <published>2022-04-30T06:34:32.166Z</published>
    <updated>2022-04-30T06:34:32.166Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p><ul><li>等级关系的描述</li><li>分类数据的管理</li><li>分类查找操作</li></ul><p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>类似链表，树也是由节点构成的。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/node.png"></p><p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p><h3 id="父节点和子节点"><a href="#父节点和子节点" class="headerlink" title="父节点和子节点"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p><p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png"></p><h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/root.png"></p><h3 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png"></p><h2 id="Swift树结构实现"><a href="#Swift树结构实现" class="headerlink" title="Swift树结构实现"></a>Swift树结构实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">TreeNode</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p><p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节点添加新的子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">child</span>: <span class="type">TreeNode</span>) &#123;</span><br><span class="line">    children.append(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time to give it a whirl.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Create a tree&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> beverages <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    beverages.add(hot)</span><br><span class="line">    beverages.add(cold)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(beverages.value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">0</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">1</span>].value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Create a tree---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">Hot</span></span><br><span class="line"><span class="comment">Cold</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png"></p><h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png"></p><p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png"></p><p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachDepthFirst</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.forEachDepthFirst(visit: visit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeBeverageTree</span>() -&gt; <span class="type">TreeNode</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> coffee <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chocolate <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> blackTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> greenTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chaiTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> soda <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;sida&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> milk <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> gingerAle <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bitterLemon <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    </span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    </span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    </span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    </span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该树的形态如下：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png"></p><p>接下来在这棵树上测试深度优先遍历。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;depth-first traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of depth-first traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachLevelOrder</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&gt;()</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            queue.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst() &#123;</span><br><span class="line">            visit(node)</span><br><span class="line">            node.children.forEach &#123;</span><br><span class="line">                queue.append(<span class="variable">$0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;level-order traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachLevelOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of level-order traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">search</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">TreeNode</span>?</span><br><span class="line">        forEachLevelOrder &#123; node <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">                result <span class="operator">=</span> node</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;searching for a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult1 <span class="operator">=</span> tree.search(<span class="string">&quot;ginger ale&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found node: <span class="subst">\(searchResult1.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult2 <span class="operator">=</span> tree.search(<span class="string">&quot;WKD Blue&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(searchResult2.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of searching for a node---</span></span><br><span class="line"><span class="comment">Found node: ginger ale</span></span><br><span class="line"><span class="comment">Couldn&#x27;t find WKD Blue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul><li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li><li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li><li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li></ul><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png"></p><p>打印的结果应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 </span><br><span class="line">1 17 20 </span><br><span class="line">1 5 0 2 5 7</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printEachLevel</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">tree</span>: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    queue.append(tree)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>queue.isEmpty &#123;</span><br><span class="line">        nodesLeftInCurrentLevel <span class="operator">=</span> queue.count</span><br><span class="line">        <span class="keyword">while</span> nodesLeftInCurrentLevel <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst()  <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(node.value)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">            node.children.forEach &#123; queue.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">            nodesLeftInCurrentLevel <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算机编程的世界中，&lt;strong&gt;树&lt;/strong&gt;是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等级关系的描述&lt;/li&gt;
&lt;li&gt;分类数据的管理&lt;/li&gt;
&lt;li&gt;分类查找操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在计算机算</summary>
      
    
    
    
    <category term="Data Structures &amp; Algorithms in Swift" scheme="https://zycslog.github.io/categories/Data-Structures-Algorithms-in-Swift/"/>
    
    
    <category term="Swift中的数据结构与算法" scheme="https://zycslog.github.io/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>\#13\ 字典树（Tries Tree）</title>
    <link href="https://zycslog.github.io/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/"/>
    <id>https://zycslog.github.io/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/</id>
    <published>2022-04-30T06:34:32.165Z</published>
    <updated>2022-04-30T06:34:32.166Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p>例如利用Tries表示一个英语单词，可以表示如下：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png"></p><p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> words: [<span class="type">String</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">words</span>(<span class="params">matching</span> <span class="params">prefix</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> words.filter &#123; <span class="variable">$0</span>.hasPrefix(<span class="keyword">prefix</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p><p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p><p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p><p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png"></p><p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p><p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png"></p><p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png"></p><h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Key</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> parent: <span class="type">TrieNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">Key</span>: <span class="type">TrieNode</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">key</span>: <span class="type">Key</span>?, <span class="params">parent</span>: <span class="type">TrieNode</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tries的节点结构和其他树型数据结构有明显的不同。</p><ul><li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li><li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li><li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li><li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li></ul><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&lt;<span class="title class_">CollectionType</span>: <span class="title class_">Collection</span>&gt; <span class="title class_">where</span> <span class="title class_">CollectionType</span>.<span class="title class_">Element</span>: <span class="title class_">Hashable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> <span class="operator">=</span> <span class="type">TrieNode</span>&lt;<span class="type">CollectionType</span>.<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> root <span class="operator">=</span> <span class="type">Node</span>(key: <span class="literal">nil</span>, parent: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p><p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p><h2 id="操作算法实现"><a href="#操作算法实现" class="headerlink" title="操作算法实现"></a>操作算法实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[element] <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[element] <span class="operator">=</span> <span class="type">Node</span>(key: element, parent: current)</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> current.children[element]<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    current.isTerminating <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li><li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li><li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li></ul><p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p><h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isTerminating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p><p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insert and contains&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> trie.contains(<span class="string">&quot;cute&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cute is in the trie&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insert and contains---</span></span><br><span class="line"><span class="comment">cute is in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> current.isTerminating <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent <span class="operator">=</span> current.parent, current.children.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>current.isTerminating &#123;</span><br><span class="line">            parent.children[current.key<span class="operator">!</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            current <span class="operator">=</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li><li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li><li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li></ul><p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** Before removeing ***&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cut<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** After removing cut ***&quot;</span>)</span><br><span class="line">    trie.remove(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is still in the trie&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of remove---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Before removeing ***</span></span><br><span class="line"><span class="comment">&quot;cut&quot; is in the trie</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is in the trie</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** After removing cut ***</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is still in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Prefix-matching"><a href="#Prefix-matching" class="headerlink" title="Prefix matching"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> <span class="title class_">where</span> <span class="title class_">CollectionType</span>: <span class="title class_">RangeReplaceableCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">prefix</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> collections(startingWith: <span class="keyword">prefix</span>, after: current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li><li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">CollectionType</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.isTerminating &#123;</span><br><span class="line">        results.append(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children.values &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">        <span class="keyword">prefix</span>.append(child.key<span class="operator">!</span>)</span><br><span class="line">        results.append(contentsOf: collections(startingWith: <span class="keyword">prefix</span>, after: child))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li><li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li></ul><p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p><p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;prefix matching&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;car&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;card&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;care&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cared&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cars&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carbs&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carapace&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cargo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>car<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCar <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;car&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCar)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>care<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCare <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;care&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of prefix matching---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;car&quot;</span></span><br><span class="line"><span class="comment">[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;care&quot;</span></span><br><span class="line"><span class="comment">[&quot;care&quot;, &quot;cared&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul><li>Trie树在前缀匹配上有着卓越的性能表现；</li><li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Tries&lt;/strong&gt; 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个</summary>
      
    
    
    
    <category term="Data Structures &amp; Algorithms in Swift" scheme="https://zycslog.github.io/categories/Data-Structures-Algorithms-in-Swift/"/>
    
    
    <category term="Swift中的数据结构与算法" scheme="https://zycslog.github.io/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>\#19\ 基数排序（Radix Sort）</title>
    <link href="https://zycslog.github.io/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/"/>
    <id>https://zycslog.github.io/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/</id>
    <published>2022-04-30T06:34:32.165Z</published>
    <updated>2022-04-30T06:34:32.165Z</updated>
    
    <content type="html"><![CDATA[<p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p><p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure><p>基数排序依赖于整数的位置表示法，如下：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png"></p><p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png"></p><p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">410</span>, <span class="number">20</span>, <span class="number">1772</span>, <span class="number">88</span>]</span><br></pre></td></tr></table></figure><p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png"></p><p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p><p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png"></p><p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure><p>最后，在堆集合中的元素进行千位拆解：</p><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png"></p><p>重新按照千位拆解结果进行排序，结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure><p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">radixSort</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> base <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> digits <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>done &#123;</span><br><span class="line">            <span class="comment">// more to come</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p><ol><li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li><li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li></ol><p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p><h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buckets: [[<span class="type">Int</span>]] <span class="operator">=</span> .<span class="keyword">init</span>(repeating: [], count: base)</span><br><span class="line">            </span><br><span class="line">forEach &#123;</span><br><span class="line">    number <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> remainingPart <span class="operator">=</span> number <span class="operator">/</span> digits</span><br><span class="line">    <span class="keyword">let</span> digit <span class="operator">=</span> remainingPart <span class="operator">%</span> base</span><br><span class="line">    buckets[digit].append(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digits <span class="operator">*=</span> base</span><br><span class="line"><span class="keyword">self</span> <span class="operator">=</span> buckets.flatMap &#123; <span class="variable">$0</span> &#125;</span><br></pre></td></tr></table></figure><ol><li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li><li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li><li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li></ol><p><strong>循环何时结束？</strong></p><p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p><ol><li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li><li>在forEach闭包结构中，增加如下语句：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remainingPart <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;radix sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    array.radixSort()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Radix sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of radix sort---</span></span><br><span class="line"><span class="comment">Original: [88, 410, 1772, 20]</span></span><br><span class="line"><span class="comment">Radix sorted: [20, 88, 410, 1772]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p><p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p><h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul><li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p></li><li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p></li><li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。&lt;/p&gt;
&lt;p&gt;为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; clas</summary>
      
    
    
    
    <category term="Data Structures &amp; Algorithms in Swift" scheme="https://zycslog.github.io/categories/Data-Structures-Algorithms-in-Swift/"/>
    
    
    <category term="Swift中的数据结构与算法" scheme="https://zycslog.github.io/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从Keras开始构建iOS平台手写数字实时识别</title>
    <link href="https://zycslog.github.io/2022/04/30/2019-01-22-keras_mnist_for_iOS/"/>
    <id>https://zycslog.github.io/2022/04/30/2019-01-22-keras_mnist_for_iOS/</id>
    <published>2022-04-30T06:34:32.164Z</published>
    <updated>2022-04-30T06:34:32.164Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。</p><h1 id="10步之内完成模型的构建、训练和发布使用"><a href="#10步之内完成模型的构建、训练和发布使用" class="headerlink" title="10步之内完成模型的构建、训练和发布使用"></a><strong>10步之内完成模型的构建、训练和发布使用</strong></h1><p><strong>TLDR；</strong></p><p>本文中暂时不会介绍卷积神经网络的细节内容，例如如何使用卷积层、池化层训练深度学习网络，以及如何使用预训练模型识别目标等，相关卷积神经网络细节的内容将会放在本文内容之后，进行详细的介绍。本文旨在介绍如何一步一步的从数据的获取、整理、模型的构建、训练以及后面的格式转换、使用等介绍Keras框架的基本使用和如何使用CoreML体系在一个实实在在的应用程序中使用模型等。</p><p>下图是最终结果的预览：</p><p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p><p>接下来，开始一步步的实现相关的过程等。</p><h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1. 如何开始"></a>1. <strong>如何开始</strong></h2><p>To have a fully working example I thought we’d start with a toy dataset like the <a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST set of handwritten letters</a> and train a deep learning network to recognize those. Once it’s working nicely on our PC, we will port it to an iPhone X using the <a href="https://developer.apple.com/documentation/coreml">CoreML standard</a>.</p><p>在计算机程序设计学习的过程中，几乎都是以一个经典的“Hello World”程序开始的。而在机器学习领域，同样具有类似“Hello World”的一个经典入门级数据集——<a href="https://en.wikipedia.org/wiki/MNIST_database">MNIST</a>，该数据集是一系列手写数字0到9的图片文件，这里的目的是使用这个数据集训练一个深度学习网络来识别它们。在开始之前，你或许对iOS平台的CoreML以及keras还很陌生，你可以先了解一下它们的体系和设计：</p><ul><li>CoreML：</li></ul><p><a href="https://developer.apple.com/documentation/coreml">Core ML | Apple Developer Documentation</a></p><ul><li>Keras：</li></ul><p><a href="https://keras.io/zh/">Keras 中文文档</a></p><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>在大多数的Python机器学习类库中，都有内置的数据集访问接口，以方便使用者的使用，在Keras中也不例外，可以很方便的使用其内置的数据集访问接口获取数据集，具体的接口定义在<code>keras.datasets</code>中，具体的使用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Keras内置数据集访问接口导入数据集并对数据集进行转换</span></span><br><span class="line">    <span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">    <span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line">    <span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mnist_data</span>():</span><br><span class="line">        <span class="comment"># 定义输入图像的维度</span></span><br><span class="line">        img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line">        <span class="comment"># 加载数据集</span></span><br><span class="line">        (X_train, Y_train), (X_test, Y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 数据缩放，将原来的 [0, 255] 缩放至 [0, 1]</span></span><br><span class="line">        X_train = X_train.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">        X_test = X_test.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 对原始数据中的目标值进行One-Hot Encoding，使得目标数据更加的稀疏</span></span><br><span class="line">        Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">        Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> (X_train, Y_train), (X_test, Y_test), input_shape</span><br><span class="line">    </span><br><span class="line">    (X_train, Y_train), (X_test, Y_test), input_shape = mnist_data()</span><br></pre></td></tr></table></figure><h2 id="3-正确地编码"><a href="#3-正确地编码" class="headerlink" title="3. 正确地编码"></a>3. 正确地编码</h2><p>当处理图片数据的时候，必须要区分想要的编码方式。Keras是一个可以处理多个“后端”的高级库，例如<a href="https://www.tensorflow.org/">Tensorflow</a>, <a href="http://deeplearning.net/software/theano/">Theano</a> 和 <a href="https://www.microsoft.com/en-us/cognitive-toolkit/">CNTK</a>，首先我们要了解我们所使用的后端是如何编码数据的。在Keras默认使用的TensorFlow后端中，针对图像的处理通常是以“通道优先”或“通道末尾”的方式进行编码的，因此在我们的使用TensorFlow作为后端的时候，编码结果其实是一个张量，其形状为(batch_size, rows, cols, channels)。意味着首先是输入的batch_size，然后输入28行28列的图像维度，最后输入1作为通道数，因为我们使用的是灰度图像数据。</p><p>我们可以看看前6张图像具体是什么样子，可以使用如下代码查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化数据集中前6张图像</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    %matplotlib inline</span><br><span class="line">    <span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line">    (X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">6</span>, i+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        ax.imshow(X_train[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="built_in">str</span>(y_train[i]))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://liip.rokka.io/www_inarticle/7cce04/numbers.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-规范化数据"><a href="#4-规范化数据" class="headerlink" title="4. 规范化数据"></a>4. 规范化数据</h2><p>可以看到，在黑色背景中显示了白色数字，每一张图像中的数字都是居中的，而且分辨率都很低——在这个例子中我们使用的是28x28像素。</p><p>你可能已经注意到，在上述获取数据的部分，我们对每一张图片除以255来缩放了图像像素，这导致像素值在0和1之间，这对于任何类型的训练都非常有用。每个图像像素值在转换之前都是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用像素值可视化一个数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_input</span>(<span class="params">img, ax</span>):</span><br><span class="line">    ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    width, height = img.shape</span><br><span class="line">    thresh = img.<span class="built_in">max</span>()/<span class="number">2.5</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            ax.annotate(<span class="built_in">str</span>(<span class="built_in">round</span>(img[x][y], <span class="number">2</span>)),</span><br><span class="line">                        xy=(y, x),</span><br><span class="line">                        horizontalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        verticalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        color=<span class="string">&#x27;white&#x27;</span> <span class="keyword">if</span> img[x][y] &lt; thresh <span class="keyword">else</span> <span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">visualize_input(X_train[<span class="number">0</span>], ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/keras-mnist-for-ios/pixes-daf69647-717f-499d-aa39-fa83904d7675.png"></p><p>可以看到图像中的每个灰度像素都是介于0到255之间的，并且当像素为255时，背景色为白色，像素为0时，背景色为黑色。在这里使用的是<code>mnist.load_data()</code>加载的数据集，此时并没有对图像进行像素缩放，而在我们自定义的数据集加载方法<code>mnist_data()</code>方法中，我们进行了像素的缩放，<code>X_train = X_train.astype(&#39;float32&#39;)/255</code> 。</p><h2 id="5-One-Hot-编码"><a href="#5-One-Hot-编码" class="headerlink" title="5. One-Hot 编码"></a>5. One-Hot 编码</h2><p>最初，数据以Y-Vector包含X Vector（像素数据）包含的数值的方式编码。例如，如果图像看起来像7，那么Y-Vector中必定包含数字7。但是这种方式不利于我们在网络结构中直接使用，我们需要进行这种转换，希望将数据的输出映射到网络中的10个输出神经元，此时当相应的数字被识别时，相应的神经元就会触发，从而达到有效的识别。</p><p><img src="https://liip.rokka.io/www_inarticle/46a2ef/onehot.png"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="6-网络模型化"><a href="#6-网络模型化" class="headerlink" title="6. 网络模型化"></a>6. 网络模型化</h2><p>了解了数据集的基本情况以及进行合理的数据转换后，该是定义卷积神经网络的时候了。这里讲直接使用卷积神经网络中的卷积层和池化层来定义网络，具体实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义网络模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adadelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">network</span>():</span><br><span class="line">    model = Sequential()</span><br><span class="line">    input_shape = (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">500</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型概述</span></span><br><span class="line">    <span class="built_in">print</span>(model.summary())</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>在模型的定义中，我们以内核大小为3的<a href="https://keras.io/layers/convolutional/">卷积</a>，这也意味着窗口为3x3像素，输入形状的大小为28x28像素。紧跟着使用了一个池化大小为2的<a href="https://keras.io/layers/pooling/">池化层</a>，这里的池化大小为2，意味着将会对每一个输入缩减为原来的一般，因此在下一个卷积层中，输入大小为14x14像素。按照此方式重复两次后，最终的卷积输入大小转换为3x3像素。接下来，使用了<a href="https://keras.io/layers/core/#dropout">Dropout层</a>，将30%的输入单元随机设置为0，以防止训练的过拟合。最后，展平输入层（此例子中为3x3x32&#x3D;288），并将它们连接到一个具有500个输入的密度层。在这些步骤之后，添加了另一个Dropout层，之后连接到最后的密度层，该密度层中包含10个输出单元，这些输出单元对应着我们的目标类别，0到9之间的数字。</p><pre><code>_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_1 (Conv2D)            (None, 28, 28, 32)        320       _________________________________________________________________max_pooling2d_1 (MaxPooling2 (None, 14, 14, 32)        0         _________________________________________________________________conv2d_2 (Conv2D)            (None, 14, 14, 32)        4128      _________________________________________________________________max_pooling2d_2 (MaxPooling2 (None, 7, 7, 32)          0         _________________________________________________________________conv2d_3 (Conv2D)            (None, 7, 7, 32)          4128      _________________________________________________________________max_pooling2d_3 (MaxPooling2 (None, 3, 3, 32)          0         _________________________________________________________________dropout_1 (Dropout)          (None, 3, 3, 32)          0         _________________________________________________________________flatten_1 (Flatten)          (None, 288)               0         _________________________________________________________________dense_1 (Dense)              (None, 500)               144500    _________________________________________________________________dropout_2 (Dropout)          (None, 500)               0         _________________________________________________________________dense_2 (Dense)              (None, 10)                5010      =================================================================Total params: 158,086Trainable params: 158,086Non-trainable params: 0_________________________________________________________________</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7. 训练模型"></a>7. 训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = network()</span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=Adadelta(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用训练数据拟合模型</span></span><br><span class="line">model.fit(X_train, Y_train, batch_size=<span class="number">512</span>, epochs=<span class="number">6</span>, verbose=<span class="number">1</span>, validation_data=(X_test, Y_test))</span><br><span class="line"><span class="comment"># 模型评估分数</span></span><br><span class="line">score = model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里使用了<code>categorical_crossentropy</code>作为损失函数，因为我们的目标类别有多个（0至9），Keras库提供了多种<a href="https://keras.io/optimizers/#usage-of-optimizers">优化器</a>，你可以选择任意一个进行模型训练，并最终找到一个最好的。经过尝试之后，这里选择<a href="https://keras.io/optimizers/#adadelta"><code>AdaDelta</code></a>作为优化器进行模型训练，当然你也可以尝试AdaDelta的高级版<a href="https://keras.io/optimizers/#adagrad">AdaGrad</a>。</p><p><img src="https://liip.rokka.io/www_inarticle/42b4b8/train.png"></p><p>可以看到，经过训练，所得到的模型识别准确率达到了98%，考虑到这里仅仅使用了简单的网络结构，达到这样的准确率已经是非常出色了。在上述截图中，每次迭代的准确性都是在提高，可以说明这里使用的简单结构是合理的，训练得到的模型可以很好地预测输入28x28像素所表示的数字。</p><h2 id="8-保存模型"><a href="#8-保存模型" class="headerlink" title="8. 保存模型"></a>8. 保存模型</h2><p>由于我们想要在iOS设备上使用该模型，因此需要将该模型转换为iOS系统能够理解的格式。实际上，微软、Facebook以及亚马逊等企业已经研发出了一套能够在所有深度学习网络格式见转换的协议，以便能够在任何设备上使用的可交换的开放式神经网络交换格式——<a href="https://onnx.ai/">ONNX</a>。</p><p>但是，截止目前，Apple设备上仅仅能够使用的是CoreML格式。为了能够将Keras模型转换为CoreML格式，Apple特意推出来一个非常方便的帮助类库——<a href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">coremltools</a>，这里我们就可以使用该类库来完成工作。该类库能够将scikit-learn、Keras、XGBoost等机器学习类库训练的模型转换为CoreML支持的格式，从而使得模型能够直接在Apple设备上使用。如果你还未安装coremltools类库，可以使用<code>pip install coremltools</code>进行安装，然后再使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coreml_model = coremltools.converters.keras.convert(model,</span><br><span class="line">                                                        input_names=<span class="string">&quot;image&quot;</span>,</span><br><span class="line">                                                        image_input_names=<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">                                                        class_labels=[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">                                                        )</span><br></pre></td></tr></table></figure><p>在进行模型转换的时候，最重要的参数是class_labels，它定义了模型尝试预测的类数，以及input_names或者image_input_names。通过将它们设置为图像，Xcode会自动识别该模型是关于接收图像并从中预测某些内容，也就是说这些参数是告诉Xcode，该模型是关于那方面的任务。根据应用程序和模型的特定功能，需要研究<a href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">官方文档</a>进一步的了解这些参数的可选值等。</p><p>另外还有一些可以定义模型元信息的参数，这些参数可以给模型一个简要的说明，甚至作者、license等，可以让使用者能够方便的查阅模型所针对的特定任务等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑模型元信息</span></span><br><span class="line">coreml_model.author = <span class="string">&#x27;Robin&#x27;</span></span><br><span class="line">coreml_model.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">coreml_model.short_description = <span class="string">&#x27;MNIST handwriting recognition with a 3 layer network&#x27;</span></span><br><span class="line">coreml_model.input_description[<span class="string">&#x27;image&#x27;</span>] = <span class="string">&#x27;28x28 grayscaled pixel values between 0-1&#x27;</span></span><br><span class="line">coreml_model.save(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coreml_model)</span><br></pre></td></tr></table></figure><h2 id="9-使用模型预测"><a href="#9-使用模型预测" class="headerlink" title="9. 使用模型预测"></a>9. 使用模型预测</h2><p>在将模型保存为CoreML格式之后，我们可以尝试使用转换后的模型进行一个预测，来确定模型是否工作正常。在这里我们将从MNIST数据集中选择一张图像进行预测验证。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用CoreML模型预测验证</span></span><br><span class="line"> <span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> model =  coremltools.models.MLModel(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"> im = Image.fromarray((np.reshape(mnist_data()[<span class="number">0</span>][<span class="number">0</span>][<span class="number">12</span>]*<span class="number">255</span>, (<span class="number">28</span>, <span class="number">28</span>))).astype(np.uint8),<span class="string">&quot;L&quot;</span>)</span><br><span class="line"> plt.imshow(im)</span><br><span class="line"> predictions = model.predict(&#123;<span class="string">&#x27;image&#x27;</span>: im&#125;)</span><br><span class="line"> <span class="built_in">print</span>(predictions)</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>&#123;u&#39;classLabel&#39;: u&#39;3&#39;, u&#39;output1&#39;: &#123;u&#39;1&#39;: 0.0,                         u&#39;0&#39;: 0.0,                         u&#39;3&#39;: 1.0,                         u&#39;2&#39;: 0.0,                         u&#39;5&#39;: 0.0,                         u&#39;4&#39;: 0.0,                         u&#39;7&#39;: 0.0,                         u&#39;6&#39;: 0.0,                         u&#39;9&#39;: 0.0,                         u&#39;8&#39;: 0.0                        &#125;&#125;</code></pre><p><img src="/images/keras-mnist-for-ios/download-45f07bef-9ca6-4ea6-a674-789607207e9c.png"></p><p>可以看到，预测过程和结果均符合预期。接下来是时候在Xcode项目中使用该模型了。</p><h1 id="10步完成模型在Xcode项目中的应用"><a href="#10步完成模型在Xcode项目中的应用" class="headerlink" title="10步完成模型在Xcode项目中的应用"></a>10步完成模型在Xcode项目中的应用</h1><p>为了能够让几乎所有人了解机器学习模型文件是如何一步一步在Xcode项目中使用的，这里将会从最为基础的Xcode安装、项目创建等说起，如果你是iOS开发的老鸟，部分内容请自行略过。</p><h2 id="1-安装Xcode"><a href="#1-安装Xcode" class="headerlink" title="1. 安装Xcode"></a>1. 安装Xcode</h2><p>对于iOS体系来说，Xcode是开发iOS应用程序必须的工具之一，因此如果你还未安装Xcode，需要安装Xcode，最为简单的方式是在Mac App Store中搜索并安装。如果你已经安装了Xcode，需要确保Xcode的版本至少在9.0或以上。</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>安装好Xcode之后，开启Xcode，选择iOS平台下的单视图应用，命名项目，这里命名为“MNIST-Demo”，选择一个保存项目文件的位置，创建项目即可。</p><p><img src="/images/keras-mnist-for-ios/Untitled-78fa75ca-4376-49e8-b194-bde1699f9be3.png"></p><h2 id="3-添加CoreML模型文件"><a href="#3-添加CoreML模型文件" class="headerlink" title="3. 添加CoreML模型文件"></a>3. 添加CoreML模型文件</h2><p>现在，你可以将通过coremltools转换得到的CoreML模型加入到项目中了。最简单的方式是直接拖拽模型文件到项目目录中，如果为了之后更新模型而不用去删掉重新添加，你可以在弹出的选项框中选择“add as Reference”。</p><p><img src="/images/keras-mnist-for-ios/add-model-98101cf6-8cf8-4d2a-b58e-30d397c98354.png"></p><h2 id="4-删除不需要的视图或者故事版"><a href="#4-删除不需要的视图或者故事版" class="headerlink" title="4. 删除不需要的视图或者故事版"></a>4. 删除不需要的视图或者故事版</h2><p>因为我们仅仅使用相机并显示标签，因此这里会删除掉项目中默认的一些用户界面，也就是项目中的视图控制器和故事面板。当然你也可以选择不删除，直接使用现有的视图和故事面板进行开发，不论选择哪种方式都能达到目的。这里要注意的是，如果选择编码的方式构建应用，再删除了主故事面板文件后，需要在项目的TARGETS中同步删除”Main Interface”的默认设置。</p><p><img src="/images/keras-mnist-for-ios/ScreenShot2018-11-22at10-9150b677-f351-4732-bfb6-d74019527380.32.46AM.png"></p><h2 id="5-程序化创建根视图控制器"><a href="#5-程序化创建根视图控制器" class="headerlink" title="5. 程序化创建根视图控制器"></a>5. 程序化创建根视图控制器</h2><p>接下来我们将使用代码的方式，重新制定应用程序的根视图。具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码的方式指定根视图控制器</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     <span class="comment">// 创建窗口</span></span><br><span class="line">     window <span class="operator">=</span> <span class="type">UIWindow</span>()</span><br><span class="line">     window<span class="operator">?</span>.makeKeyAndVisible()</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// 指定根视图控制器</span></span><br><span class="line">     <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">ViewController</span>()</span><br><span class="line">     window<span class="operator">?</span>.rootViewController <span class="operator">=</span> vc</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-构建视图控制器细节"><a href="#6-构建视图控制器细节" class="headerlink" title="6. 构建视图控制器细节"></a>6. 构建视图控制器细节</h2><p>接下来就是构建视图控制器的详细内容细节了。我们需要以下可交互的元素组件，例如按钮，也需要作为展示结果或者状态的标签等，另外重要的是，由于需要使用相机，因此AVFoundation类库是必须要添加的，该库用来访问和控制iOS设备上的相机，还需要Vision库，该库是iOS推出的用于计算机视觉相关任务的工具库，能够很好的和CoreML模型之间进行交互等。</p><p>具体的代码细节，这里不再累述，完成之后的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义视图控制器</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> Vision</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要使用到相机设备进行视频流的输入，因此这里要继承AVCaptureVideoDataOutputSampleBufferDelegate协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">AVCaptureVideoDataOutputSampleBufferDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文本标签用来显示识别结果</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">UILabel</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.textColor <span class="operator">=</span> .white</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Label&quot;</span></span><br><span class="line">        label.font <span class="operator">=</span> label.font.withSize(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="comment">// 调用相机设备设置方法、文本标签设置方法</span></span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()       </span><br><span class="line">        setupCaptureSession()</span><br><span class="line">        view.addSubview(label)</span><br><span class="line">        setupLabel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相机设备session</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupCaptureSession</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的捕获session</span></span><br><span class="line">        <span class="keyword">let</span> captureSession <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找可用的相机设备</span></span><br><span class="line">        <span class="keyword">let</span> availableDevices <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.<span class="type">DiscoverySession</span>(deviceTypes: [.builtInWideAngleCamera], mediaType: <span class="type">AVMediaType</span>.video, position: .back).devices</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 选择首个设备并设置为输入源</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> captureDevice <span class="operator">=</span> availableDevices.first &#123;</span><br><span class="line">                captureSession.addInput(<span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: captureDevice))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未找到相机设备，则打印错误信息</span></span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将视频输出设置到屏幕并将输出添加到我们的捕获会话</span></span><br><span class="line">        <span class="keyword">let</span> captureOutput <span class="operator">=</span> <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">        captureSession.addOutput(captureOutput)</span><br><span class="line">        <span class="keyword">let</span> previewLayer <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>(session: captureSession)</span><br><span class="line">        previewLayer.frame <span class="operator">=</span> view.frame</span><br><span class="line">        view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲视频并启动捕获会话</span></span><br><span class="line">        captureOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;videoQueue&quot;</span>))</span><br><span class="line">        captureSession.startRunning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">captureOutput</span>(<span class="keyword">_</span> <span class="params">output</span>: <span class="type">AVCaptureOutput</span>, <span class="params">didOutput</span> <span class="params">sampleBuffer</span>: <span class="type">CMSampleBuffer</span>, <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载Core ML 模型</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">VNCoreMLModel</span>(for: <span class="type">SimpleMnist</span>().model) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Core ML运行推理</span></span><br><span class="line">        <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNCoreMLRequest</span>(model: model) &#123; (finishedRequest, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> results <span class="operator">=</span> finishedRequest.results <span class="keyword">as?</span> [<span class="type">VNClassificationObservation</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获得分最高的推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="type">Observation</span> <span class="operator">=</span> results.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建最终显示的文本格式</span></span><br><span class="line">            <span class="keyword">let</span> predclass <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(Observation.identifier)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示在文本标签内</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async(execute: &#123;</span><br><span class="line">                <span class="keyword">self</span>.label.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(predclass)</span> &quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建一个核心视频像素缓冲区，它是一个图像缓冲区，用于保存主存储器中的像素生成帧，</span></span><br><span class="line">                <span class="comment">// 压缩或解压缩视频或使用核心图像的应用程序都可以使用核心视频像素缓冲区</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> pixelBuffer: <span class="type">CVPixelBuffer</span> <span class="operator">=</span> <span class="type">CMSampleBufferGetImageBuffer</span>(sampleBuffer) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="keyword">try?</span> <span class="type">VNImageRequestHandler</span>(cvPixelBuffer: pixelBuffer, options: [:]).perform([request])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupLabel</span>() &#123;</span><br><span class="line">        label.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        label.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: <span class="operator">-</span><span class="number">50</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你直接使用上述代码，请记得修改模型的名称。</p></blockquote><p><img src="/images/keras-mnist-for-ios/Untitled-503351b4-b11a-4e7b-a7ad-de4017cbac28.png"></p><h2 id="6-添加隐私说明信息"><a href="#6-添加隐私说明信息" class="headerlink" title="6. 添加隐私说明信息"></a>6. 添加隐私说明信息</h2><p>由于我们要使用相机设备进行视频数据流的获取，因此需要在Xcode工程项目中的info.plist文件中添加相应的权限申请说明“<em>Privacy - Camera Usage Description</em>”，并附带相应的说明性文字：</p><p><img src="/images/keras-mnist-for-ios/Untitled-8e6fa826-e368-47d0-8256-588a136119db.png"></p><h2 id="7-加入苹果开发者计划"><a href="#7-加入苹果开发者计划" class="headerlink" title="7. 加入苹果开发者计划"></a>7. 加入苹果开发者计划</h2><p>为了能够让该应用程序运行在你的手机设备上，你可能需要注册<a href="https://developer.apple.com/programs/enroll/">苹果的开发者计划</a>。当然如果你不想为了运行项目而花费金钱，你也可以按照<a href="https://9to5mac.com/2016/03/27/how-to-create-free-apple-developer-account-sideload-apps/">此教程</a>注册免费的账户。</p><h2 id="8-在iPhone设备上发布应用"><a href="#8-在iPhone设备上发布应用" class="headerlink" title="8. 在iPhone设备上发布应用"></a>8. 在iPhone设备上发布应用</h2><p>一切准备好之后，你就可以将该应用程序发布到你的手机设备上了。你可以按照如下图所示的方式发布项目，也可以直接在Xcode中选定目标设备，然后使用快捷键CMD+R的方式构建：</p><p><img src="/images/keras-mnist-for-ios/Untitled-1a74e4bf-8c84-4e49-95f2-4b46f8f4102f.png"></p><h2 id="9-使用应用程序"><a href="#9-使用应用程序" class="headerlink" title="9. 使用应用程序"></a>9. 使用应用程序</h2><p>经过上述各种设置和编码之后，终于可以在设备上运行我们的应用程序了。如果一切正常，首次应用程序启动的时候，会询问你是否允许应用程序访问设备的相机，这里需要允许，否则我们的应用程序则无法正常工作。</p><p>另外，我们这里所训练的模型以及制作的应用程序，没有进行详细的设计和优化，在识别的过程中，可能会遇到识别不出来以及识别错误的情况，如果需要将此功能应用在你的产品中，需要严格重新审查你所拥有的数据，以及模型的训练，app的使用等，以免出现不可预知的错误等问题。</p><p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，希望能够让你了解如何使用Keras训练所需要的模型，以及如何将其应用在iOS平台下的应用程序中，虽然介绍的不够深入，但是希望能够带给你继续深入理解Keras、了解Core ML的欲望，早日在你的应用程序中实现AI的能力，为你的应用程序增添色彩。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。&lt;/p&gt;
&lt;h1 id=&quot;10步之内完成模型的构建、训练和发布使用&quot;&gt;&lt;a href=&quot;#10步</summary>
      
    
    
    
    <category term="机器学习" scheme="https://zycslog.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习 Keras MNIST" scheme="https://zycslog.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"/>
    
  </entry>
  
</feed>
