<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.574Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.574Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item">17 分钟读完 (大约2483个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2020-07-01-iOS-runtime-category/">Runtime剖析04 --- 深入理解Category</a></h1><div class="content"><p>在Objective-C中，可以通过<strong>Category</strong>添加属性、方法、协议，在Runtime中<strong>Class</strong>和<strong>Category</strong>都是通过结构体实现的。和<strong>Category</strong>相似的还有<strong>Extension</strong>，二者的区别在于，<strong>Extension</strong>在编译期就直接和原类编译在一起，而<strong>Category</strong>是在运行时动态添加到原类中的。</p>
<h2 id="Category的数据结构"><a href="#Category的数据结构" class="headerlink" title="Category的数据结构"></a>Category的数据结构</h2><p>在Runtime中，Category的数据结构是基本的结构体，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">method_list_t</span> *<span class="title function_">methodsForMeta</span><span class="params">(<span class="type">bool</span> isMeta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">property_list_t</span> *<span class="title function_">propertiesForMeta</span><span class="params">(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">protocol_list_t</span> *<span class="title function_">protocolsForMeta</span><span class="params">(<span class="type">bool</span> isMeta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> nullptr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> protocols;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Category</strong>的定义中，为每一种可添加的元素提供了属性，添加实例方法的<strong>instanceMethods</strong>、添加类方法的<strong>classMethods</strong>、添加协议的<strong>protocols</strong>、添加实例属性的<strong>instanceProperties</strong>，并且提供了添加方法、属性和协议的可行性判断方法。</p>
<h2 id="Category的加载"><a href="#Category的加载" class="headerlink" title="Category的加载"></a>Category的加载</h2><p>首先，Category数据会被保存在Mach-O中的**__data<strong>段，当Objective-C被dyld加载的时候，Objective-C开始进入其入口函数</strong>_objc_init()**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在入口函数**_objc_init()<strong>中，会进行各种初始化操作，例如runtime、exception、cache等等的初始化，其中</strong>_dyld_objc_notify_register()**注册函数会向dyld注册监听Mach-O中Objective-C相关的section被载入和载出内存的事件。该函数有三个回调事件：</p>
<ol>
<li>对应&amp;map_images回调**_dyld_objc_notify_mapped**：当dyld已经将images加载进内存时；</li>
<li>对应load_images回调**_dyld_objc_notify_init**：当dyld初始化image后；</li>
<li>对应unmap_image回调**_dyld_objc_notify_unmapped**：当dyld将image移除内存时。</li>
</ol>
<p>将Category写入到目标类的方法列表，发生在**_dyld_objc_notify_mapped<strong>，即Mach-O相关的sections都加载到内存之后发生。此时的回调函数为</strong>map_images<strong>，该函数中最终调用的是</strong>_read_images**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc/Source/objc-os.mm</span></span><br></pre></td></tr></table></figure>

<p>在**_read_images**中，又调取了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        load_categories_nolock(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// objc/Source/objc-runtime-new.mm</span></span><br></pre></td></tr></table></figure>

<p>最终，关于Category的读取转向了函数<strong>load_categories_nolock</strong>，在这个函数中，将对Category的属性、方法、协议等进行读取，最终通过<strong>unattachedCategories</strong>方法添加到目标类的方法列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_categories_nolock</span><span class="params">(header_info *hi)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="type">category_t</span> * <span class="type">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            <span class="type">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isStubClass()) &#123;</span><br><span class="line">                <span class="comment">// Stub classes are never realized. Stub classes</span></span><br><span class="line">                <span class="comment">// don&#x27;t know their metaclass until they&#x27;re</span></span><br><span class="line">                <span class="comment">// initialized, so we have to add categories with</span></span><br><span class="line">                <span class="comment">// class methods or properties to the stub itself.</span></span><br><span class="line">                <span class="comment">// methodizeClass() will find them and add them to</span></span><br><span class="line">                <span class="comment">// the metaclass as appropriate.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// First, register the category with its target class.</span></span><br><span class="line">                <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if</span></span><br><span class="line">                <span class="comment">// the class is realized.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">                    ||  cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols</span><br><span class="line">                    ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                        attachCategories(cls-&gt;ISA(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.addForClass(lc, cls-&gt;ISA());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    processCatlist(_getObjc2CategoryList(hi, &amp;count));</span><br><span class="line">    processCatlist(_getObjc2CategoryList2(hi, &amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先调用**_getObjc2CategoryList<strong>读取</strong>__objc_catlist** section下所有记录的<strong>category</strong>，并存放在**category_t * const *catlist**数组中；</li>
<li>遍历**category_t * const *catlist**数组；</li>
<li>对每一个<em>*category_t *cat &#x3D; catlist[i];<strong>，先调用</strong>remapClass**获取</em>*Category**所属的类；</li>
<li>找到Category对应的类对象<strong>cls</strong>后，开始对<strong>cls</strong>进行修改工作。首先，如果category中有实例方法、协议，以及实例属性的话，则直接对<strong>cls</strong>进行操作，如果category中包含了类方法、协议或属性之一的话，还需要对<strong>cls</strong>所对应的<strong>元类（cls-&gt;ISA()）</strong>进行操作；</li>
<li>无论是对cls还是cls的元类进行操作，都调用方法<strong>attachCategories</strong>，修改class的方法列表结构。</li>
</ol>
<h2 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">attachCategories</span><span class="params">(Class cls, <span class="type">const</span> <span class="type">locstamped_category_t</span> *cats_list, <span class="type">uint32_t</span> cats_count,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintReplacedMethods)) &#123;</span><br><span class="line">        printReplacements(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;nameForLogging(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Only a few classes have more than 64 categories during launch.</span></span><br><span class="line"><span class="comment">     * This uses a little stack, and avoids malloc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Categories must be added in the proper order, which is back</span></span><br><span class="line"><span class="comment">     * to front. To do that with the chunking, we iterate cats_list</span></span><br><span class="line"><span class="comment">     * from front to back, build up the local buffers backwards,</span></span><br><span class="line"><span class="comment">     * and call attachLists on the chunks. attachLists prepends the</span></span><br><span class="line"><span class="comment">     * lists, so the final result is in the expected order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    constexpr <span class="type">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="type">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="type">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="type">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;data()-&gt;extAllocIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">                rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">protocol_list_t</span> *protolist = entry.cat-&gt;protocolsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        prepareMethodLists(cls, mlists + ATTACH_BUFSIZ - mcount, mcount, NO, fromBundle);</span><br><span class="line">        rwe-&gt;methods.attachLists(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) flushCaches(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.attachLists(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.attachLists(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，会完成对category中方法、协议、属性的加载，最终添加到对应class的方法、协议以及属性列表中。最终会调用<strong>attachLists</strong>方法，进行原类和分类列表的合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">attachLists</span><span class="params">(List* <span class="type">const</span> * addedLists, <span class="type">uint32_t</span> addedCount)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="type">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="type">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="type">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在合并的时候，会采用<strong>头插法</strong>将新的列表插入到原始列表中，也就是新的列表会位于原始列表的头部位置。这也就解释了为什么category中的方法，会<code>覆盖</code>class的原始方法。严格说并不是覆盖，而是因为category中定义的方法会排列在方法列表的前面，在进行方法查找的时候，会优先被找到，从而调用，而原始方法位置相对靠后，导致没有查找到，因此没有被调动。</p>
<h2 id="Category和-load方法"><a href="#Category和-load方法" class="headerlink" title="Category和+load方法"></a>Category和+load方法</h2><p><strong>+load</strong>方法在Objective-C中被调用的时机相对较早，因此Category中定义的方法需要在调用**+load**方法之前就被附加到类的方法列表中，否则可能导致调用无效的情况，实际上，Runtime中也是真么保证的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">    </span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在**_dyld_objc_notify_register<strong>中，runtime向dyld中注册了三个事件监听：</strong>map_images、load_images、unmap_image<strong>。在</strong>map_images<strong>事件中，runtime会读取Mach-O文件中的oc sections，并根据这些信息初始化runtime环境，在这一步包含了category的加载等。之后当runtime环境初始化完成后，会进行dyld的</strong>load_images<strong>，这一步会调用</strong>+load**方法。</p>
<h2 id="Category-Associate"><a href="#Category-Associate" class="headerlink" title="Category Associate"></a>Category Associate</h2><p>在项目开发中，经常会使用到<strong>Category</strong>，有时候会遇到向<strong>Category</strong>中添加属性的需求，但是在<strong>Category</strong>中不能直接添加属性，而是要借助Runtime提供的<strong>Associated</strong>相关的API，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">TestCategory</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> *<span class="keyword">const</span> kAssociatedObjectKey = (<span class="type">void</span> *)&amp;kAssociatedObjectKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">TestCategory</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)object&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="built_in">NSObject</span> *)object&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在<strong>Category</strong>中添加属性后，默认是没有实现方法的，如果调用属性会发生崩溃，而且还会提示如下警告。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Property <span class="string">&#x27;object&#x27;</span> requires method <span class="string">&#x27;object&#x27;</span> to be defined - use @dynamic or provide a method implementation in this category</span><br><span class="line"></span><br><span class="line">Property <span class="string">&#x27;object&#x27;</span> requires method <span class="string">&#x27;setObject:&#x27;</span> to be defined - use @dynamic or prov ide a method implementation in this category</span><br></pre></td></tr></table></figure>

<p>这里提出<strong>objc_getAssociatedObject</strong>的runtime源码，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="type">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;<span class="title function_">associations</span><span class="params">(manager.get())</span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，所有通过<strong>Associated</strong>添加的属性，都被存储在一个全局单独的<strong>AssociationsHashMap</strong>哈希表中，<strong>objc_getAssociatedObject</strong>和<strong>objc_setAssociatedObject</strong>本质都是在操作这个哈希表，通过对哈希表进行映射来存储对象。</p>
<p>在<strong>Associated</strong>的API中还有一些内存管理相关的关键字，例如<strong>OBJC_ASSOCIATION_ASSIGN</strong>，这些关键字用来指定对象的内存管理方式，在runtime中会根据这些关键字进行不同的内存管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">OBJC_ENUM</span><span class="params">(<span class="type">uintptr_t</span>, objc_AssociationPolicy)</span> &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.573Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.573Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item">31 分钟读完 (大约4606个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2020-06-17-iOS-memory-manage-tips/">iOS内存管理小结</a></h1><div class="content"><p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。在早起的iOS开发中多采用MRC（手动引用计数）来进行内存管理，iOS 5引入了ARC（自动引用计数），90%以上的内存管理问题都交给了系统去进行，但是ARC并不是万能的，有些框架中和某些使用到C语言的场景中还是需要开发者手动对内存进行管理。</p>
<h2 id="iOS-中的内存管理模型"><a href="#iOS-中的内存管理模型" class="headerlink" title="iOS 中的内存管理模型"></a>iOS 中的内存管理模型</h2><p>对于<strong>面向过程</strong>的C语言而言，在内存管理的设计上也较为直接，内存的申请和释放都由开发者手动管理。这种管理方式虽然简单，但是大大的增加了编码的工作量，也增加了代码的复杂度。</p>
<p>在<strong>面向对象</strong>语言中，内存管理通常会由<strong>模型机制</strong>来完成，常见的内存管理模型机制有<strong>垃圾回收机制</strong>和<strong>引用计数机制</strong>两种，Objective-C语言采用的则是引用计数的内存管理模型。</p>
<p>内存的管理其实就是管理程序代码和相关数据对内存的消耗，在iOS中，内存通常被分为5个特定的功能性区域：</p>
<ul>
<li><strong>栈区</strong>：存储局部变量，或自动变量，在作用域结束后内存会被回收；栈区也保存了函数调用的现场；</li>
<li><strong>堆区</strong>：存储OC对象，需要开发者手动申请和释放，通常使用malloc、realloc、alloc等函数控制的变量，均存储在堆上，堆在所有的线程，共享库和动态加载的模块中被共享使用；</li>
<li><strong>BSS区</strong>：即Block Started by Symbol，用来存储未初始化的全局变量和静态变量；</li>
<li><strong>数据区</strong>：用来存储已经初始化的全局变量、静态变量和常量；</li>
<li><strong>代码区</strong>：加载程序代码。</li>
</ul>
<p>在5个内存区域中，除了堆区需要开发者手动进行内存的管理外，其他区域均由系统自动进行管理。</p>
<p>引用计数是Objective-C语言提供的内存管理技术，每一个Objective-C对象都有一个<strong>retainCount</strong>属性，该属性便是引用计数机制的根本。一个Objective-C对象是否应该被释放，取决于retainCount是否为0。</p>
<h3 id="关于MRC"><a href="#关于MRC" class="headerlink" title="关于MRC"></a>关于MRC</h3><p>MRC内存管理有如下两个原则：</p>
<ul>
<li>谁持有对象，谁负责释放，不是自己持有的不能释放；</li>
<li>当对象不再被需要时，需要主动释放。</li>
</ul>
<p>在OC中，会对对象进行持有的方法有alloc、new、copy、mutableCopy、retain。其中retain是对当前对象进行持有，使得引用计数加1，其余四个是创建新的对象，创建后引用计数加1。</p>
<h3 id="关于ARC"><a href="#关于ARC" class="headerlink" title="关于ARC"></a>关于ARC</h3><p>ARC是Xcode编译器的功能，ARC并没有改变MRC内存管理的两个原则，也并没有在运行时增加新的特性，ARC仅仅是在编译时帮助开发者将retain和release方法给补上。</p>
<p>ARC下，有几个关键的修饰符：**__strong、__weak、__unsafe_unretained、__autoreleasing<strong>，被称为</strong>所有权修饰符<strong>，在开发中，开发者所使用的指针默认使用</strong>__strong**修饰符。</p>
<p>__strong修饰符通常是对变量进行强引用，主要有三方面的作用：</p>
<ol>
<li>使用__strong修饰的变量如果是自己生成的，则会被添加进自动释放池，在作用域结束后，会被release一次；</li>
<li>使用__strong修饰的变量如果不是自己生成的，则会被强引用，即会被持有使其引用计数加1，在离开作用域之后，会被release一次；</li>
<li>使用__strong修饰的变量如果重新赋值或者置为nil，则变量会被release一次。</li>
</ol>
<p>__weak修饰符通常用来对变量进行弱引用，最大的用途是避免ARC环境下的循环引用问题。<strong>循环引用</strong>问题是ARC中造成内存泄漏的主要问题。__weak修饰符主要有两个作用：</p>
<ol>
<li>被__weak修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会被添加到自动释放池，会在离开作用域是被release一次，如果不是自己生成的，则在离开作用域后，不会进行release操作；</li>
<li>被__weak修饰的变量指针，变量如果失效，则指针会被自动置为nil，否则可能会造成<code>野指针</code>异常。</li>
</ol>
<p>__unsafe_unretained修饰符是不全安的，该修饰符的作用也是对变量进行弱引用，和__weak不同的是，当变量失效后，其指针不会被自动置为nil。__unsafe_unretained修饰符的主要作用：</p>
<ol>
<li>被__unsafe_unretained修饰的变量仅提供弱引用，不会使其引用计数增加。变量对象如果是自己生成的，则会在离开作用域后release一次，如果不是自己生成的，则在离开作用域后，不进行release操作；</li>
<li>被__unsafe_unretained修饰的变量，当变量失效后，被修饰指针不会被安全处理为nil，即旧地址依然保存。</li>
</ol>
<p>__autoreleasing修饰符与自动释放池有关。</p>
<p>在使用ARC时，有以下几条原则：</p>
<ul>
<li>不能使用retain、release、autorelease函数，不可访问retainCount属性</li>
<li>不能调用dealloc函数，可以覆写dealloc函数，但是在其视线中不可调用父类的dealloc函数</li>
<li>不能使用NSAutoreleasePool，可以使用@autoreleasepool代替</li>
<li>对象类型变量不能作为C语言的结构体</li>
</ul>
<h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><p><strong>类是属性和方法的集合。属性用来存储类中的数据，方法用来描述类的行为。</strong></p>
<p>属性在声明时会默认添加修饰符。在MRC环境下，默认的属性修饰符为<strong>atomic，readWrite，retain</strong>，在ARC下，默认的属性修饰符为<strong>atomic，readWrite，strong\assign</strong>。</p>
<p>通常情况下，在声明属性时会使用@property，此时编译器或自动帮助声明和实现属性的Setter方法和Getter方法。</p>
<p>关于内存管理相关的属性修饰符有如下几种：</p>
<table>
        <tr>
            <th>修饰符</th>
            <th>作用</th>
        </tr>
        <tr>
            <th>assign</th>
            <th>直接赋值，和引用计数无关，用来声明简单数据类型的属性，例如int</th>
        </tr>
        <tr>
            <th>retain</th>
            <th>对旧对象进行释放，并强引用新的对象，使其引用计数加1，用在MRC中</th>
        </tr>
        <tr>
            <th>strong</th>
            <th>对新对象进行强引用，释放旧对象，使其引用计数加1，作用与retain相似，用在ARC中</th>
        </tr>
        <tr>
            <th>copy</th>
            <th>在实现Setter方法时，采用copy函数，会生成新的对象，并被自己持有</th>
        </tr>
        <tr>
            <th>weak</th>
            <th>弱引用，不对所赋值的对象进行持有，但是是安全的，对对象不可用时，会被置为nil，用在ARC中</th>
        </tr>
        <tr>
            <th>unsafe_unreatined</th>
            <th>弱引用，和weak不同的是，如果引用的对象不可用，则当前指针不会被置为nil，会产生野指针</th>
        </tr>
    </table>

<h2 id="自动释放内存"><a href="#自动释放内存" class="headerlink" title="自动释放内存"></a>自动释放内存</h2><p>在iOS中，对象的创建除了使用alloc、new等函数创建外，还可使用对象的对象方法来创建，但此时对象的创建方式并不符合“谁持有对象，谁负责释放”的原则，此类方式创建的对象在内存管理上，则将管理权移交给了自动释放池。</p>
<p>我们知道，release函数的作用是对当前对象进行一次引用计数减1，当引用计数为0时，才真实释放对象所使用的内存。而autorelease，其本质上是使release函数的调用进行延迟调用了。可以简单的把autorelease方法的对象成为自动释放对象，自动释放对象的内存管理是提交给自动释放池处理的。</p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>@autoreleasepool{}标识就是自动释放池，当自动释放池操作结束后，其会向被添加进自动释放池的所有对象发送release消息。@autoreleasepool{}的写法是ARC下的下发，在MRC坏境下，需要创建自动释放池对象，然后进行使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="comment">// 添加进自动释放池的对象</span></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>

<p>另外，在iOS系统运行应用程序时，会自动创建一些线程，每个线程都默认拥有自己的自动释放池。还有，在每次执行时间循环时，都活将其自动释放池清空。因此，在大多数情况下，开发者不需要手动创建自动释放池，例外的是，系统的自动释放池会在每次时间循环结束后清空，如果代码中有大量的循环，会生成大量的自动释放对象，则可能会导致内存消耗瞬时增长。</p>
<h2 id="杜绝内存泄漏"><a href="#杜绝内存泄漏" class="headerlink" title="杜绝内存泄漏"></a>杜绝内存泄漏</h2><p><strong>内存泄漏的核心问题是循环引用。</strong></p>
<p><strong>循环引用：在OC设计中，对象会对其内部的属性进行持有，当一个对象的引用计数为0，将其内存回收时，这个对象会向其内的所有属性发送release消息，让其中的属性对象进行释放。如果对象内的某个属性再次对当前的对象进行了持有，则会产生循环引用。</strong></p>
<h3 id="Block与循环引用"><a href="#Block与循环引用" class="headerlink" title="Block与循环引用"></a>Block与循环引用</h3><p>Block是OC中一种十分强大的语法。使用Block，可以将代码块作为属性、参数以及变量来使用，并且可以灵活地执行这块代码。Block的实质是一段可执行的代码块，对于Block类型的属性和变量，可以对其进行赋值。但究其根本，Block的本质还是对象。</p>
<p>对于Block的使用，有一些有趣的地方，在Block中访问Block外的数据时没有问题的，无论是对象数据还是基本数据类型数据，但是如果要在Block中修改Block外的数据，可能会发生异常，可变字符串等外部数据的修改不会发生异常。</p>
<p>其实并不是Block对外部数据修改有什么特殊的设计，而是因为在Block中，任何外部数据都是不允许被修改的，可变类型数据能够被修改，是因为对象指针所指向的内存存放的只是对象数据的地址，并不是对象数据本身，只要地址不被修改，只修改对象的数据是没有问题的。</p>
<p><strong>在Block内部无法修改外部数据的根本原因在于，Block中访问外部变量时，都会对其进行拷贝和强引用，这里的拷贝是直接拷贝，如果在Block外部和内部分别打印对象，会看到对象的地址是不同的。</strong></p>
<p>如果要保证在Block内部可以自由修改外部的数据，OC提供了__block关键字，使用该关键字修饰的变量，可以在Block中直接访问原始变量，而没有拷贝。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.myblock = ^<span class="type">BOOL</span>(<span class="type">int</span> param)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码是Block中循环引用的经典例子。其中myblock和self之间产生的循环引用。要解决Block中的循环引用，只需要在Block中使用弱引用的指针即可，这样在Block的作用域结束后，其对外部变量的引用也会自然切换，避免循环引用。</p>
<h3 id="代理与循环引用"><a href="#代理与循环引用" class="headerlink" title="代理与循环引用"></a>代理与循环引用</h3><p>代理是另一种可能会产生循环引用的场景。在iOS中，除了系统的一些原生的组件需要通过代理函数来进行回调外，开发者也经常使用<strong>代理来进行传值、逻辑回调、组件配置</strong>等。有时，开发者会使用代理来进行<strong>反向传值</strong>，而反向传值的时候需要在视图控制器中设置代理，如果代理属性采用了strong修饰符，则视图控制器对代理对象是强应用，而定义代理的类可能又是视图控制器的属性，造成了循环引用，造成内存泄漏，因此在使用代理模式的时候，设置代理属性一般采用如下修饰符：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span>&lt;CustomeDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>


<h3 id="定时器引起的内存泄漏"><a href="#定时器引起的内存泄漏" class="headerlink" title="定时器引起的内存泄漏"></a>定时器引起的内存泄漏</h3><p>定时器通产个用来进行循环任务的执行，NSTimer是iOS中极易产生循环引用的一个类。通常在使用定时器时，会定义一个定时器对象如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> * timer;</span><br></pre></td></tr></table></figure>

<p>再具体使用定时器时，如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval: <span class="number">1</span> target: <span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerRun) userinfo: <span class="literal">nil</span> repeat: <span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p>当定时器对象所在的视图控制器被dismiss之后，视图控制器并没有执行dealloc函数，原因在于定时器对象实际上持有了视图控制器，只有当定时器失效后，其才会释放所持有的视图控制器。因此，在视图控制器返回前，开发者可以手动调用invalidate方法使得定时器失效，已避免循环引用。</p>
<blockquote>
<p>iOS 10 SDK 中已经提供了避免循环引用的NSTimer 新 API。</p>
</blockquote>
<h2 id="“僵尸”对象"><a href="#“僵尸”对象" class="headerlink" title="“僵尸”对象"></a>“僵尸”对象</h2><p>首先，<strong>僵尸对象和内存泄漏无任何关系。</strong>但是产生僵尸对象也属于内存管理问题。当一个对象被释放后，如果其指针没有置空，则这个指针就变成了野指针，此时该对象被称为僵尸对象。</p>
<h3 id="僵尸对象的捕获"><a href="#僵尸对象的捕获" class="headerlink" title="僵尸对象的捕获"></a>僵尸对象的捕获</h3><p>在OC中，内存的使用包含如下几个阶段：</p>
<ul>
<li>请求创建对象，向系统申请一块内存空间，在申请完成后，这块内存空间不能在做他用；</li>
<li>对象被释放，此时这块内存空间变为闲置，可以被再次申请使用；</li>
<li>在此块内存重新被申请使用之前，这块内存中的数据依然存在；</li>
<li>此时如果依然有指针指向这块内存，则此指针为野指针；</li>
<li>当野指针对这块内存进行访问时，如果这块内存已经被重新分配，则会出现系统问题，如果没有被分配，则不会出现系统问题。</li>
</ul>
<p>在MRC下，当一个对象被release后，再去访问这个对象的时候，就会出现异常，出现僵尸对象。而在ARC下,Xcode也提供了捕获僵尸对象的选项，供开发者使用。<strong>Zombie Objects选项</strong></p>
<h3 id="处理僵尸对象"><a href="#处理僵尸对象" class="headerlink" title="处理僵尸对象"></a>处理僵尸对象</h3><p>一般在开发中，僵尸对象一旦出现，大多数情况是代码逻辑的问题，但是如果做到万无一失，避免由于僵尸对象带来应用程序的崩溃呢？</p>
<p>在OC中，向空指针发送任何消息都是无效的。因此，访问到僵尸对象的根本问题是野指针的问题。在ARC中，使用__weak和__strong修饰的变量指针，在对象释放后被自动置为nil，这就大大减少了野指针的问题。另外一种方式就是使用OC的消息机制来规避所有的僵尸对象问题。</p>
<h2 id="CoreFoundation框架中的内存管理"><a href="#CoreFoundation框架中的内存管理" class="headerlink" title="CoreFoundation框架中的内存管理"></a>CoreFoundation框架中的内存管理</h2><p>CoreFoundation框架是由C语言实现的一组编程接口，与Foundation框架提供类似的基础功能，不同的是Foundation框架是由OC语言实现的，CoreFoundation也提供了字符串、数组、集合、颜色、时间和URL等对象。</p>
<p><strong>CoreFoundation框架中依然采用引用计数的方式进行内存管理，但并不支持ARC。</strong></p>
<p>在CoreFoundation框架中，有几条内存管理法则：</p>
<ol>
<li>自己创建的对象要自己负责释放；</li>
<li>如果使用别人创建的对象，要保证其可用，则需要对对象进行持有；</li>
<li>如果对对象进行了持有，则当不在需要此对象时，要进行释放。</li>
</ol>
<p>在CoreFoundation框架中，使用带有Create、Copy此类字段的函数获取的对象会被认为是自己创建的对象，要负责这些对象的释放。当使用滴啊有Get这样的字段的函数获取对象时，默认并不对此对象进行持有，可以手动调用CFRetain()函数进行持有。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>OC是面向对象的语言，但是对象仅仅是引用层面的一种抽象，抛开其华丽的外衣，底层依然是最为朴素的结构体和指针。</li>
<li>OC语言采用了引用计数的内存管理模型，对内存进行管理；</li>
<li>除了用户自建的内存管理池意外，系统在每个线程都维护了一个系统级别的自动释放池；</li>
<li>OC语言的类型检查都是编译时的特性；</li>
<li>OC语言的数据传递是运行时决定的。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">7 分钟读完 (大约1093个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2019-01-22-data_cleaning/">8大场景数据清洗Python代码</a></h1><div class="content"><p><strong>数据清洗</strong>是进行数据分析和使用数据训练模型的必经之路，也是最为耗费数据科学家、程序员的地方。</p>
<p>在数据清洗的过程中，绝大多数的场景下，所进行的清洗工作都是相似甚至是重复的，因此有必要将数据清洗工作的场景进行总结并给出对应的清洗代码，以便形成可适用于多数工程项目的工具箱。</p>
<hr>
<h1 id="涵盖8大场景的数据清洗代码"><a href="#涵盖8大场景的数据清洗代码" class="headerlink" title="涵盖8大场景的数据清洗代码"></a>涵盖8大场景的数据清洗代码</h1><p>以下数据清洗代码，涵盖了8个数据清洗工作中常见的场景，分别是：</p>
<ol>
<li>删除多列</li>
<li>转换数据类型</li>
<li>将分类变量转换为数字变量</li>
<li>检查缺失数据</li>
<li>删除列中的字符串</li>
<li>删除列中的空格</li>
<li>用字符串连接两列（带条件）</li>
<li>转换时间戳（从字符串到日期时间格式）</li>
</ol>
<h2 id="1-删除多列"><a href="#1-删除多列" class="headerlink" title="1. 删除多列"></a>1. 删除多列</h2><p>在进行数据分析时，可能并非所有的列都有用，此时可以使用<code>df.drop</code>方便地删除指定的列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">drop_multiple_col</span>(<span class="params">col_name_list, df</span>):</span><br><span class="line">	df.drop(col_name_list, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> df</span><br></pre></td></tr></table></figure>

<h2 id="2-转换数据类型"><a href="#2-转换数据类型" class="headerlink" title="2. 转换数据类型"></a>2. 转换数据类型</h2><p>当数据集变大时，可能需要转换数据类型来节省内存空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_dtypes</span>(<span class="params">col_int, col_float, df</span>):</span><br><span class="line">	df[col_int] = df[col_int].astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line">	df[col_float] = df[col_float].astype(<span class="string">&#x27;float32&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-将分类变量转换为数字变量"><a href="#3-将分类变量转换为数字变量" class="headerlink" title="3. 将分类变量转换为数字变量"></a>3. 将分类变量转换为数字变量</h2><p>在一些机器学习模型中，会要求变量采用数值格式。此时便需要将分类变量转换为数字变量，同时，也可以保留分类变量，以便进行数据可视化等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_cat_2num</span>(<span class="params">df</span>):</span><br><span class="line">	num_encode = &#123;<span class="string">&#x27;col_1&#x27;</span> : &#123;<span class="string">&#x27;YES&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;NO&#x27;</span>:<span class="number">0</span>&#125;,</span><br><span class="line">				  <span class="string">&#x27;col_2&#x27;</span> : &#123;<span class="string">&#x27;WON&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;LOSE&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;DRAW&#x27;</span>:<span class="number">0</span>&#125;&#125;</span><br><span class="line">	df.replace(num_encode, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-检查缺失数据"><a href="#4-检查缺失数据" class="headerlink" title="4. 检查缺失数据"></a>4. 检查缺失数据</h2><p>如果要检查每列缺失数据的数量，可使用下面的代码，目前来看应该是最快的方法。可以更好地了解哪些列缺失的数据更多，从而确定怎么进行下一步的数据清洗和分析操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_missing_data</span>(<span class="params">df</span>):</span><br><span class="line">	<span class="keyword">return</span> df.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5-删除列中的字符串"><a href="#5-删除列中的字符串" class="headerlink" title="5. 删除列中的字符串"></a>5. 删除列中的字符串</h2><p>有时，会有新的字符或者其他不需要的符号出现在字符串中，此时可以使用<code>df[&#39;col_1&#39;].replace</code>将它们处理掉：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_col_str</span>(<span class="params">df</span>):</span><br><span class="line">	df[<span class="string">&#x27;col_1&#x27;</span>].replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">	df[<span class="string">&#x27;col_1&#x27;</span>].replace(<span class="string">&#x27; &amp;#.*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-删除列中的空格"><a href="#6-删除列中的空格" class="headerlink" title="6. 删除列中的空格"></a>6. 删除列中的空格</h2><p>当数据混乱的时候，什么情况都有可能发生。字符串开头有时会有一些空格，在删除列中字符串开头的空格时，可使用下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_col_white_space</span>(<span class="params">col, df</span>):</span><br><span class="line">	df[col] = df[col].<span class="built_in">str</span>.lstrip()</span><br></pre></td></tr></table></figure>

<h2 id="7-用字符串连接两列（带条件）"><a href="#7-用字符串连接两列（带条件）" class="headerlink" title="7. 用字符串连接两列（带条件）"></a>7. 用字符串连接两列（带条件）</h2><p>当你想要有条件地用字符串将两列连接在一起时，这段代码很有帮助。比如，你可以在第一列结尾处设定某些字母，然后用它们与第二列连接在一起。</p>
<p>根据需要，结尾处的字母也可以在连接完成后删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">concat_col_str_condition</span>(<span class="params">df</span>):</span><br><span class="line">    mask = df[<span class="string">&#x27;col_1&#x27;</span>].<span class="built_in">str</span>.endswith(<span class="string">&#x27;pil&#x27;</span>, na=<span class="literal">False</span>)</span><br><span class="line">    col_new = df[mask][<span class="string">&#x27;col_1&#x27;</span>] + df[mask][<span class="string">&#x27;col_2&#x27;</span>]</span><br><span class="line">    col_new.replace(<span class="string">&#x27;pil&#x27;</span>, <span class="string">&#x27; &#x27;</span>, regex=<span class="literal">True</span>, inplace=<span class="literal">True</span>)  <span class="comment"># replace the &#x27;pil&#x27; with emtpy space</span></span><br></pre></td></tr></table></figure>

<h2 id="8-转换时间戳（从字符串到日期时间格式）"><a href="#8-转换时间戳（从字符串到日期时间格式）" class="headerlink" title="8. 转换时间戳（从字符串到日期时间格式）"></a>8. 转换时间戳（从字符串到日期时间格式）</h2><p>在处理时间序列数据时，我们很可能会遇到字符串格式的时间戳列。</p>
<p>这意味着要将字符串格式转换为日期时间格式(或者其他根据我们的需求指定的格式) ，以便对数据进行有意义的分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert_str_datetime</span>(<span class="params">df</span>): </span><br><span class="line">    df.insert(loc=<span class="number">2</span>, column=<span class="string">&#x27;timestamp&#x27;</span>, value=pd.to_datetime(df.transdate, <span class="built_in">format</span>=<span class="string">&#x27;%Y-%m-%d %H:%M:%S.%f&#x27;</span>)) </span><br></pre></td></tr></table></figure>

<p>以上便是针对8个常见场景的数据清洗代码，在部分场景下，你可能需要简单修改代码才可使用。在面对各种不同且复杂的数据时，可能需要先了解你的数据，然后再决定使用那个或者那些方法进行数据的清洗工作，使得数据能够更好的进入下一步的分析建模过程等。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.565Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">17 分钟读完 (大约2516个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2019-01-22-iOS_NSLog/">iOS中Log同步获取与重定向</a></h1><div class="content"><p>在iOS开发的过程中，经常会使用<code>NSLog</code>作为调试和查看相关数据的输出口，该方法连接Xcode构建项目时能够实时输出开发者在代码线中打印的日志。但是在断开Xcode并使用真机测试的时候，经常会无法查看真机的实时日志，导致一些问题难以追查和确定，导致问题的定位与解决花费较长的时间，一定程度上影响了产品开发的进度和优化。面对诸如此类的问题，我们可以通过Log信息的重定向等技术，让相关的Log信息转存到一个我们能够提取的地方，方便开发人员在出现问题的时候，得到详细的Log信息，快速的识别出问题的原因并修复和优化等。</p>
<h1 id="NSLog的输出到底在哪里？"><a href="#NSLog的输出到底在哪里？" class="headerlink" title="NSLog的输出到底在哪里？"></a>NSLog的输出到底在哪里？</h1><p>在iOS的系统API中，专门提供了一个上层函数<code>NSLog</code>以供开发者调用并打印相关的信息，<code>NSLog</code>本质上是一个C函数，它的声明如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="type">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...)</span><br></pre></td></tr></table></figure>

<p>系统对该函数的说明是：<code>Logs an error message to the Apple System Log facility</code>。简单的说就是用来输出信息到标准的Error控制台上，其内部其实是使用<code>Apple System Log（asl）</code>的API，至少iOS 10以前是这样。在调试阶段，日志会输出到Xcode中，而在真机上，会输出到系统的<code>/var/log/syslog</code>文件中。</p>
<h1 id="Apple-System-Logger"><a href="#Apple-System-Logger" class="headerlink" title="Apple System Logger"></a>Apple System Logger</h1><p>我们可以通过<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/1395074-nslogv?language=objc">官方文档</a>了解到，OC中最常见的NSLog操作会同时将标准的Error输出到控制台和系统日志(syslog)中(C语言的printf系列函数并不会，swift的printf为了保证性能也只会在模拟器环境中输出)。其内部是使用Apple System Logger(简称ASL)去实现的，ASL是苹果自己实现的用于输出日志到系统日志库的一套API接口，有点类似于SQL操作。在iOS真机设备上，使用ASL记录的log被缓存在沙盒文件中，直到设备被重启。</p>
<p>既然日志被写入系统的syslog中，那我们可以直接读取这些日志。从ASL读取日志的核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;asl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 从日志的对象aslmsg中获取我们需要的数据</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)logMessageFromASLMessage:(aslmsg)aslMessage&#123;</span><br><span class="line">    SystemLogMessage *logMessage = [[SystemLogMessage alloc] init];</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *timestamp = asl_get(aslMessage, ASL_KEY_TIME);</span><br><span class="line">    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeInterval = [@(timestamp) integerValue];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *nanoseconds = asl_get(aslMessage, ASL_KEY_TIME_NSEC);</span><br><span class="line">        <span class="keyword">if</span> (nanoseconds) &#123;</span><br><span class="line">            timeInterval += [@(nanoseconds) doubleValue] / <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logMessage.timeInterval = timeInterval;</span><br><span class="line">        logMessage.date = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timeInterval];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *sender = asl_get(aslMessage, ASL_KEY_SENDER);</span><br><span class="line">    <span class="keyword">if</span> (sender) &#123;</span><br><span class="line">        logMessage.sender = @(sender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *messageText = asl_get(aslMessage, ASL_KEY_MSG);</span><br><span class="line">    <span class="keyword">if</span> (messageText) &#123;</span><br><span class="line">        logMessage.messageText = @(messageText);<span class="comment">//NSLog写入的文本内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *messageID = asl_get(aslMessage, ASL_KEY_MSG_ID);</span><br><span class="line">    <span class="keyword">if</span> (messageID) &#123;</span><br><span class="line">        logMessage.messageID = [@(messageID) longLongValue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> logMessage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSMutableArray</span>&lt;SystemLogMessage *&gt; *)allLogMessagesForCurrentProcess&#123;</span><br><span class="line">    asl_object_t query = asl_new(ASL_TYPE_QUERY);</span><br><span class="line">    <span class="comment">// Filter for messages from the current process. </span></span><br><span class="line">    <span class="comment">// Note that this appears to happen by default on device, </span></span><br><span class="line">    <span class="comment">// but is required in the simulator.</span></span><br><span class="line">    <span class="built_in">NSString</span> *pidString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d&quot;</span>, [[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier]];</span><br><span class="line">    asl_set_query(query, ASL_KEY_PID, [pidString UTF8String], ASL_QUERY_OP_EQUAL);</span><br><span class="line"></span><br><span class="line">    aslresponse response = asl_search(<span class="literal">NULL</span>, query);</span><br><span class="line">    aslmsg aslMessage = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *logMessages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">while</span> ((aslMessage = asl_next(response))) &#123;</span><br><span class="line">        [logMessages addObject:[SystemLogMessage logMessageFromASLMessage:aslMessage]];</span><br><span class="line">    &#125;</span><br><span class="line">    asl_release(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logMessages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以上方法的好处是不会影响Xcode控制台的输出，可以用非侵入性的方式来读取日志。</p>
<h1 id="ASL在iOS10后被弃用"><a href="#ASL在iOS10后被弃用" class="headerlink" title="ASL在iOS10后被弃用"></a>ASL在iOS10后被弃用</h1><p>但是Apple从iOS 10开始，为了减弱ASL对于日志系统的侵入性，直接废弃掉了ASL<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/os/logging?language=objc">link</a>，导致在iOS 10之后的系统版本中无法使用ASL相关的API。因此为了能够在iOS 10之后的版本中同样获取日志数据，我们寻找一种版本兼容的解决方案。</p>
<h1 id="NSLog重定向"><a href="#NSLog重定向" class="headerlink" title="NSLog重定向"></a>NSLog重定向</h1><p>NSLog能输出到文件syslog中，靠的是文件IO的API的调用，那么在这些IO操作中，一定存在文件句柄。在C语言中，存在默认的三个文件句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> stdin __stdinp </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stdout __stdoutp </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stderr __stderrp</span></span><br></pre></td></tr></table></figure>

<p>其对应的三个iOS版本的文件句柄是(定义在<code>unistd.h</code>文件中):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	 STDIN_FILENO	0	<span class="comment">/* standard input file descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STDOUT_FILENO	1	<span class="comment">/* standard output file descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	STDERR_FILENO	2	<span class="comment">/* standard error file descriptor */</span></span></span><br></pre></td></tr></table></figure>

<p>在使用重定向之后，NSLog就不会写到系统的syslog中了。</p>
<h2 id="dup2重定向"><a href="#dup2重定向" class="headerlink" title="dup2重定向"></a>dup2重定向</h2><p>通过重定向，可以直接截取<code>stdout,stderr</code>等标准输出的信息，然后保存在想要存储的位置，上传到服务器或者显示到View上。<br>要做到重定向，需要通过<code>NSPipe</code>创建一个管道，pipe有读端和写端，然后通过<code>dup2</code>将标准输入重定向到pipe的写端。再通过<code>NSFileHandle</code>监听pipe的读端，最后再处理读出的信息。<br>之后通过<code>printf</code>或者<code>NSLog</code>写数据，都会写到pipe的写端，同时pipe会将这些数据直接传送到读端，最后通过NSFileHandle的监控函数取出这些数据。<br>核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)redirectStandardOutput&#123;</span><br><span class="line">    <span class="comment">//记录标准输出及错误流原始文件描述符</span></span><br><span class="line">    <span class="keyword">self</span>.outFd = dup(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">self</span>.errFd = dup(STDERR_FILENO);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    stdout-&gt;_flags = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSPipe</span> *outPipe = [<span class="built_in">NSPipe</span> pipe];</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *pipeOutHandle = [outPipe fileHandleForReading];</span><br><span class="line">    dup2([[outPipe fileHandleForWriting] fileDescriptor], STDOUT_FILENO);</span><br><span class="line">    [pipeOutHandle readInBackgroundAndNotify];</span><br><span class="line"></span><br><span class="line">    stderr-&gt;_flags = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">NSPipe</span> *errPipe = [<span class="built_in">NSPipe</span> pipe];</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *pipeErrHandle = [errPipe fileHandleForReading];</span><br><span class="line">    dup2([[errPipe fileHandleForWriting] fileDescriptor], STDERR_FILENO);</span><br><span class="line">    [pipeErrHandle readInBackgroundAndNotify];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> </span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(redirectOutNotificationHandle:) </span><br><span class="line">                                            name:<span class="built_in">NSFileHandleReadCompletionNotification</span> </span><br><span class="line">                                            object:pipeOutHandle];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> </span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(redirectErrNotificationHandle:) </span><br><span class="line">                                            name:<span class="built_in">NSFileHandleReadCompletionNotification</span> </span><br><span class="line">                                            object:pipeErrHandle];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)recoverStandardOutput&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    dup2(<span class="keyword">self</span>.outFd, STDOUT_FILENO);</span><br><span class="line">    dup2(<span class="keyword">self</span>.errFd, STDERR_FILENO);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向之后的NSLog输出</span></span><br><span class="line">- (<span class="type">void</span>)redirectOutNotificationHandle:(<span class="built_in">NSNotification</span> *)nf&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [[nf userInfo] objectForKey:<span class="built_in">NSFileHandleNotificationDataItem</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// YOUR CODE HERE...  保存日志并上传或展示</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [[nf object] readInBackgroundAndNotify];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向之后的错误输出</span></span><br><span class="line">- (<span class="type">void</span>)redirectErrNotificationHandle:(<span class="built_in">NSNotification</span> *)nf&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BETA_BUILD</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [[nf userInfo] objectForKey:<span class="built_in">NSFileHandleNotificationDataItem</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="comment">// YOUR CODE HERE...  保存日志并上传或展示</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    [[nf object] readInBackgroundAndNotify];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dup函数可以为我们复制一个文件描述符，传给该函数一个既有的描述符，它就会返回一个新的描述符，这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。<br>而dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。</p>
</blockquote>
<h2 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h2><p>另一种重定向的方式是利用c语言的<code>freopen</code>函数进行重定向，将写往<code>stderr</code>的内容重定向到我们制定的文件中去，一旦执行了上述代码那么在这个之后的NSLog将不会在控制台显示了，会直接输出在指定的文件中。<br>在模拟器中，我们可以使用终端的<code>tail</code>命令(tail -f xxx.log)对这个文件进行实时查看，就如同我们在Xcode的输出窗口中看到的那样，你还可以结合<code>grep</code>命令进行实时过滤查看，非常方便在大量的日志信息中迅速定位到我们要的日志信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE * <span class="title function_">freopen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode, FILE * stream )</span>;</span><br></pre></td></tr></table></figure>

<p>核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSString</span> *documentsPath = [paths objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSString</span> *loggingPath = [documentsPath stringByAppendingPathComponent:<span class="string">@&quot;/xxx.log&quot;</span>];</span><br><span class="line"><span class="comment">//redirect NSLog</span></span><br><span class="line">freopen([loggingPath cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], <span class="string">&quot;a+&quot;</span>, stderr);</span><br></pre></td></tr></table></figure>

<p>这样我们就可以把可获取的日志文件发送给服务端或者通过itunes共享出来。但是由于iOS严格的沙盒机制，我们无法知道stderr原来的文件路径，也无法直接使用沙盒外的文件，所以freopen无法重定向回去，只能使用第1点所述的dup和dup2来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向</span></span><br><span class="line"><span class="type">int</span> origin1 = dup(STDERR_FILENO);</span><br><span class="line">FILE * myFile = freopen([loggingPath cStringUsingEncoding:NSASCIIStringEncoding], <span class="string">&quot;a+&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="comment">// 恢复重定向</span></span><br><span class="line">dup2(origin1, STDERR_FILENO);</span><br></pre></td></tr></table></figure>

<h2 id="使用GCD的dispatch-Source重定向方式"><a href="#使用GCD的dispatch-Source重定向方式" class="headerlink" title="使用GCD的dispatch Source重定向方式"></a>使用GCD的dispatch Source重定向方式</h2><p>具体代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (dispatch_source_t)_startCapturingWritingToFD:(<span class="type">int</span>)fd  &#123;</span><br><span class="line">    <span class="type">int</span> fildes[<span class="number">2</span>];</span><br><span class="line">    pipe(fildes);  <span class="comment">// [0] is read end of pipe while [1] is write end</span></span><br><span class="line">    dup2(fildes[<span class="number">1</span>], fd);  <span class="comment">// Duplicate write end of pipe &quot;onto&quot; fd (this closes fd)</span></span><br><span class="line">    close(fildes[<span class="number">1</span>]);  <span class="comment">// Close original write end of pipe</span></span><br><span class="line">    fd = fildes[<span class="number">0</span>];  <span class="comment">// We can now monitor the read end of the pipe</span></span><br><span class="line">    <span class="type">char</span>* buffer = malloc(<span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">NSMutableData</span>* data = [[<span class="built_in">NSMutableData</span> alloc] init];</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    dispatch_source_t source = dispatch_source_create(</span><br><span class="line">        DISPATCH_SOURCE_TYPE_READ, fd, <span class="number">0</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>));</span><br><span class="line">    dispatch_source_set_cancel_handler(source, ^&#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ssize_t size = read(fd, buffer, <span class="number">1024</span>);</span><br><span class="line">                <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                [data appendBytes:buffer length:size];</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *aString = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="comment">//printf(&quot;aString = %s&quot;,[aString UTF8String]);</span></span><br><span class="line">            <span class="comment">//NSLog(@&quot;aString = %@&quot;,aString);</span></span><br><span class="line">            <span class="comment">// Do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(source);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然上述的几个重定向的方法都能够获取到Log数据，但是弊端是当使用Log重定向之后，连接Xcode进行调试应用程序时，Xcode的Console中将不会打印任何Log信息，Log信息已经被重定向到了我们指定的文件中了。这些方法有一定的局限性，在具体使用的时候，需要视情况而定。当然还有其他的方式能够即重定向Log数据到指定文件，还能够在Xcode的Console中输出日志（pipe、dup2与GCD的相互协作），这样能够避免调试阶段无法实时查看日志的缺陷，进一步的提高开发调试和优化的效率。</p>
<p>另外也可以开发一个在桌面或者网页端实时展示Log信息的应用，实时从重定向的位置读取Log信息，达到实时查看信息的目的等。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T07:01:13.563Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-02-19T07:01:13.563Z" title="2/19/2021, 3:01:13 PM">2021-02-19</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></span><span class="level-item">1 小时读完 (大约10742个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/2018-07-26-11-tips/">11条数据化运营不得不知的数据预处理经验（无码篇）</a></h1><div class="content"><p>数据预处理是数据化运营过程中重要的环节，直接影响着后期所有的数据工作质量和价值输出。从数据预处理的主要内容来看，包括<strong>数据清洗、转换、归约、聚合、抽样等</strong>。本文将摒弃理论和方法说教，直接介绍内容本身可能遇到的问题以及应对方法。</p>
<h2 id="3-1-数据清洗：缺失值、异常值和重复值的处理"><a href="#3-1-数据清洗：缺失值、异常值和重复值的处理" class="headerlink" title="3.1 数据清洗：缺失值、异常值和重复值的处理"></a>3.1 数据清洗：缺失值、异常值和重复值的处理</h2><ul>
<li><strong>清洗：</strong>是对数据集进行丢弃、填充、替换、去重等操作，实现去除异常、纠正错误、补足缺失的目的，实现去除数据中的异常、纠正错误、补足缺失的目的。</li>
</ul>
<h3 id="3-1-1-数据列缺失的4中处理方法"><a href="#3-1-1-数据列缺失的4中处理方法" class="headerlink" title="3.1.1 数据列缺失的4中处理方法"></a>3.1.1 数据列缺失的4中处理方法</h3><p>数据缺失分为两种：</p>
<ol>
<li>行记录的缺失，此种情况又称数据记录丢失；</li>
<li>数据列值缺失，即由于某种原因导致的数据记录中某些列的值空缺等。</li>
</ol>
<blockquote>
<p>某些少数情况下，会使用空字符串来代替缺失值，但是空字符串绝对不同于缺失值，从对象实体来看，空字符串是有实体的，实体为字符串类型，而缺失值其实是没有实体的，即没有数据类型。</p>
</blockquote>
<p>丢失的行记录通常是无法找回的，而对于列值来说，通常有四种方法或者思路来处理：</p>
<p><strong>1. 丢弃</strong></p>
<p>即直接删除带有缺失值的记录（整行删除）或者列字段（整列删除），以减少缺失记录对总体数据的影响。但是丢弃也意味着消减数据特征，在以下的场景中，不宜使用：</p>
<ul>
<li>数据集总体中存在大量的数据记录不完整情况且比例较大，例如超过数据集总体的10%，删除这些带有缺失值的记录意味着损失过多的有用信息；</li>
<li>带有缺失值的数据记录大量存在着明显的数据分布规律或特征，例如带有缺失值数据记录的目标标签主要集中在某一类或几类，如果删除这些数据记录将是对应分类的数据样本丢失大量的特征信息，导致模型过拟合或者分类不准确。</li>
</ul>
<p><strong>2. 补全</strong></p>
<p>即通过一定的方式方法将缺失的数据补上，从而形成完整的数据记录，对于后续的数据处理、分析和建模至关重要。常用的补全方法有：</p>
<ul>
<li><strong>统计法：</strong> 对于数值型的数据，通常使用均值、加权均值、中位数等方法补齐；对于分类型数据，使用类别众数最多的值补齐；</li>
<li><strong>模型法：</strong> 基于已有的其他数据，将缺失值作为目标变量进行预测，从而得到最有可能的补全值。如果带有缺失值的列是数值变量，则使用回归模型补齐，如果是分类变量，则使用分类模型补齐；</li>
<li><strong>专家法：</strong> 对于少数具有重要意义的数据记录，通过领域专家来对数据进行分析，从而进行缺失值补齐；</li>
<li><strong>其他方法：</strong> 例如随机法、特殊值法、多重填补法等。</li>
</ul>
<p><strong>3. 真值转换法</strong></p>
<p>核心思路是承认缺失值的存在，并且把数据缺失也作为数据分布规律的一部分，但是缺失值往往无法在后续的数据处理和模型中进行计算，此时需要将缺失值进行<strong>真值转换</strong>。例如用户的性别，很多数据库中无法对人员的性别进行补齐，但是此性别数据又非常的重要，因此将男、女、未知从一个变量的多值分布状态转换到多个变量的真值分布状态：</p>
<ul>
<li>转换前：性别（男、女、未知）</li>
<li>转换后：性别_男（值域1或0）、性别_女（值域1或0）、性别_未知（值域1或0）</li>
</ul>
<p>然后将这3列新的字段作为输入维度以替换原来的1个字段，参与后续的数据分析、建模计算等。</p>
<p><strong>4. 不处理</strong></p>
<p>即在数据预处理阶段，不对带有缺失值的数据记录进行任何处理。此种方式主要要看后续的数据分析和建模应用，对于缺失值的容忍度或灵活处理方式。常见的能够自动补齐缺失值的模型有：<strong>KNN、决策树、随机森林、神经网络、朴素贝叶斯和DBSCAN（基于密度的带有噪声的空间聚类模型）等</strong>，这些模型对于缺失值的处理思路是：</p>
<ul>
<li>忽略：即缺失值不参与计算（KNN）</li>
<li>将缺失值作为分布的一种状态，并参与到建模过程（决策树及其变体）</li>
<li>不基于距离做计算，因此基于值的距离做计算，本身的影响将消除（DBSCAN）</li>
</ul>
<blockquote>
<p>有时候在数据采集时，采集端针对各个字段设置了一个默认值。假设原本数据采集时没有采集到数据，字段的值将以默认值赋值，此时虽然让数据集看起来非常正常，但是本质上还是确实的，需要留心此类数据。</p>
</blockquote>
<h3 id="3-1-2-不要轻易抛弃异常数据"><a href="#3-1-2-不要轻易抛弃异常数据" class="headerlink" title="3.1.2 不要轻易抛弃异常数据"></a>3.1.2 不要轻易抛弃异常数据</h3><p>异常数据是数据分布的常态，处于特定分布区域或范围之外的数据通常被定义为异常或“噪声”。从数据异常的状态来看，所谓的数据异常分为两种：</p>
<ul>
<li><strong>伪异常：</strong> 由于业务的特定运营动作产生，是正常反应业务状态的数据，而不是数据本身的异常规律；</li>
<li><strong>真异常：</strong> 并非特定的运营动作产生，而是客观反映数据本身分布异常的个案。</li>
</ul>
<p>在实际进行数据处理的过程中，“异常数据”往往被当做噪声直接剔除，但是在以下几种情况中，无需对异常值做抛弃处理：</p>
<p><strong>1. 异常值正常反应了业务运营的结果</strong>：是特定业务动作导致的数据分布异常，如果抛弃将导致无法正确反应业务的结果；</p>
<p><strong>2. 异常检测模型</strong>：异常数据本身是目标数据，如果被处理掉，将损失关键性的信息；</p>
<p><strong>3. 包容异常值的数据建模</strong>：数据算法或建模方法对异常值不敏感，异常值对模型本身不会造成负面影响（决策树中，异常值本身可以作为一种分裂节点）。</p>
<blockquote>
<p>除了抛弃和保留，还有一种思路是对异常值使用其他的统计量、预测量进行替换，但是此类方法会将数据集中本身的关键分布特征消除，从而改变原始数据集的分布规律。</p>
</blockquote>
<h3 id="3-1-3-数据重复就需要去重吗"><a href="#3-1-3-数据重复就需要去重吗" class="headerlink" title="3.1.3 数据重复就需要去重吗"></a>3.1.3 数据重复就需要去重吗</h3><p>数据集中数据重复包含两种情况：</p>
<ol>
<li>数据值完全相同的多条数据记录；</li>
<li>数据主体相同但匹配到的唯一属性值不同</li>
</ol>
<p>去重的主要目标是保留显示特征的唯一特征记录，但是当遇到以下几种情况的时候，不建议或者慎重执行数据去重：</p>
<p><strong>1. 重复的记录用于分析演变规律</strong>：例如商品类别的归属变化，不同时间段，可能同一个商品的归属有所变化，这样在数据库中可能就有一个 <strong>变化维度表</strong>。表格的维度在不断的发生变化，而对于维度的变化，有3中不同的处理方式：</p>
<ul>
<li>直接覆盖原有值（无法保留历史信息）</li>
<li>添加新的维度行（统一ID的商品会有两条匹配记录）</li>
<li>增加新的属性列（不会改变数据行记录）</li>
</ul>
<blockquote>
<p><strong>变化维度表：</strong> 是数据仓库中的概念。维度表类似匹配表，用来存储静态的维度、属性等数据，而这些数据一般都不会发生改变。但是变与不变是一个相对的概念，随着企业的不断发展，很多的维度也会发生变化，因此在某个时间内的维度是不改变的，而整体来看维度是变化的。</p>
</blockquote>
<p><strong>2. 重复的记录用于样本不均衡处理</strong></p>
<p>样本的不均衡是影响分类模型效果的关键因素之一，解决的方法一般是对少数样本进行简单过采样，通过随机过采样采取简单复制样本的策略来增加少数类样本，而这样的处理会在数据记录中产生相同记录的多条数据，此时不能对其中的重复值执行去重操作。</p>
<p><strong>3. 重复的记录用于检测业务规则问题</strong></p>
<p>主要针对的是事务性的数据，重复数据可能意味着重大运营规则问题。此类重复的数据记录可能是由于数据采集、存储、验证和审核机制的不完善问题导致的，会直接影响到前台生产和运营系统。例如重复的订单、重复的充值、重复的预约等等。</p>
<h2 id="3-2-将分类数据和顺序数据转为标志变量"><a href="#3-2-将分类数据和顺序数据转为标志变量" class="headerlink" title="3.2 将分类数据和顺序数据转为标志变量"></a>3.2 将分类数据和顺序数据转为标志变量</h2><h3 id="3-2-1-分类数据和顺序数据是什么"><a href="#3-2-1-分类数据和顺序数据是什么" class="headerlink" title="3.2.1 分类数据和顺序数据是什么"></a>3.2.1 分类数据和顺序数据是什么</h3><p>非数值型变量通常在数据建模过程中无法处理，例如KMeans算法用于计算距离的相似度，而字符串则无法直接计算距离。此类无法直接使用的数据可以分为两大类：</p>
<ol>
<li><p>分类数据：指只能归于某一类别的非数值型数据。分类数据中的值没有明显的高低、大小等包含等级、顺序、排序、好坏等逻辑划分，只能用来区分两个或多个具有相同或者相当价值的属性。是在相同衡量维度上的不同属性而已。</p>
<ul>
<li>性别 — 男、女</li>
<li>颜色 — 红、黄、蓝</li>
</ul>
</li>
<li><p>顺序数据：指只能归于某一有序类别的非数值型数据。在顺序数据中，有明显的排序规律和逻辑层次的划分。</p>
<ul>
<li>用户价值等级 — 高、中、底</li>
<li>学历 — 学士、研究生、博士</li>
</ul>
</li>
</ol>
<h3 id="3-2-2-运用标志方法处理分类和顺序数据"><a href="#3-2-2-运用标志方法处理分类和顺序数据" class="headerlink" title="3.2.2 运用标志方法处理分类和顺序数据"></a>3.2.2 运用标志方法处理分类和顺序数据</h3><p>分类数据和顺序数据要参与建模，通常会转化为数值型数据。最佳的方法是：</p>
<p><strong>将所有分类或者顺序变量的值域从一列多值的形态转换为多列只包含真值的形态，其中真值可以使用True、False或者1、0来表示。</strong> 此类转换也被称为 <strong>真值转换</strong>。例如下表格中，第一列和第二列是原始的数据格式，性别由‘男’和‘女’来表示，第三列和第四列是经过转换后的表示。（这里为了演示，并没有在转换后去除原始的“性别”一列，在实际应用中需要在转换后去除原始列）</p>
<table>
<thead>
<tr>
<th>用户ID</th>
<th>性别</th>
<th>用户性别-男</th>
<th>用户性别-女</th>
</tr>
</thead>
<tbody><tr>
<td>35666841</td>
<td>男</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>65456567</td>
<td>女</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>65498932</td>
<td>女</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="3-3-大数据时代的数据降维"><a href="#3-3-大数据时代的数据降维" class="headerlink" title="3.3 大数据时代的数据降维"></a>3.3 大数据时代的数据降维</h2><p><strong>数据降维</strong>是降低数据的维度数量，是维度归约的一种重要课题。</p>
<h3 id="3-3-1-需要数据降维的情况"><a href="#3-3-1-需要数据降维的情况" class="headerlink" title="3.3.1 需要数据降维的情况"></a>3.3.1 需要数据降维的情况</h3><p>数据降维的主要目的是降低模型的计算量并减少模型运行事件、减低噪声变量信息对于模型结果的影响，便于通过可视化的方式展示归约后的维度信息并减少数据存储空间。是否需要进行降维主要需要考虑如下几个方面：</p>
<ol>
<li><strong>维度数量</strong>： 降维的基本前提是高维，如果只有几个维度，就不需要降维了，另外还需要衡量维度的重要性、共线性以及其他排除关系，而不是出于高维的考虑。</li>
<li><strong>建模输出是否必须保留原始维度</strong>： 当需要保留原始维度时，不能进行转换方式降维，只能选择特征筛选的方式降维。</li>
<li><strong>对模型的计算效率与建模时效性有要求</strong>： 高维数据建模时，模型的消耗将呈现几何倍数增长，造成运算效率低、耗时长。</li>
<li><strong>是否要保留完整数据特征</strong>： 当需要所有数据集的完整特征时，不需要进行降维。</li>
</ol>
<h3 id="3-3-2-基于特征选择的降维"><a href="#3-3-2-基于特征选择的降维" class="headerlink" title="3.3.2  基于特征选择的降维"></a>3.3.2  基于特征选择的降维</h3><p>基于特征选择的降维指的是根据一定规则和经验，直接选取原有维度的一部分参与到后续的计算和建模过程，用选择的维度代替所有维度，整个过程不产生新的维度。基于特征选择的降维方法有四种思路：</p>
<ul>
<li><strong>经验法</strong>： 通过领域专家的经验、对业务的理解等对特征进行选择；</li>
<li><strong>测算法</strong>： 不断测试多种维度组合的结果，最终选择最佳特征组合；</li>
<li><strong>基于统计分析的方法</strong>： 对维度之间进行相关性分析，进行人工去除或者筛选；</li>
<li><strong>机器学习算法</strong>： 通过机器学习算法得到不同特征的特征值和权重，根据权重选择特征。（例如CART决策树等）</li>
</ul>
<h3 id="3-3-3-基于维度转换的降维"><a href="#3-3-3-基于维度转换的降维" class="headerlink" title="3.3.3  基于维度转换的降维"></a>3.3.3  基于维度转换的降维</h3><p>按照一定的数据变换方法，把给定的一组相关变量（维度）通过数学模型将高维空间的数据点映射到低维空间，然后利用映射变量的特征来表示原有变量的总体特质。此种方法会产生一种新的维度，而转换后的维度并不是原始维度的本体，是综合多个维度转换或者映射后的表达式。</p>
<p>基于维度转换的降维方式，通常会使用主成分分析（PCA）来进行。而PCA主要的使用场景有：</p>
<ol>
<li><strong>非监督式的数据集</strong>： PCA是一种非监督式的降维方法，因此适用于不带有标签的数据集，对于带有标签的数据集则可以使用 <strong>LDA</strong>；</li>
<li><strong>根据方差自主控制特征数量</strong>： 最大的主成分分析的数量会小于或者等于特征的数量，也就是说PCA也可以输出完全相同数据的特征，主要取决于选择特征中解释的方差比例；</li>
<li><strong>更少的正则化处理</strong>： 选择较多的主成分分析将导致较少的平滑性，因为需要保留更多的数据特征，需要减少正则化；</li>
<li><strong>数据量较大的数据集</strong>： 包括数据记录多和数据维度多两种情况；</li>
<li><strong>数据分布是位于相同平面（非曲面），数据中存在线性结构。</strong></li>
</ol>
<h2 id="3-4-解决样本类别分布不均衡的问题"><a href="#3-4-解决样本类别分布不均衡的问题" class="headerlink" title="3.4 解决样本类别分布不均衡的问题"></a>3.4 解决样本类别分布不均衡的问题</h2><p>样本不均衡是指不同类别的样本量差异非常大。主要出现在分类问题上，从数据规模上可以分为：</p>
<ul>
<li>大数据分布不均衡：整体数据规模大，只是其中的小样本类的占比较少，但从每个特征的分布上看，小样本也覆盖了大部分或者全部的特征；</li>
<li>小数据分布不均衡：整体数据规模小，并且占据少量样本比例的分类数量也少，这会导致特征分布的严重不平衡。</li>
</ul>
<h3 id="3-4-1-哪些运营场景中容易出现样本不均衡"><a href="#3-4-1-哪些运营场景中容易出现样本不均衡" class="headerlink" title="3.4.1 哪些运营场景中容易出现样本不均衡"></a>3.4.1 哪些运营场景中容易出现样本不均衡</h3><ol>
<li><strong>异常检测场景</strong>：异常检测中，异常数据本身是少量的，例如恶意刷单、信用卡欺诈场景等；</li>
<li><strong>客户流失场景</strong>：流失客户一般相对于整体客户量而言是少量的，有其是在一些垄断行业里，例如石油、网络运营商等；</li>
<li><strong>罕见事件的分析</strong>：同样属于发生个案较少，但是不同点在于异常检测通常都有预先定义的规则和逻辑，而罕见事件则无法预判，并且通常会有明显的积极或者消极的影响；</li>
<li><strong>发生频率低的事件</strong>：属于能够预期或者计划性的时间，但是发生频率非常低，例如买彩票等。</li>
</ol>
<h3 id="3-4-2-通过过抽样和欠抽样解决样本不均衡"><a href="#3-4-2-通过过抽样和欠抽样解决样本不均衡" class="headerlink" title="3.4.2 通过过抽样和欠抽样解决样本不均衡"></a>3.4.2 通过过抽样和欠抽样解决样本不均衡</h3><p>重新抽样是解决样本不均衡相对简单的方法。</p>
<ul>
<li><strong>过采样</strong>：又称上采样（over-sampling），增加分类中少数类样本的数量来实现均衡，直接的方法是复制，高端点的方法通过少数类中加入随机造成、干扰数据或通过一定的规则产生新的合成样本，例如SMOTE算法；</li>
<li><strong>欠采样</strong>：又称下采样（under-sampling），减少分类中多数类样本的数量来实现均衡，直接的方法是随机剔除。</li>
</ul>
<h3 id="3-4-3-通过正负样本的惩罚权重解决样本不均衡"><a href="#3-4-3-通过正负样本的惩罚权重解决样本不均衡" class="headerlink" title="3.4.3 通过正负样本的惩罚权重解决样本不均衡"></a>3.4.3 通过正负样本的惩罚权重解决样本不均衡</h3><p>在算法实现的过程中，对于分类中不同样本数量的类别进行分别赋予不同的权重（一般思路分类中的小样本的类别权重较高），然后进行计算和建模。</p>
<p>现在绝大部分的算法模型库中都带有类似的权重设置参数，你可以轻松的进行权重的设置等。例如scikit-learn中的SVM，通过在<code>class_weight：&#123;dict, &#39;balanced&#39;&#125;</code>中针对不同类别设置权重来进行均衡处理。SVM中进行自动均衡的计算公式为：</p>
<p><code>n_samples  / (n_classes * np.bincount(y))</code></p>
<h3 id="3-4-4-通过组合-x2F-集成方法解决样本不均衡"><a href="#3-4-4-通过组合-x2F-集成方法解决样本不均衡" class="headerlink" title="3.4.4 通过组合&#x2F;集成方法解决样本不均衡"></a>3.4.4 通过组合&#x2F;集成方法解决样本不均衡</h3><p>在每次生成训练集时使用所有分类中的小样本量，同时从分类中的大样本量中随机抽取数据来与小样本量合并构成训练集，反复之后会得到很多训练集和训练模型，最后使用组合产生分类预测结果。</p>
<h3 id="3-4-5-通过特征选择解决样本不均衡"><a href="#3-4-5-通过特征选择解决样本不均衡" class="headerlink" title="3.4.5 通过特征选择解决样本不均衡"></a>3.4.5 通过特征选择解决样本不均衡</h3><p>一般情况下，样本不均衡也会导致特征分布不均衡，但是如果小类别样本量具有一定的规模，意味着其特征值的分布较为均衡，可通过选择具有显著性的特征配合参与解决样本不均衡问题，一定程度上能够提高模型的效果。</p>
<h2 id="3-5-如何解决运营数据源的冲突问题"><a href="#3-5-如何解决运营数据源的冲突问题" class="headerlink" title="3.5 如何解决运营数据源的冲突问题"></a>3.5 如何解决运营数据源的冲突问题</h2><ol>
<li><strong>数据类型冲突</strong>：同一数据对象的数据格式不同，常见的有时间戳、日期等；</li>
<li><strong>数据结构冲突</strong>：同一数据主体的描述结构有冲突，典型的代表是关联主键ID值由不同的逻辑结构，导致后期多源数据匹配和关联变的复杂；</li>
<li><strong>记录粒度不同</strong>：对于订单记录的粒度可以存在以订单ID为基础的一条数据中，此时多个商品同时存在商品项目列中；</li>
<li><strong>数据值域的定义不同</strong>：以订单来看，销售系统中可能包括提交订单、审核中、已审核通过、审核不通过四种状态；而库存系统中对于订单状态可能包括提交订单、审核通过、商品分拣、商品包装、商品出库、商品配送、配送成功。这些状态还仅是正常情况下的正向订单状态，即从商家发货到客户手中。几乎每个企业也都存在负向订单，通常产生于退换货的场景下，此时从会员发货到商家手中，这类的订单状态会更多；</li>
<li><strong>数据值不同</strong>：数据值的不同是数据冲突最重要也是最关键的问题所在，不同的数据源通过ETL过程大多可以解决，但若出现数据值不同的问题却难以判断到底哪份数据是正确的。</li>
</ol>
<h3 id="3-5-1-为什么会出现多数据源的冲突"><a href="#3-5-1-为什么会出现多数据源的冲突" class="headerlink" title="3.5.1 为什么会出现多数据源的冲突"></a>3.5.1 为什么会出现多数据源的冲突</h3><ol>
<li><strong>内部工具与第三方工具数据冲突</strong>：<ol>
<li>对比指标不同（广告媒体代理商与网站统计分析）</li>
<li>测量的时机不同</li>
<li>网络丢包的问题</li>
<li>去重机制的问题</li>
<li>用户中途退出问题</li>
<li>页面跟踪加载问题</li>
<li>动机导致的数据夸大</li>
<li>其他因素</li>
</ol>
</li>
<li><strong>内部同一个业务主体的同一类数据工具的数据测量冲突</strong><ol>
<li>指标定义不同</li>
<li>采集逻辑不同</li>
<li>系统过滤规则不同</li>
<li>更新时间不同</li>
<li>监测位置不同</li>
</ol>
</li>
<li><strong>内部同一个业务主体的不同数据工具的数据测量冲突</strong><ol>
<li>订单来源差异</li>
<li>特殊商品订单跟踪</li>
<li>订单状态差异</li>
<li>数据同步问题</li>
<li>内部系统拆单问题</li>
</ol>
</li>
</ol>
<h3 id="3-5-2-如何应对多数据源的冲突问题"><a href="#3-5-2-如何应对多数据源的冲突问题" class="headerlink" title="3.5.2 如何应对多数据源的冲突问题"></a>3.5.2 如何应对多数据源的冲突问题</h3><ol>
<li><strong>消除冲突并形成一份唯一数据</strong>：全量数据的汇总统计工作等；</li>
<li><strong>不消除冲突也不作任何处理</strong>：使用细粒度的数据进行数据建模等；</li>
<li><strong>不消除冲突但是使用全部冲突数据</strong>： 进行流程性统计分析等。</li>
</ol>
<blockquote>
<p>不消除冲突的情况下，也需要谨慎的对待这种情况，一般情况下，需要关注两方面内容：</p>
</blockquote>
<blockquote>
<ol>
<li><strong>差异性</strong>： 对于相同实体在相同逻辑下的数据冲突（差异）应该在5%以内，条件允许时可放宽到10%，超过则需要严格对待冲突问题；</li>
<li><strong>稳定性</strong>： 当冲突无法消除时，需要确保多数据源数据的差异性相对稳定，不能出现差异变更甚至相反分布的情况。</li>
</ol>
</blockquote>
<h2 id="3-6-数据化运营要抽样还是全量数据"><a href="#3-6-数据化运营要抽样还是全量数据" class="headerlink" title="3.6 数据化运营要抽样还是全量数据"></a>3.6 数据化运营要抽样还是全量数据</h2><p>抽样是从整体样本中通过一定的方法选择一部分样本，抽样是雏菊处理的基本步骤之一，也是科学实验、质量检测、社会调查等普遍使用的一种经济有效的工作方法。</p>
<h3 id="3-6-1-什么时候需要抽样"><a href="#3-6-1-什么时候需要抽样" class="headerlink" title="3.6.1 什么时候需要抽样"></a>3.6.1 什么时候需要抽样</h3><ol>
<li>数据计算资源不足</li>
<li>数据采集限制</li>
<li>时效性要求</li>
</ol>
<p>应该使用抽样的方法来解决具体问题的场景：</p>
<ul>
<li>通过抽样实现快速的概念验证</li>
<li>通过抽样来解决样本不平衡问题</li>
<li>无法实现对全部样本覆盖的数据化运营场景</li>
<li>定性分析的工作需要</li>
</ul>
<h3 id="3-6-2-如何进行抽样"><a href="#3-6-2-如何进行抽样" class="headerlink" title="3.6.2 如何进行抽样"></a>3.6.2 如何进行抽样</h3><p>抽样从整体上分为 <strong>非概率抽样</strong> 和 <strong>概率抽样</strong> 两种。非概率抽样不是按照等概率的原则进行抽样，而是根据人类的主观经验和状态进行判断；概率抽样则是以数学概率论为基础，按照随机的原则进行抽样，一般概率抽样分为如下几种：</p>
<ol>
<li>简单随机抽样：适用于个体分布均匀的场景</li>
<li>等距抽样：适用于个体分布均匀或呈现明显的均匀分布规律，无明显趋势或周期性规律的数据</li>
<li>分层抽样：适用于带有分类逻辑的属性、标签等特征的数据</li>
<li>整群抽样：适用于小群体集的特征差异较小，并且对划分小群体集有更高的要求</li>
</ol>
<h3 id="3-6-3-抽样需要注意的几个问题"><a href="#3-6-3-抽样需要注意的几个问题" class="headerlink" title="3.6.3 抽样需要注意的几个问题"></a>3.6.3 抽样需要注意的几个问题</h3><p><strong>1. 数据抽样要能反映运营背景</strong></p>
<p>数据能正确反映运营背景，但实际上此过程需要数据工作者对于运营环节和流程非常熟悉才可。</p>
<p>以下是常见的抽样不能反映运营背景的情况：</p>
<ul>
<li>数据时效性问题：使用合适时间段的数据，而非历史久远的数据</li>
<li>缺少关键因素数据：没有运营活动的关键性数据</li>
<li>不具备业务随机性：抽样后的数据只能反映某一种特定的数据场景</li>
<li>没有考虑业务增长性：企业在成长，数据也应该有所变化</li>
<li>没有考虑数据来源的多样性：不能只选择某一个来源的数据</li>
<li>业务数据可行性问题：根据运营实际情况调整数据工作</li>
</ul>
<p><strong>2. 数据抽样要能满足数据分析和建模要求</strong></p>
<p>数据抽样要注意一下几个方面：</p>
<ol>
<li>抽样样本量的问题<ul>
<li>以时间为维度分布的，至少要包含一个能满足预测的完整业务周期；</li>
<li>做预测（包含分类和回归）分析建模的，需要考虑特征数量和特征值域的分布，通常数据记录数要同时是特征数量和特征值域的100倍以上；</li>
<li>做关联规则分析建模的，根据关联前后项的数量（每个前项和后项可包含多个要关联的主体），每个主体需要至少1000条数据；</li>
<li>对于异常检测类分析建模的，无论是监督式还是无监督式建模，由于异常数据本来就是小概率分布的，因此异常数据记录一般越多越好。</li>
</ul>
</li>
<li>抽样样本在不同类别中的分布问题</li>
</ol>
<ul>
<li><p>抽样样本能准确代表全部整体特性：</p>
<ul>
<li>非数值型的特征值域（例如各值频数相对比例、值域范围等）分布需要和总体一致；</li>
<li>数值型特征的数据分布区间和各个统计值（如均值、方差、偏度等）需要与整体数据分布区间一致；</li>
<li>缺失值、异常值、重复值等特殊数据的分布要与整体数据分布一致。</li>
</ul>
</li>
<li><p>异常检测类数据的处理：</p>
<ul>
<li>对于异常检测类的应用要包含全部异常样本；</li>
<li>对于需要去除业务因素的数据异常，如果有类别特征需要跟类别特征分布一致；如果没有类别特征，属于无监督式学习，则需要和整体分布一致。</li>
</ul>
</li>
</ul>
<h2 id="3-7-解决运营数据的共线性问题"><a href="#3-7-解决运营数据的共线性问题" class="headerlink" title="3.7 解决运营数据的共线性问题"></a>3.7 解决运营数据的共线性问题</h2><p>所谓<strong>共线性</strong>（又称为多重共线性）问题是指输入的自变量之间存在较高的线性相关度。会导致回归模型的稳定性和准确性大大下降，过多共线性的维度参与计算会浪费计算资源和时间。</p>
<p>常见的具有明显的共线性的维度或者变量包括：</p>
<ul>
<li>访问量和页面浏览量</li>
<li>页面浏览量和访问时间</li>
<li>订单量和销售额</li>
<li>订单量和转化率</li>
<li>促销费用和销售额</li>
<li>网络展示广告费用和访客数</li>
</ul>
<p>导致出现变量之间共线性的原因包括：</p>
<ul>
<li>数据样本不够，可能导致共线性存在偶然性（数据不够）</li>
<li>多个变量都基于时间有共同或者相反的演变趋势（双11的网络销售额比平时有上升趋势）</li>
<li>多个变量间存在一定的推移关系，但是总体上变量间的趋势一致，只是发生在时间点不一致（广告曝光后才会出现销售额）</li>
<li>多个变量间存在近似线性关系（访客数y，广告费x，关系可能是 y &#x3D; 2 * x + b）</li>
</ul>
<h3 id="3-7-1-如何检测共线性"><a href="#3-7-1-如何检测共线性" class="headerlink" title="3.7.1 如何检测共线性"></a>3.7.1 如何检测共线性</h3><p>共线性一般通过容忍度、方差膨胀因子、特征值这几个特征数据来做判断：</p>
<ul>
<li>容忍度（Tolerance）：是每个自变量作为因变量对其他自变量进行回归建模时得到的残差比例，大小用1减得到的决定系数来表示。容忍度的值介于0.1和1之间，越小说明这个自变量与其他自变量间越可能存在共线性问题；</li>
<li>方差膨胀因子（Variance Inflation Factor, VIF）: VIF是容忍度的倒数，值越大则共线性问题越明显，通常以10作为判断边界。当VIF&lt;10，不存在多重共线性，当10≤VIF&lt;100，存在较强的多重共线性，VIF≥100，存在严重多重共线性；</li>
<li>特征值（Eigenvalue）：对自变量进行主成分分析，如果多个维度的特征值等于0，则可能有比较严重的共线性。</li>
</ul>
<h3 id="3-7-2-解决共线性的5中常用方法"><a href="#3-7-2-解决共线性的5中常用方法" class="headerlink" title="3.7.2 解决共线性的5中常用方法"></a>3.7.2 解决共线性的5中常用方法</h3><ol>
<li><strong>增大样本量（huge samples）</strong>：可以减低共线性问题，但是不一定会解决</li>
<li><strong>岭回归法（Ridge Regression）</strong>：放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价来获得更实际和可靠性更强的回归系数</li>
<li><strong>逐步回归法（Stepwise Regression）</strong>：每次引入一个自变量并进行统计检验，然后逐步引入其他变量，同时对所有变量的回归系数进行检验。如果改变不在显著，则剔除</li>
<li><strong>主成分回归（Principal Components Regression）</strong>：通过PCA将参与建模的变量转换为少数几个主成分，每个成分是原来变量的线性组合，再进行回归分析</li>
<li><strong>人工去除</strong>：直接结合人工经验，对参与回归模型的变量进行剔除</li>
</ol>
<h2 id="3-8-有关相关性分析的混沌"><a href="#3-8-有关相关性分析的混沌" class="headerlink" title="3.8 有关相关性分析的混沌"></a>3.8 有关相关性分析的混沌</h2><p>相关性分析是指对多个具备相关关系的变量进行分析，从而衡量变量间的相关程度或者密切程度。相关性用 <strong>R（相关系数）</strong> 表示，取值范围 <code>[-1, 1]</code>。</p>
<h3 id="3-8-1-相关和因果是一回事吗"><a href="#3-8-1-相关和因果是一回事吗" class="headerlink" title="3.8.1 相关和因果是一回事吗"></a>3.8.1 相关和因果是一回事吗</h3><p>相关性不等于因果，用 <code>x1</code> 和 <code>x2</code> 作为两个变量进行解释，相关意味着 <code>x1</code> 和 <code>x2</code> 是逻辑上的并列相关关系，而因果关系可解释为应为 <code>x1</code> 所以 <code>x2</code>的逻辑关系。相关性不是用来分析 “为什么”，而是知道 “是什么”。</p>
<h3 id="3-8-2-相关系数低就是不相关吗"><a href="#3-8-2-相关系数低就是不相关吗" class="headerlink" title="3.8.2 相关系数低就是不相关吗"></a>3.8.2 相关系数低就是不相关吗</h3><p><strong>R</strong> 的趋势是可以为负数的，但是负数并不代表相关性低，而是代表两个变量的增长趋势是相反的，因此要看 <strong>R</strong> 的绝对值来判断相关性的强弱的。</p>
<h2 id="3-9-标准化，让运营数据落入相同的范围"><a href="#3-9-标准化，让运营数据落入相同的范围" class="headerlink" title="3.9 标准化，让运营数据落入相同的范围"></a>3.9 标准化，让运营数据落入相同的范围</h2><p>标准化是一个常用的数据预处理操作，目的是处理不同规模和量纲的数据，使其缩放到相同的数据区间和范围，以减少规模、特征、分布差异等对模型的影响。</p>
<h3 id="3-9-1-实现中心化和整正态分布的Z-Score"><a href="#3-9-1-实现中心化和整正态分布的Z-Score" class="headerlink" title="3.9.1 实现中心化和整正态分布的Z-Score"></a>3.9.1 实现中心化和整正态分布的Z-Score</h3><p>Z-Score 标准化是基于原始数据的均值和标准差进行的标准化，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = （x - mean） / std</code>，其中mean和std是x所在列的均值和标准差。Z-Score方法是一种中心化方法，会改变原有数据的分布结构，不适合用于对稀疏数据做处理。</p>
<h3 id="3-9-2-实现归一化的Max-Min"><a href="#3-9-2-实现归一化的Max-Min" class="headerlink" title="3.9.2 实现归一化的Max-Min"></a>3.9.2 实现归一化的Max-Min</h3><p>Max-Min标准化是对原始数据进行线性变换，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = （x - min） / (max - min)</code>，其中min和max为x所在列的最小值和最大值。Max-Min方法能够使数据归一化而落入一定区间内，同时还能较好保持原有数据的结构。</p>
<h3 id="3-9-3-用于稀疏数据的MaxAbs"><a href="#3-9-3-用于稀疏数据的MaxAbs" class="headerlink" title="3.9.3 用于稀疏数据的MaxAbs"></a>3.9.3 用于稀疏数据的MaxAbs</h3><p>最大值绝对值标准化即根据最大值的绝对值进行标准化，假设原转换的数据为 <code>x</code>, 新数据为 <code>x′</code>，那么 <code>x′ = x / \max\</code>，其中max为x所在列的最大值。MaxAbs的数据区间为[-1， 1]，不会破坏原有数据分布结构的特点，因此也可以用于稀疏数据、稀疏的CSR或CSC矩阵。</p>
<blockquote>
<p>CSR（Compressed Sparse Row, 行压缩）、CSC（Compressed Sparse Column，列压缩）</p>
</blockquote>
<h3 id="3-9-4-针对离群点的RobustScaler"><a href="#3-9-4-针对离群点的RobustScaler" class="headerlink" title="3.9.4 针对离群点的RobustScaler"></a>3.9.4 针对离群点的RobustScaler</h3><p>某些情况下，假设数据集中有离群点，可以使用Z-Score进行标准化，但是标准化后的数据不理想，因为异常点的特征往往在标准化之后容易失去离群特点，此时可以使用RobustScaler针对离群点做标准化处理。</p>
<h2 id="3-10-离散化，对运营数据做逻辑分层"><a href="#3-10-离散化，对运营数据做逻辑分层" class="headerlink" title="3.10 离散化，对运营数据做逻辑分层"></a>3.10 离散化，对运营数据做逻辑分层</h2><p>所谓离散化，就是把无限空间中有限的个体映射到有限的空间中。大多数是对连续性数据进行，处理后的数据值域分布将从连续属性变为离散属性。离散化处理的必要性有：</p>
<ul>
<li><strong>节约计算资源，提高计算效率</strong></li>
<li><strong>算法模型（尤其是分类模型）的计算需要</strong>（例如决策树模型本身支持输入连续性数据，但是会将连续性数据转化为离散化数据）</li>
<li><strong>增强模型的稳定性和准确度</strong>（离散化后，异常数据会被划分为一个子集中的一部分，对模型的影响大大降低，尤其是基于距离计算的模型，K均值、协同过滤等）</li>
<li><strong>特定数据处理和分析的必要步骤，尤其在图像处理方面应用广泛</strong>（二值化也是离散化的一种）</li>
<li><strong>模型结果应用和部署的需要</strong></li>
</ul>
<h3 id="3-10-1-针对时间数据的离散化"><a href="#3-10-1-针对时间数据的离散化" class="headerlink" title="3.10.1 针对时间数据的离散化"></a>3.10.1 针对时间数据的离散化</h3><p>主要用于以时间为主要特征的数据集和粒度转换，离散化处理后将分散的时间特征转换为更高层次的时间特征。常见的针对时间数据的离散化操作分为两类：</p>
<ol>
<li>针对一天中的时间离散化：一般是将时间戳转换为时、分、秒或者上午、下午、晚上等</li>
<li>针对日粒度以上数据的离散化：一般是将日期转换为周数、周几、月、工作日或者休息日、季度、年等</li>
</ol>
<p>针对时间数据的离散化可以将细粒度的时间序列数据离散化为粗粒度的三类数据：</p>
<ol>
<li><strong>离散化为分类数据</strong>：例如上午、下午</li>
<li><strong>离散化为顺序数据</strong>：例如周一、周二、周三</li>
<li><strong>离散化为数值型数据</strong>：例如一年有52周，周数就是数值型的数据</li>
</ol>
<h3 id="3-10-2-针对多值离散数据的离散化"><a href="#3-10-2-针对多值离散数据的离散化" class="headerlink" title="3.10.2 针对多值离散数据的离散化"></a>3.10.2 针对多值离散数据的离散化</h3><p>多值离散数据的离散化是指要进行离散化处理的数据本身不是数值型数据，而是分类或者顺序数据。</p>
<p>例如用户活跃度变量的值，原来为高、中、低三个类别，但是由于业务的变化，新的用户活跃度变量需要高、中、低、负四个类别，此时就需要对不同类别的数据进行统一规则的离散化处理。</p>
<h3 id="3-10-3-针对连续数据的离散化"><a href="#3-10-3-针对连续数据的离散化" class="headerlink" title="3.10.3 针对连续数据的离散化"></a>3.10.3 针对连续数据的离散化</h3><p>此类离散化是主要的离散化应用，在分类或者关联分析中应用广泛，此类算法的结果是以类别或者属性标识为基础，而非数值型标记。连续数据的离散化结果可以分为两类：</p>
<ol>
<li>将连续数据划分为特定区间的集合</li>
<li>将连续数据划分为特定类</li>
</ol>
<p>常用实现针对连续数据离散化的方法包括：</p>
<ul>
<li><strong>分位数法</strong>：使用四分位、五分位、十分位等分位数进行离散化处理</li>
<li><strong>距离区间法</strong>：等距区间或者自定义区间进行离散化</li>
<li><strong>频率区间法</strong>：按照不同数据的频率分布进行排序，再按照等频率或者指定频率离散化（会改变原有数据的分布状态）</li>
<li><strong>聚类法</strong>：使用K均值将样本集分为多个离散化的簇</li>
<li><strong>卡方</strong>：基于卡方的离散化方法，找出数据的最佳临近区间并合并，形成较大的区间。</li>
</ul>
<h3 id="3-10-4-针对连续数据的二值化"><a href="#3-10-4-针对连续数据的二值化" class="headerlink" title="3.10.4 针对连续数据的二值化"></a>3.10.4 针对连续数据的二值化</h3><p>二值化是指对每个数据点跟阈值进行比较，大于阈值设置为某一固定值，小于阈值设置为某一固定值，然后得到一个只拥有两个值域的二值化数据集。</p>
<p>二值化应用的前提是数据集中所有的属性值所代表的含义相同或类似。</p>
<h2 id="3-11-数据处理应该考虑哪些运营业务因素"><a href="#3-11-数据处理应该考虑哪些运营业务因素" class="headerlink" title="3.11 数据处理应该考虑哪些运营业务因素"></a>3.11 数据处理应该考虑哪些运营业务因素</h2><p>数据处理工作不仅依赖于数据工作者的经验，也需要考虑实际的运营业务因素。数据处理时应该考虑的运营业务因素包括固定和突发运营周期、运营需求的有效性、交付时要贴合运营落地场景、专家经验、业务需求等变动因素。</p>
<h3 id="3-11-1-考虑固定和突发运营周期"><a href="#3-11-1-考虑固定和突发运营周期" class="headerlink" title="3.11.1 考虑固定和突发运营周期"></a>3.11.1 考虑固定和突发运营周期</h3><p>运营周期的属性主要表现在两个方面：</p>
<ol>
<li><strong>有计划的周期性</strong></li>
<li><strong>临时或突发周期</strong></li>
</ol>
<p>运营业务的周期性对数据的影响：</p>
<ul>
<li>有计划的周期在数据的选取和分析过程中非常重要，尤其涉及对比时，选对具有相同属性的对比周期是形成结论的基础</li>
<li>有计划的运营周期对于时间序列特征明显的建模影响较大，包括时间序列、时序关联、隐马尔可夫模型等</li>
<li>不同周期下产生的数据可能有差异，尤其是对于高速发展的新型公司，不同周期下的数据可能带有明显的线性、指数、二项式以及其他变化特征，甚至可能带有业务因素导致的异常数据点</li>
<li>运营过程中可能产生突发的数据工作需求</li>
<li>数据工作的整个过程需要运营业务人员参与，而依赖于运营业务人员参与的时机以及对应的方式和切入点也很重要。</li>
</ul>
<h3 id="3-11-2-考虑运营需求的有效性"><a href="#3-11-2-考虑运营需求的有效性" class="headerlink" title="3.11.2 考虑运营需求的有效性"></a>3.11.2 考虑运营需求的有效性</h3><p>数据工作者可以对某些需求做拒绝或者延迟处理，主要原因如下：</p>
<ol>
<li><strong>缺少数据</strong></li>
<li><strong>需求不合理</strong></li>
<li><strong>条件限制</strong></li>
<li><strong>资源限制</strong></li>
<li><strong>低价值需求</strong></li>
</ol>
<h3 id="3-11-3-考虑交付时要贴合运营落地场景"><a href="#3-11-3-考虑交付时要贴合运营落地场景" class="headerlink" title="3.11.3 考虑交付时要贴合运营落地场景"></a>3.11.3 考虑交付时要贴合运营落地场景</h3><p>数据处理工作虽然只是中间过程，并没有到达数据分析、建模、部署和应用的阶段，但是该阶段的很多工作会直接影响后期的交付和运营落地，典型因素如下：</p>
<ol>
<li><strong>维持原有指标</strong></li>
<li><strong>更容易理解的算法限制</strong></li>
<li><strong>数据生产和应用环境</strong></li>
</ol>
<h3 id="3-11-4-不要忽视业务专家的经验"><a href="#3-11-4-不要忽视业务专家的经验" class="headerlink" title="3.11.4 不要忽视业务专家的经验"></a>3.11.4 不要忽视业务专家的经验</h3><p>业务专家经验在数据处理工作中的重要作用体现在一下两个方面：</p>
<ol>
<li><strong>数据工作方向</strong>：专家经验会决定需要做什么、产出是什么、中间的过程应该向哪个方向考虑，侧重于“是什么”。直接影响着：<ul>
<li>数据项目工作目标和需求</li>
<li>数据探索和摸底方向</li>
<li>数据交付物的形式和规格</li>
</ul>
</li>
<li><strong>数据工作逻辑</strong>：专家经验可以提出有价值的参考和工作建议，侧重于“怎么做”，直接影响着：<ul>
<li>总体数据周期、规则、条件等的选取</li>
<li>数据抽样规则，有其涉及到分层、整群抽样</li>
<li>多数据的整合、匹配和关联关系</li>
<li>不同数据源和数据间的清洗、转换逻辑</li>
<li>重复值、异常值和缺失值的处理逻辑</li>
<li>数据离散化的方法选择和区间定义</li>
<li>根据变量重要性进行数据变量的选取和降维</li>
<li>数据算法和模型选择</li>
<li>数据模型的调整、评估和优化</li>
</ul>
</li>
</ol>
<h3 id="3-11-5-考虑业务需求的变动因素"><a href="#3-11-5-考虑业务需求的变动因素" class="headerlink" title="3.11.5 考虑业务需求的变动因素"></a>3.11.5 考虑业务需求的变动因素</h3><p>为了最小程度的降低业务的变动给数据工作带来困惑，甚至失败，应该提前做好如下几个准备：</p>
<ol>
<li><strong>充分、有效的沟通</strong></li>
<li><strong>更完整、更原始的数据集</strong></li>
<li><strong>可理解性强、规则清晰的算法和模型</strong></li>
<li><strong>模块化工作方法</strong></li>
<li><strong>建立数据工作流程和机制</strong></li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/5/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/7/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link is-current" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.804Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2018-08-28-coreml-vs-mlkit/">Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.803Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2020-07-13-iOS-memory-manager/">Runtime剖析05 --- 再议iOS内存管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.802Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-09-07-machine-learning-feature/">机器学习与移动应用开发的未来</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.801Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-08-31-mind-flower/">思维的火花 --- 大数据与数据思维</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.800Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/">\#1\ 为什么要学习数据结构与算法</a></p><p class="categories"><a href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">48</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">Swift中的数据结构与算法</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"><span class="tag">开发知识 iOS</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">开发知识 技术人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">技术人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F-%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"><span class="tag">技术人生 读书计划</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-Python/"><span class="tag">数据科学 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"><span class="tag">机器学习 Keras MNIST</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-MFCC/"><span class="tag">机器学习 MFCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python/"><span class="tag">机器学习 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97-CoreML/"><span class="tag">端测计算 CoreML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>