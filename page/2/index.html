<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/1/cover.jpg" alt="\#1\ 为什么要学习数据结构与算法"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.800Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:27.134Z" title="4/30/2022, 3:45:27 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">15 分钟读完 (大约2188个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/">\#1\ 为什么要学习数据结构与算法</a></h1><div class="content"><p>随机网络上有大量的程序员应该学习<strong>数据结构和算法</strong>的文章。还记得实在大学时代的时候，系统的学习过数据结构、算法相关的课程，而后几乎没有系统学习过了。工作后从一开始的各种业务逻辑的开发，慢慢深入了解到系统底层，了解了代码的执行效率以及对硬件设备资源的消耗基本上都是由数据结构和算法决定的，才开始慢慢关心起来良好的数据结构设计和良好的算法设计，才能够在数据量越来越多的时候，所设计的软件才能良好地执行等。</p>
<p>那么对于程序员来说，到底为什么要学习数据结构和算法呢？首先要了解的是什么是<strong>数据结构</strong>？</p>
<h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>具体的定义这里摘录了维基百科的定义，具体如下：</p>
<blockquote>
<p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。</p>
<p>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>
<p>大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。</p>
<p>数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p>
<p>不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。</p>
<p>正确的数据结构选择可以提高算法的效率（请参考算法效率）。在计算机程序设计的过程中，选择适当的数据结构是一项重要工作。许多大型系统的编写经验显示，程序设计的困难程度与最终成果的质量与表现，取决于是否选择了最适合的数据结构。</p>
<p>系统架构的关键因素是数据结构而非算法的见解，导致了多种形式化的设计方法与编程语言的出现。绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于用户界面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类 (计算机科学)来达到这个目的。</p>
<p>摘录自维基百科: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/5/cover.jpg" alt="\#5\ Linked List &amp;&amp; Swift Collection Protocol"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.800Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:33.512Z" title="4/30/2022, 3:45:33 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">18 分钟读完 (大约2751个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/">\#5\ Linked List &amp;&amp; Swift Collection Protocol</a></h1><div class="content"><p>在Swift标准库（<strong>Swift standard library</strong>）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集合中，有四种关于<strong>集合的协议（collection protocols）</strong>，分别是：</p>
<ul>
<li><strong>Tier 1, Sequence：</strong>序列类型是Swift中最为朴素的协议,仅仅定义了一系列类型相同的元素，而不对这一系列元素的性质有任何额外的约定。它唯一约定了的动作，就是从序列当前位置读取下一个元素。</li>
<li><strong>Tier 2, Collection：</strong>集合类型是一种提供额外保证的序列类型。集合类型是有限的，允许重复的非破坏性顺序访问。</li>
<li><strong>Tier 3, BidirectionalColllection：</strong>集合类型可以是双向集合类型，可以允许在序列中上下双向移动。 这对于链表是不可能的，因为你只能从头到尾，而不是相反。</li>
<li><strong>Tier 4, RandomAccessCollection：</strong>如果它可以保证访问特定索引处的元素将花费与访问任何其他索引处的元素一样长的时间。该双向集合类型就是随机访问集合类型， 这对于链表来说是不可能的，因为访问列表前面附近的节点比列表下方的节点快得多。</li>
</ul>
<p>因此对于链表数据结构来说，<strong>Sequence</strong>和<strong>Collection</strong>两种协议是适用的。首先链表是一个序列型数据结构，适用<strong>Sequence</strong>协议，另外链表是有限序列，适用<strong>Collection</strong>协议。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.799Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:17.541Z" title="4/30/2022, 3:45:17 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">16 分钟读完 (大约2350个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-08-02-novelty-detection/">异常点检测算法小结</a></h1><div class="content"><p>异常点检测，有时也叫离群点检测，英文一般叫做Novelty Detection或者Outlier Detection,是比较常见的一类非监督学习算法，这里就对异常点检测算法做一个总结。</p>
<h2 id="异常点检测算法使用场景"><a href="#异常点检测算法使用场景" class="headerlink" title="异常点检测算法使用场景"></a>异常点检测算法使用场景</h2><p>什么时候我们需要异常点检测算法呢？常见的有三种情况。</p>
<ol>
<li>在做特征工程的时候需要对异常的数据做过滤，防止对归一化等处理的结果产生影响。</li>
<li>对没有标记输出的特征数据做筛选，找出异常的数据。</li>
<li>对有标记输出的特征数据做二分类时，由于某些类别的训练样本非常少，类别严重不平衡，此时也可以考虑用非监督的异常点检测算法来做。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2018-08-02-novelty-detection/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-23-transition/"><img class="fill" src="/images/transition/cover.jpg" alt="如何完成技术跃迁"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.798Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:13.181Z" title="4/30/2022, 3:45:13 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">1 小时读完 (大约10762个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-23-transition/">如何完成技术跃迁</a></h1><div class="content"><p>前言：近期又到了毕业招聘季，我作为技术分享嘉宾，回到母校参加宣讲会，做了一个主题为《如何在毕业三年完成技术跃迁》的分享，本文由此次分享整理而成，并改名为《如何完成技术跃迁》，希望能够给刚进入职场的程序员，或者卡在瓶颈期的程序员，带来一些指导，在技术的道路上少走些弯路。请注意，本文源于我的经验思考，非教条或准则，仅供参考。另由于本人主要的项目经验来源于App端（主要是iOS、Android），Web前端及后端只是稍有涉猎，因此文中的例子大多也来自App端，其他端同学可能会觉得陌生，但应该不会影响理解。</p>
<p>本文约1W字，阅读时长大概二十分钟，稍有啰嗦，请见谅。 </p>
<h1 id="1-什么是技术跃迁"><a href="#1-什么是技术跃迁" class="headerlink" title="1. 什么是技术跃迁"></a>1. 什么是技术跃迁</h1><p>首先，我们需要明确一个定义，什么是技术跃迁？在说技术跃迁之前，跟大家解释下跃迁这个词。</p>
<p>”跃迁“，来源于量子力学，说的是微观状态发生跳跃式变化的过程，比如从低能态跳跃到高能态，需要注意的是：因为微观粒子的状态是分立的，也即是非连续性的，所以这个变化是跳跃性的。用这个词来说明技术的成长，个人认为是非常合适的。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-03-23-transition/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.796Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:05.377Z" title="4/30/2022, 3:45:05 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">1 小时读完 (大约11266个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/">机器学习基础介绍</a></h1><div class="content"><p><strong>机器学习是一门从数据中提取知识的技术。</strong> 它是统计学、人工智能和计算机科学的交叉研究领域，被常被称为<strong>预测分析</strong>、<strong>统计学习</strong>。机器学习方法的应用近年来在日常生活中无处不在。从自动推荐看哪部电影、点什么食物或买什么东西，到个性化的在线收音机、智能化在线教育，再到从照片中找到你的朋友等等需要现代网站和设备的核心都是机器学习算法。当你查看例如Facebook、Amazon、Netflix、Weibo、Twitter等复杂网站时，很可能网站的每个部分都包含了多个机器学习模型。</p>
<p>除了商业应用之外，机器学习已经对数据驱动的研究方式产生了巨大的影响。机器学习相关的技术、工具已经应用于各种科学问题，例如理解恒星、发现遥远的行星、发现新的粒子、分析DNA序列以及提供个性化的癌症治疗等。</p>
<p>但是，为了从机器学习中获益，你的应用程序可能并不需要大规模。在本部分，将解释为什么机器学习变的如此的流行，并讨论使用机器学习可以解决哪些问题。然后，将展示如何构建你的第一个机器学习模型等。</p>
<h2 id="为什么是机器学习？"><a href="#为什么是机器学习？" class="headerlink" title="为什么是机器学习？"></a>为什么是机器学习？</h2><p>较早期的“智能”应用程序，许多的系统使用“if”和“else”硬编码规则来处理数据或者根据用户的输入进行调整。想象一个垃圾邮件过滤器，其工作是适当的移动电子邮件到垃圾邮件文件夹。你可以构造一个垃圾邮件词库黑名单，并返回垃圾邮件标记 <em>1</em>。这是一个使用专家设计的规则来实现“智能”应用程序的例子。手工创建决策规则对于一些应用程序是可行的，特别是那些人类对建模过程有很好理解的应用程序，然而，使用手工编码的规则进行决策有两点主要缺点：</p>
<ul>
<li>做出决策所需的规则逻辑是针对特定的单个域和任务的，一些业务改变，整个系统可能都需要重写；</li>
<li>设计规则需要深刻理解人类专家应该如何做出决定。</li>
</ul></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-08-iOS_Tips/"><img class="fill" src="/images/ios-jq/logo.jpeg" alt="iOS开发隐藏技能如何开启"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.795Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:58.501Z" title="4/30/2022, 3:44:58 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">8 分钟读完 (大约1230个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-08-iOS_Tips/">iOS开发隐藏技能如何开启</a></h1><div class="content"><p>在iOS的开发过程中，我们经常会遇到一些需要关心但是无法直接得到的信息，本文记录了一些能够开启IDE隐藏功能的方法，帮助开发者了解更多的信息等。</p>
<h2 id="1-在-Xcode-中追踪构建时间"><a href="#1-在-Xcode-中追踪构建时间" class="headerlink" title="1. 在 Xcode 中追踪构建时间"></a>1. 在 Xcode 中追踪构建时间</h2><p>在使用Xcode进行项目的编译和打包的时候，总是耗时的，而这个时间Xcode本身是具有统计功能的。如果需要查看此时间，需要开启Xcode的<code>ShowBuildOperationDuration</code>选项，打开命令行工具，直接输入如下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES</span><br></pre></td></tr></table></figure>

<p>开启后，Xcode的构建完成后，会在Xcode的状态栏显示本次构建的耗时。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-03-08-iOS_Tips/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-iOS_VMManage/"><img class="fill" src="/images/vm/memory_manage.jpg" alt="iOS虚拟内存管理"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.794Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:53.482Z" title="4/30/2022, 3:44:53 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">28 分钟读完 (大约4166个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-iOS_VMManage/">iOS虚拟内存管理</a></h1><div class="content"><p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p>
<h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p>
<p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p>
<p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p>
<p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-01-22-iOS_VMManage/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-10-23-what-is-event-modeling/"><img class="fill" src="/images/img/hero.jpg" alt="What is Event Modeling?"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.167Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.168Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">27 分钟读完 (大约4029个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-10-23-what-is-event-modeling/">What is Event Modeling?</a></h1><div class="content"><p>Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the clearest communication of the system’s workings to the largest possible cross-section of roles in an organization. The system can be checked for completeness by following the single thread of data propagation through it.</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Moore’s-Law"><a href="#Moore’s-Law" class="headerlink" title="Moore’s Law"></a>Moore’s Law</h3><p>Digitized Information Systems are a relatively new concept. Humans have been working with information systems for thousands of years. Over centuries banks, insurance companies and many other large scale organizations have managed to succeed.</p>
<p>With the advent of the transistor, the speed and accuracy of processing information increased by orders of magnitude. What did not gain the same quantum leap is digital storage. This imbalance caused information systems to be optimized for a very small amount of online information. You can see this in the advent of RDBMS technology. What it mean is that the compromise was to throw information away.</p>
<h3 id="Human-Memory"><a href="#Human-Memory" class="headerlink" title="Human Memory"></a>Human Memory</h3><p>Story telling is something that enables humans to pass knowledge on to subsequent generations and relies heavily on how we store memories - whether logical, visual, auditory or other. This is important because there is a parallel with how information systems were constructed. There is a “memory” of all your visits to the doctor. It’s the ledger of the forms that are filled in with each visit.</p>
<p>Specifications by example are a way to show how something is supposed to work. This can be seen in successful practices in software such as Behaviour Driven Development. This works well because we communicate by stories more effectively. It ties back to story telling as a way to keep information in society. Our brains are built for it more than they are built for flow-charts and other formats. </p>
<h2 id="Life-After-the-Dawn-of-the-Computer-Age"><a href="#Life-After-the-Dawn-of-the-Computer-Age" class="headerlink" title="Life After the Dawn of the Computer Age"></a>Life After the Dawn of the Computer Age</h2><p>In recent decades, Moore’s Law from the side of online storage has caught up. This means that after the initial few decades of living with computer systems, our information systems that are now digitized can use the mechanics that made them effective throughout history.</p>
<p>This means we have enough storage to not throw away information. The ability to be able to keep a history of all that has happened allows systems to be more reliable by means of audit and specification by example that literally translates to how the system is implemented.</p>
<p>We also have enough storage to have a cache of different views into what has happened in the system. This is important as we now have made the task of trying to fit all our concerns into one model an unnecessary constraint. In 1956, an IBM harddrive that stored 10MB cost $1M and required $30K monthly budget.</p>
<h3 id="Reality-of-Current-Tooling"><a href="#Reality-of-Current-Tooling" class="headerlink" title="Reality of Current Tooling"></a>Reality of Current Tooling</h3><p>So we are now at a cross-roads where we have very mature tooling, but that tooling is made for solving a problem we no longer have - being efficient with storage constraints. The new tooling that we see on the rise is what information systems always had: a ledger of what happened - storage is not a major issue anymore. There are many benefits to keeping ledger. They represent the natural way we think about systems - digital or not.</p>
<h2 id="The-Model-That-Works"><a href="#The-Model-That-Works" class="headerlink" title="The Model That Works"></a>The Model That Works</h2><p><img src="/images/event-modeling/blueprint_large.jpg" alt="blueprint"></p>
<p>Time is a concept that is now a core piece of describing a system. The components and classes that we saw in computing are not as important. We can show, by example, what a system is supposed to do from start to finish, on a time line and with no branching - again to make use of that memory aspect of our brains. This is the Event Model. It is used to follow all field values in the UI to the storage of those value to where they finally end up on a report or a screen. It’s generally done with sticky notes on a wall or whiteboard - or an online version of a whiteboard. We’ll see that simplicity is at the heart of the approach as we will only use 3 types of building blocks as well as traditional wireframes or mockups. Further to keep things simple, we will rely on only 4 patterns of how we structure the diagram.</p>
<h3 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h3><p>When we want to adopt certain practices or processes to help one another understand and communicate, it is inversely proportional to the amount of learning individuals must do to be proficient in those methods. Put in another way, if an organization chooses to adopt a process called “X”, and X requires one book and a workshop that takes a week to go through, it nullifies the effectiveness of X, and here’s the worst part, <strong>no matter how good X is</strong>.</p>
<p>When the book is a required reading by the people in an organization, everyone will say they have read it; only half will have actually read it; half of those will claim they understood it; and only half of those will have understood it; and half of those will be able to apply it.</p>
<p>This is why Event Modeling only uses 3 moving pieces and 4 patterns based on 2 ideas. It takes a few minutes to explain and the rest of the learning is done in practice, transparently where any deficiencies in the understanding of even those few core ideas are quickly corrected.</p>
<p>This is how you get to an understanding in an organization.</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Let’s say we want to design a hotel website for a hotel chain for allowing our customers to book rooms online and for us to schedule cleaning and any other hotel concerns. We can show what events, or facts, are stored on a timeline of the year in that business. We can pretend we have the system already and ask ourselves what facts were stored as we move forward through time.</p>
<h3 id="Wireframes"><a href="#Wireframes" class="headerlink" title="Wireframes"></a>Wireframes</h3><p>To bring in the visual part of story-telling we show wireframes or web page mockups across the top. These can be organized in swim-lanes to show different people (or sometimes systems) interacting with our system. We also show any automation here with a symbol like gears to illustrate that the system is doing something. This has an easy to understand set of mechanics of a todo list that a process goes and does and marks items as done. In our hotel example, this could be a payment system or notification system.</p>
<p><img src="/images/event-modeling/innovate_large.jpg" alt="innovation"></p>
<p>At this point we have enough to be able to design some systems with some UX&#x2F;UI people. But there are 2 very fundamental pieces that must be added to the blueprint which show 2 core features of any information system: Empowering the user and informing the user.</p>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p>Most information systems must give an ability for a user to affect state of the system. In our example, we must allow the booking of a room to change the system so that we don’t over-book and when that person arrives at that future date, they have a room ready for them.</p>
<p>Intentions to change the system are encapsulated in a command. As opposed to simply saving form data to a table in a database, this allows us to have a non-technical way to show the intentions while allowing any implementation - although certain ones have advantages as we will see.</p>
<p><img src="/images/event-modeling/empower_large.jpg" alt="empower"></p>
<p>From the UI and UX perspective this drives a “command based UI” which goes a long way into helping make composable UIs. With this pattern, it’s a lot clearer what the transactional boundaries are both from the technical and business perspectives. The hotel guest either registered successfully or not.</p>
<p>When there are nuances to what the prerequisites are for having a command succeed, they are elaborated on “Given-When-Then” style specifications. This is, again, a way to tell a story of what success looks like. There may be a few of these stories to show how a command can and cannot succeed.</p>
<p>An example might be “<strong>Given</strong>: We have registered, and added a payment method, <strong>When</strong>: We try to book a room, <strong>Then</strong>: a room is booked.” This form of specification is also referred to as “Arrange, Act, Assert” and in the UX&#x2F;UI world “Situation, Motivation, Value”.</p>
<h3 id="Views-or-Read-Models"><a href="#Views-or-Read-Models" class="headerlink" title="Views (or Read Models)"></a>Views (or Read Models)</h3><p>The second part of any information system is the ability to inform the user about the state of the system. Our hotel guest should know about what days are available for certain types of rooms they are interested in staying in. There are usually many of these and support the multi-model aspect of information systems.</p>
<p><img src="/images/event-modeling/inform_large.jpg" alt="inform"></p>
<p>A view into the facts already in the system has been changing as these new events were being stored. In our hotel system, this calendar view was being updated as new events that affected inventory were happening. Other views may be for the cleaning staff to see which rooms are ready to be cleaned as events about guests checking out are being stored.</p>
<p>Specifying how a view behaves is very similar to the way we specify how we accept commands with one difference. The views are passive and cannot reject an event after it’s been stored in the system. We have “<strong>Given</strong>: hotel is set up with 12 ocean view rooms, ocean view room was booked from April 4th - 12th X 12, <strong>Then</strong>: the calendar should show all dates except April 4th - 12th for ocean view availability”.</p>
<h3 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h3><p>We just covered the first 2 patterns of the 4 that are needed to describe most systems. Systems can get information from other systems and send information to other systems. It would be tempting to force these 2 patterns to be an extension of the first 2 and share the same space. However, these interactions are harder to communicate as they don’t have that human-visible aspect to them and require some higher level patterns.</p>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>When we have an external system that’s providing us with information, it’s helpful to translate that information into a form that is more familiar in our own system. In our hotel system, we may get events from guests’ GPS coordinates if they opted in to our highly reactive cleaning crew. We would not want to use longitude and latitude pairs as events to specify preconditions in our system. We would rather have events that mean something to us like “Guest left hotel”, “Guest returned to hotel room”.</p>
<p><img src="/images/event-modeling/understand_large.jpg" alt="understand"></p>
<p>Often, translations are simple enough to represent as views that get their information from external events. If we don’t use them as any “Given” parts of tests, the values they store in that view model are simply represented in the command parameters in our state change tests.</p>
<h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h3><p>Our system is going to need to communicate with external services. When the guests in our hotel are paying for their stay when they check out, our system makes a call to a payment processor. We can make the concept of how this occurs with the idea of a “todo list” for some processor in our system. This todo list shows tasks we need to complete. Our processor goes through that list from time to time (could be milliseconds or days) and sends out a command to the external system to process the payment, as an example. The reply from the external system is then translated into an event that we store back in our system. This way we keep the building blocks that we use in our system as something that’s meaningful to us.</p>
<p><img src="/images/event-modeling/automate_large.jpg" alt="automate"></p>
<p>We show this by putting a processor in the top of our blueprint which has the wireframes. This shows that there are things not evident on the screen but are happening behind the scenes. A user may expect a spinning icon to indicate a delay due to background tasks needing to finish. The specification for this has the form of “<strong>Given</strong>: A view of the tasks to do, <strong>When</strong> This command is launched for each item, <strong>Then</strong> These events are expected back.”</p>
<p>In reality, these may be implemented in many different ways such as queues, reactive or real-time constructs. They may even actually be manual todo lists that our employees use. The goal here is to communicate how our system communicates with the outside world when it needs to affect it. </p>
<h2 id="Workshop-Format-The-7-Steps"><a href="#Workshop-Format-The-7-Steps" class="headerlink" title="Workshop Format - The 7 Steps"></a>Workshop Format - The 7 Steps</h2><p>Event Modeling is done in 7 steps. We explained the end-goal already. So let’s rewind to the beginning and show how to build up to the blueprint:</p>
<h3 id="1-Brain-Storming"><a href="#1-Brain-Storming" class="headerlink" title="1. Brain Storming"></a>1. Brain Storming</h3><p><img src="/images/event-modeling/Step-1_large.jpg" alt="Step 1"></p>
<p>We have someone explain the goals of the project and other information. The participants then envision what system would look and behave like. They put down all the events that they can conceive of having happened. Here we gently introduce the concept that only state-changing events are to be specified. Often, people will name “guest viewed calendar for room availability”. We put those aside for now - they are not events.</p>
<h3 id="2-The-Plot"><a href="#2-The-Plot" class="headerlink" title="2. The Plot"></a>2. The Plot</h3><p><img src="/images/event-modeling/Step-2_large.jpg" alt="Step 2"></p>
<p>Now the task is to create a plausible story made of these events. So they are arranged in a line and everyone reviews this time line to understand that this makes sense as events that happen in order.</p>
<h3 id="3-The-Story-Board"><a href="#3-The-Story-Board" class="headerlink" title="3. The Story Board"></a>3. The Story Board</h3><p><img src="/images/event-modeling/Step-3_large.jpg" alt="Step 3"></p>
<p>Next, the wireframes or mockups of the story are needed to address those that are visual learners. More importantly, each field must be represented so that the blueprint for the system has the source of and destination of the information represented from the user’s perspective.</p>
<h4 id="3-1-UX-Concurrency"><a href="#3-1-UX-Concurrency" class="headerlink" title="3.1 UX Concurrency"></a>3.1 UX Concurrency</h4><p>The wireframes are generally put at the top of the blueprint. They can be divided into separate swimlanes to show what each user sees if there is more than one. There are no screens that appear above one another as we need to capture each change in the system state as a separate vertical slice of the blueprint. The different ordering can be shown in the various specifications. If it is core to the system or very important to communicate, alternate workflows will need to be added to the blueprint. This is part of the last step that shows organization but can be done earlier if helpful.</p>
<h3 id="4-Identify-Inputs"><a href="#4-Identify-Inputs" class="headerlink" title="4. Identify Inputs"></a>4. Identify Inputs</h3><p><img src="/images/event-modeling/Step-4_large.jpg" alt="Step 4"></p>
<p>From the earlier section we saw that we need to show how we enable the user to change the state of the system. This is usually the step in which we do this introduction of these blue boxes. Each time an event is stored due to a users action, we link that to the UI by a command that shows what we are getting from the screen or implicitly from client state if it’s a web application.</p>
<h3 id="5-Identify-Outputs"><a href="#5-Identify-Outputs" class="headerlink" title="5. Identify Outputs"></a>5. Identify Outputs</h3><p><img src="/images/event-modeling/Step-5_large.jpg" alt="Step 5"></p>
<p>Again looking back at our goals for the blueprint, we now have to link information accumulated by storing events back into the UI via views (aka read-models). These may be things like the calendar view in our hotel system that will show the availability of rooms when a user is looking to book a room. </p>
<h3 id="6-Apply-Conway’s-Law"><a href="#6-Apply-Conway’s-Law" class="headerlink" title="6. Apply Conway’s Law"></a>6. Apply Conway’s Law</h3><p><img src="/images/event-modeling/Step-6_large.jpg" alt="Step 6"></p>
<p>Now that we know how information gets in and out of our system, we can start to look at organizing the events themselves into swimlanes. We need to do this to allow the system to exist as a set of autonomous parts that separate teams can own. This allows specialization to happen to a level that we control instead of falling out of the composition of teams. See <a target="_blank" rel="noopener" href="http://melconway.com/Home/Conways_Law.html">Conway’s Law</a> by Mel Conway.</p>
<h3 id="7-Elaborate-Scenarios"><a href="#7-Elaborate-Scenarios" class="headerlink" title="7. Elaborate Scenarios"></a>7. Elaborate Scenarios</h3><p>Each workflow step is tied to either a command or a view&#x2F;read-model. The specifications were explained earlier on. How we make them is still collaboratively with all participants in the same space. A Give-When-Then or Given-Then can be constructed one after the other very rapidly while being reviewed by multiple role representatives. This allows what is traditionally done as user story writing by a dedicated product owner in isolation in a text format, to be done visually in a very small amount of time collaboratively. What’s very critical here, is that each specification is tied to exactly one command or view.</p>
<h3 id="Completeness-Check"><a href="#Completeness-Check" class="headerlink" title="Completeness Check"></a>Completeness Check</h3><p>At this time the event model should have every field accounted for. All information has to have an origin and a destination. Events must facilitate this transition and hold the necessary fields to do so. This rigor is what is required to get the most benefits of the technique.</p>
<p>A variation of this is where we don’t do this final check and rely on absorbing the rework costs. There are scenarios where this is desired.</p>
<h2 id="Project-Management"><a href="#Project-Management" class="headerlink" title="Project Management"></a>Project Management</h2><p>The final output of the exercise if done to completion is a set of very small projects defined by all the scenarios for each workflow step. They are in a format that allows them to be directly translated to what developers will use to make their unit tests. They are also coupled to the adjacent workflow steps by only the contract.</p>
<p><img src="/images/event-modeling/parallel_large.jpg" alt="parallel effort"></p>
<h3 id="Strong-Contracts"><a href="#Strong-Contracts" class="headerlink" title="Strong Contracts"></a>Strong Contracts</h3><p>Many project management, business and coordination issues are mitigated by the fact that we have made explicit contracts as to the shape of the information of when we start a particular step of the workflow and what is the shape of the data when it’s finished. These pre- and post-conditions are what allows the work to be completed in relative isolation and later snap together with the adjoining steps as designed.</p>
<h4 id="Flat-Cost-Curve"><a href="#Flat-Cost-Curve" class="headerlink" title="Flat Cost Curve"></a>Flat Cost Curve</h4><p>The biggest impact of using Event Modeling is the flat cost curve of the average feature cost. This is due to the fact that the effort of building each workflow step is not impacted by the development of other workflows. One important thing to understand, is that a workflow step is considered to be repeated on the event model if it uses the same command or view. </p>
<p><img src="/images/event-modeling/flat-cost-curve.jpg" alt="flat cost curve"></p>
<p>The impact of this is very far reaching because it is what changes software development back into an engineering practice. It’s what makes creating an information system work like the construction of a house. Features can be created in any order. Traditional development cannot rely on estimates because whether the feature gets developed early on versus later in the project impacts the amount of work required. Reprioritizing work makes any previous estimates unreliable.</p>
<h4 id="Done-is-Done-Done-Right"><a href="#Done-is-Done-Done-Right" class="headerlink" title="Done is Done Done Right"></a>Done is Done Done Right</h4><p>When a workflow step is implemented, the act of implementing any other workflow step does not cause the need to revisit this already complete workflow step. It’s the reason that the constant feature cost curve can be realized.</p>
<h4 id="Estimates-without-Estimating"><a href="#Estimates-without-Estimating" class="headerlink" title="Estimates without Estimating"></a>Estimates without Estimating</h4><p>With a constant cost curve, the effort for an organization to implement can simply be measured over many features over time. This is an impartial way to empirically determine the velocity of teams. These numbers are then used to scope, schedule and cost out future projects.</p>
<h5 id="Technical-Side-Note-About-Test-Driven-Development"><a href="#Technical-Side-Note-About-Test-Driven-Development" class="headerlink" title="Technical Side-Note About Test Driven Development"></a>Technical Side-Note About Test Driven Development</h5><p>This is the impact of the adoption of Agile practices in the industry to put band-aids over the core issue of lack of design. Because the scope of each set of requirements is now per workflow step, the refactoring step of TDD does not impact other workflow steps in the event model. When we don’t have an event model, refactoring goes unrestricted and previously completed pieces of work have to be adjusted. The more work is already completed, the more that has to be reviewed and adjusted with each new addition as we build the solution.</p>
<h4 id="Subcontracting"><a href="#Subcontracting" class="headerlink" title="Subcontracting"></a>Subcontracting</h4><p>The constant cost curve gives the opportunity to do fixed-cost projects. Once there is a velocity established for a team, you have the cost of the software for your organization. With this number, you now can price out what you are willing to give contractors in pay for each workflow step they complete.</p>
<h5 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h5><p>Since each workflow step is protected from being affected by other workflow steps, any deficiencies are to be guaranteed by who is delivering them with non-billable work. So in the case of a subcontractor doing a bad job just to get more billable items done quickly, they will have to have the next hours of work dedicated to fixing deficiencies of work already done before. This evens out their effective rate of pay because they are not working on new delivarables.</p>
<p>This can be carried out over longer periods within an employee engagement by making these metrics available through different checkpoints for performance.</p>
<p>Due to the effective pay self-adjusting to the capability of the individual, it is also a way to on-board new employees and pay them fairly while they are in the probation stage of the engagement. This contract-to-hire process removes the subjective and largely ineffective interview process for technical positions.</p>
<h4 id="Prioritization"><a href="#Prioritization" class="headerlink" title="Prioritization"></a>Prioritization</h4><p>Moving work on a schedule as to what steps are going to be implemented first is done without changing the estimated costs of each item. This ensures that prioritization of work has no impact in the total cost also. The constant cost curve is required to allow this “agility” of reprioritizing features.</p>
<h4 id="Change-Management"><a href="#Change-Management" class="headerlink" title="Change Management"></a>Change Management</h4><p>When the plans change, we simply adjust the event model. This is usually done by just copying the current one and adjusting. Now we can see where the differences are. If a new piece of information is added to one event, that constitutes a new version of the workflow that creates it. Same with the views. If these have not been implemented yet, they don’t change our estimate. If they are already implemented, they add another unit of work to our plan because it’s considered a replacement. There are a few more rules around this. The end result is a definitive guide for change management.</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p><img src="/images/event-modeling/arrows_large.jpg" alt="security arrows"></p>
<p>With an event model, the solution shows exactly where, and equally importantly, when sensitive data crosses boundaries. With traditional audits, the number of interviews with staff was time consuming and at risk of missing important areas. Security concerns are addressed most responsibly when the applications have an event model to reference.</p>
<h2 id="Legacy-Systems"><a href="#Legacy-Systems" class="headerlink" title="Legacy Systems"></a>Legacy Systems</h2><p>Most of the scenarios that real organizations face is where a system is already in place. The main way to deal with a system that is hard to manage because of complexity and lack of understanding is to either rewrite it or to refactor it while it runs. Both of these are very costly.</p>
<p>A third, less risky option exists: Freeze the old system. With proper buy-in, the organization can agree to not alter the existing system. Instead, dealing with bugs and adding new functionality is done on the side as a side-car solution.</p>
<p>Events can be gathered from the database of the old system and make views of that state - employing the <a href="#translation">translate</a> pattern described previously. Y-valve redirection of user action can add new functionality in the side solution. An example which fixes a bug (notice that we use the <a href="./#automation">external integration pattern</a> and extends the old system to add profile pictures is shown here:</p>
<p><img src="/images/event-modeling/event-modeling-legacy-side-car.jpg" alt="legacy side car event model"></p>
<p>This pattern allows an organization to stop putting energy into the sub-optimal existing system and get unblocked from delivering value via the patterns that enable the benefits of the Event Model.</p>
<h2 id="Conclusion-for-Now"><a href="#Conclusion-for-Now" class="headerlink" title="Conclusion for Now"></a>Conclusion for Now</h2><p>Event Modeling is changing how information systems are built. With simple repeatable patterns, information systems are as predicable as engineering efforts should be.</p>
<h2 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h2><p>This content reprinted from <a target="_blank" rel="noopener" href="https://eventmodeling.org/posts/what-is-event-modeling/">Event Modeling: What is it?</a></p>
<p>Thanks.</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/9/cover.png" alt="\#9\ 一般树与树节点遍历"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1775个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/">\#9\ 一般树与树节点遍历</a></h1><div class="content"><p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p>
<ul>
<li>等级关系的描述</li>
<li>分类数据的管理</li>
<li>分类查找操作</li>
</ul>
<p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>类似链表，树也是由节点构成的。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/node.png"></p>
<p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p>
<h3 id="父节点和子节点"><a href="#父节点和子节点" class="headerlink" title="父节点和子节点"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p>
<p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png"></p>
<h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/root.png"></p>
<h3 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png"></p>
<h2 id="Swift树结构实现"><a href="#Swift树结构实现" class="headerlink" title="Swift树结构实现"></a>Swift树结构实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">TreeNode</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p>
<p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节点添加新的子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">child</span>: <span class="type">TreeNode</span>) &#123;</span><br><span class="line">    children.append(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time to give it a whirl.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Create a tree&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> beverages <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    beverages.add(hot)</span><br><span class="line">    beverages.add(cold)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(beverages.value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">0</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">1</span>].value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Create a tree---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">Hot</span></span><br><span class="line"><span class="comment">Cold</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png"></p>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png"></p>
<p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png"></p>
<p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachDepthFirst</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.forEachDepthFirst(visit: visit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeBeverageTree</span>() -&gt; <span class="type">TreeNode</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> coffee <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chocolate <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> blackTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> greenTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chaiTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> soda <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;sida&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> milk <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> gingerAle <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bitterLemon <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    </span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    </span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    </span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    </span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该树的形态如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png"></p>
<p>接下来在这棵树上测试深度优先遍历。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;depth-first traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of depth-first traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachLevelOrder</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&gt;()</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            queue.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst() &#123;</span><br><span class="line">            visit(node)</span><br><span class="line">            node.children.forEach &#123;</span><br><span class="line">                queue.append(<span class="variable">$0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;level-order traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachLevelOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of level-order traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">search</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">TreeNode</span>?</span><br><span class="line">        forEachLevelOrder &#123; node <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">                result <span class="operator">=</span> node</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;searching for a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult1 <span class="operator">=</span> tree.search(<span class="string">&quot;ginger ale&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found node: <span class="subst">\(searchResult1.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult2 <span class="operator">=</span> tree.search(<span class="string">&quot;WKD Blue&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(searchResult2.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of searching for a node---</span></span><br><span class="line"><span class="comment">Found node: ginger ale</span></span><br><span class="line"><span class="comment">Couldn&#x27;t find WKD Blue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li>
<li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li>
<li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li>
</ul>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png"></p>
<p>打印的结果应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 </span><br><span class="line">1 17 20 </span><br><span class="line">1 5 0 2 5 7</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printEachLevel</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">tree</span>: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    queue.append(tree)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>queue.isEmpty &#123;</span><br><span class="line">        nodesLeftInCurrentLevel <span class="operator">=</span> queue.count</span><br><span class="line">        <span class="keyword">while</span> nodesLeftInCurrentLevel <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst()  <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(node.value)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">            node.children.forEach &#123; queue.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">            nodesLeftInCurrentLevel <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/13/cover.jpg" alt="\#13\ 字典树（Tries Tree）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">19 分钟读完 (大约2865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/">\#13\ 字典树（Tries Tree）</a></h1><div class="content"><p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>例如利用Tries表示一个英语单词，可以表示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png"></p>
<p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> words: [<span class="type">String</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">words</span>(<span class="params">matching</span> <span class="params">prefix</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> words.filter &#123; <span class="variable">$0</span>.hasPrefix(<span class="keyword">prefix</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p>
<p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p>
<p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p>
<p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png"></p>
<p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p>
<p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png"></p>
<p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png"></p>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p>
<h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Key</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> parent: <span class="type">TrieNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">Key</span>: <span class="type">TrieNode</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">key</span>: <span class="type">Key</span>?, <span class="params">parent</span>: <span class="type">TrieNode</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tries的节点结构和其他树型数据结构有明显的不同。</p>
<ul>
<li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li>
<li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li>
<li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li>
<li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li>
</ul>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&lt;<span class="title class_">CollectionType</span>: <span class="title class_">Collection</span>&gt; <span class="title class_">where</span> <span class="title class_">CollectionType</span>.<span class="title class_">Element</span>: <span class="title class_">Hashable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> <span class="operator">=</span> <span class="type">TrieNode</span>&lt;<span class="type">CollectionType</span>.<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> root <span class="operator">=</span> <span class="type">Node</span>(key: <span class="literal">nil</span>, parent: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p>
<p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p>
<h2 id="操作算法实现"><a href="#操作算法实现" class="headerlink" title="操作算法实现"></a>操作算法实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[element] <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[element] <span class="operator">=</span> <span class="type">Node</span>(key: element, parent: current)</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> current.children[element]<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    current.isTerminating <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li>
<li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li>
<li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p>
<h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isTerminating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p>
<p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insert and contains&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> trie.contains(<span class="string">&quot;cute&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cute is in the trie&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insert and contains---</span></span><br><span class="line"><span class="comment">cute is in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> current.isTerminating <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent <span class="operator">=</span> current.parent, current.children.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>current.isTerminating &#123;</span><br><span class="line">            parent.children[current.key<span class="operator">!</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            current <span class="operator">=</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li>
<li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li>
<li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** Before removeing ***&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cut<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** After removing cut ***&quot;</span>)</span><br><span class="line">    trie.remove(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is still in the trie&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of remove---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Before removeing ***</span></span><br><span class="line"><span class="comment">&quot;cut&quot; is in the trie</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is in the trie</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** After removing cut ***</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is still in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Prefix-matching"><a href="#Prefix-matching" class="headerlink" title="Prefix matching"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> <span class="title class_">where</span> <span class="title class_">CollectionType</span>: <span class="title class_">RangeReplaceableCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">prefix</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> collections(startingWith: <span class="keyword">prefix</span>, after: current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li>
<li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">CollectionType</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.isTerminating &#123;</span><br><span class="line">        results.append(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children.values &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">        <span class="keyword">prefix</span>.append(child.key<span class="operator">!</span>)</span><br><span class="line">        results.append(contentsOf: collections(startingWith: <span class="keyword">prefix</span>, after: child))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li>
<li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li>
</ul>
<p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p>
<p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;prefix matching&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;car&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;card&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;care&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cared&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cars&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carbs&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carapace&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cargo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>car<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCar <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;car&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCar)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>care<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCare <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;care&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of prefix matching---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;car&quot;</span></span><br><span class="line"><span class="comment">[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;care&quot;</span></span><br><span class="line"><span class="comment">[&quot;care&quot;, &quot;cared&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>Trie树在前缀匹配上有着卓越的性能表现；</li>
<li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Logs/"><span class="level-start"><span class="level-item">Logs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>