<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.799Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:17.541Z" title="4/30/2022, 3:45:17 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">16 分钟读完 (大约2350个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-08-02-novelty-detection/">异常点检测算法小结</a></h1><div class="content"><p>异常点检测，有时也叫离群点检测，英文一般叫做Novelty Detection或者Outlier Detection,是比较常见的一类非监督学习算法，这里就对异常点检测算法做一个总结。</p>
<h2 id="异常点检测算法使用场景"><a href="#异常点检测算法使用场景" class="headerlink" title="异常点检测算法使用场景"></a>异常点检测算法使用场景</h2><p>什么时候我们需要异常点检测算法呢？常见的有三种情况。</p>
<ol>
<li>在做特征工程的时候需要对异常的数据做过滤，防止对归一化等处理的结果产生影响。</li>
<li>对没有标记输出的特征数据做筛选，找出异常的数据。</li>
<li>对有标记输出的特征数据做二分类时，由于某些类别的训练样本非常少，类别严重不平衡，此时也可以考虑用非监督的异常点检测算法来做。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2018-08-02-novelty-detection/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-23-transition/"><img class="fill" src="/images/transition/cover.jpg" alt="如何完成技术跃迁"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.798Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:13.181Z" title="4/30/2022, 3:45:13 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">1 小时读完 (大约10762个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-23-transition/">如何完成技术跃迁</a></h1><div class="content"><p>前言：近期又到了毕业招聘季，我作为技术分享嘉宾，回到母校参加宣讲会，做了一个主题为《如何在毕业三年完成技术跃迁》的分享，本文由此次分享整理而成，并改名为《如何完成技术跃迁》，希望能够给刚进入职场的程序员，或者卡在瓶颈期的程序员，带来一些指导，在技术的道路上少走些弯路。请注意，本文源于我的经验思考，非教条或准则，仅供参考。另由于本人主要的项目经验来源于App端（主要是iOS、Android），Web前端及后端只是稍有涉猎，因此文中的例子大多也来自App端，其他端同学可能会觉得陌生，但应该不会影响理解。</p>
<p>本文约1W字，阅读时长大概二十分钟，稍有啰嗦，请见谅。 </p>
<h1 id="1-什么是技术跃迁"><a href="#1-什么是技术跃迁" class="headerlink" title="1. 什么是技术跃迁"></a>1. 什么是技术跃迁</h1><p>首先，我们需要明确一个定义，什么是技术跃迁？在说技术跃迁之前，跟大家解释下跃迁这个词。</p>
<p>”跃迁“，来源于量子力学，说的是微观状态发生跳跃式变化的过程，比如从低能态跳跃到高能态，需要注意的是：因为微观粒子的状态是分立的，也即是非连续性的，所以这个变化是跳跃性的。用这个词来说明技术的成长，个人认为是非常合适的。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-03-23-transition/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.796Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:05.377Z" title="4/30/2022, 3:45:05 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">1 小时读完 (大约11266个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/">机器学习基础介绍</a></h1><div class="content"><p><strong>机器学习是一门从数据中提取知识的技术。</strong> 它是统计学、人工智能和计算机科学的交叉研究领域，被常被称为<strong>预测分析</strong>、<strong>统计学习</strong>。机器学习方法的应用近年来在日常生活中无处不在。从自动推荐看哪部电影、点什么食物或买什么东西，到个性化的在线收音机、智能化在线教育，再到从照片中找到你的朋友等等需要现代网站和设备的核心都是机器学习算法。当你查看例如Facebook、Amazon、Netflix、Weibo、Twitter等复杂网站时，很可能网站的每个部分都包含了多个机器学习模型。</p>
<p>除了商业应用之外，机器学习已经对数据驱动的研究方式产生了巨大的影响。机器学习相关的技术、工具已经应用于各种科学问题，例如理解恒星、发现遥远的行星、发现新的粒子、分析DNA序列以及提供个性化的癌症治疗等。</p>
<p>但是，为了从机器学习中获益，你的应用程序可能并不需要大规模。在本部分，将解释为什么机器学习变的如此的流行，并讨论使用机器学习可以解决哪些问题。然后，将展示如何构建你的第一个机器学习模型等。</p>
<h2 id="为什么是机器学习？"><a href="#为什么是机器学习？" class="headerlink" title="为什么是机器学习？"></a>为什么是机器学习？</h2><p>较早期的“智能”应用程序，许多的系统使用“if”和“else”硬编码规则来处理数据或者根据用户的输入进行调整。想象一个垃圾邮件过滤器，其工作是适当的移动电子邮件到垃圾邮件文件夹。你可以构造一个垃圾邮件词库黑名单，并返回垃圾邮件标记 <em>1</em>。这是一个使用专家设计的规则来实现“智能”应用程序的例子。手工创建决策规则对于一些应用程序是可行的，特别是那些人类对建模过程有很好理解的应用程序，然而，使用手工编码的规则进行决策有两点主要缺点：</p>
<ul>
<li>做出决策所需的规则逻辑是针对特定的单个域和任务的，一些业务改变，整个系统可能都需要重写；</li>
<li>设计规则需要深刻理解人类专家应该如何做出决定。</li>
</ul></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2018-09-20-Introduction_Of_Machine_Learning/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-08-iOS_Tips/"><img class="fill" src="/images/ios-jq/logo.jpeg" alt="iOS开发隐藏技能如何开启"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.795Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:58.501Z" title="4/30/2022, 3:44:58 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">8 分钟读完 (大约1230个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-08-iOS_Tips/">iOS开发隐藏技能如何开启</a></h1><div class="content"><p>在iOS的开发过程中，我们经常会遇到一些需要关心但是无法直接得到的信息，本文记录了一些能够开启IDE隐藏功能的方法，帮助开发者了解更多的信息等。</p>
<h2 id="1-在-Xcode-中追踪构建时间"><a href="#1-在-Xcode-中追踪构建时间" class="headerlink" title="1. 在 Xcode 中追踪构建时间"></a>1. 在 Xcode 中追踪构建时间</h2><p>在使用Xcode进行项目的编译和打包的时候，总是耗时的，而这个时间Xcode本身是具有统计功能的。如果需要查看此时间，需要开启Xcode的<code>ShowBuildOperationDuration</code>选项，打开命令行工具，直接输入如下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES</span><br></pre></td></tr></table></figure>

<p>开启后，Xcode的构建完成后，会在Xcode的状态栏显示本次构建的耗时。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-03-08-iOS_Tips/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-iOS_VMManage/"><img class="fill" src="/images/vm/memory_manage.jpg" alt="iOS虚拟内存管理"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.794Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:53.482Z" title="4/30/2022, 3:44:53 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">28 分钟读完 (大约4166个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-iOS_VMManage/">iOS虚拟内存管理</a></h1><div class="content"><p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p>
<h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p>
<p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p>
<p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p>
<p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-01-22-iOS_VMManage/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-10-23-what-is-event-modeling/"><img class="fill" src="/images/img/hero.jpg" alt="What is Event Modeling?"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.167Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.168Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">27 分钟读完 (大约4029个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-10-23-what-is-event-modeling/">What is Event Modeling?</a></h1><div class="content"><p>Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the clearest communication of the system’s workings to the largest possible cross-section of roles in an organization. The system can be checked for completeness by following the single thread of data propagation through it.</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Moore’s-Law"><a href="#Moore’s-Law" class="headerlink" title="Moore’s Law"></a>Moore’s Law</h3><p>Digitized Information Systems are a relatively new concept. Humans have been working with information systems for thousands of years. Over centuries banks, insurance companies and many other large scale organizations have managed to succeed.</p>
<p>With the advent of the transistor, the speed and accuracy of processing information increased by orders of magnitude. What did not gain the same quantum leap is digital storage. This imbalance caused information systems to be optimized for a very small amount of online information. You can see this in the advent of RDBMS technology. What it mean is that the compromise was to throw information away.</p>
<h3 id="Human-Memory"><a href="#Human-Memory" class="headerlink" title="Human Memory"></a>Human Memory</h3><p>Story telling is something that enables humans to pass knowledge on to subsequent generations and relies heavily on how we store memories - whether logical, visual, auditory or other. This is important because there is a parallel with how information systems were constructed. There is a “memory” of all your visits to the doctor. It’s the ledger of the forms that are filled in with each visit.</p>
<p>Specifications by example are a way to show how something is supposed to work. This can be seen in successful practices in software such as Behaviour Driven Development. This works well because we communicate by stories more effectively. It ties back to story telling as a way to keep information in society. Our brains are built for it more than they are built for flow-charts and other formats. </p>
<h2 id="Life-After-the-Dawn-of-the-Computer-Age"><a href="#Life-After-the-Dawn-of-the-Computer-Age" class="headerlink" title="Life After the Dawn of the Computer Age"></a>Life After the Dawn of the Computer Age</h2><p>In recent decades, Moore’s Law from the side of online storage has caught up. This means that after the initial few decades of living with computer systems, our information systems that are now digitized can use the mechanics that made them effective throughout history.</p>
<p>This means we have enough storage to not throw away information. The ability to be able to keep a history of all that has happened allows systems to be more reliable by means of audit and specification by example that literally translates to how the system is implemented.</p>
<p>We also have enough storage to have a cache of different views into what has happened in the system. This is important as we now have made the task of trying to fit all our concerns into one model an unnecessary constraint. In 1956, an IBM harddrive that stored 10MB cost $1M and required $30K monthly budget.</p>
<h3 id="Reality-of-Current-Tooling"><a href="#Reality-of-Current-Tooling" class="headerlink" title="Reality of Current Tooling"></a>Reality of Current Tooling</h3><p>So we are now at a cross-roads where we have very mature tooling, but that tooling is made for solving a problem we no longer have - being efficient with storage constraints. The new tooling that we see on the rise is what information systems always had: a ledger of what happened - storage is not a major issue anymore. There are many benefits to keeping ledger. They represent the natural way we think about systems - digital or not.</p>
<h2 id="The-Model-That-Works"><a href="#The-Model-That-Works" class="headerlink" title="The Model That Works"></a>The Model That Works</h2><p><img src="/images/event-modeling/blueprint_large.jpg" alt="blueprint"></p>
<p>Time is a concept that is now a core piece of describing a system. The components and classes that we saw in computing are not as important. We can show, by example, what a system is supposed to do from start to finish, on a time line and with no branching - again to make use of that memory aspect of our brains. This is the Event Model. It is used to follow all field values in the UI to the storage of those value to where they finally end up on a report or a screen. It’s generally done with sticky notes on a wall or whiteboard - or an online version of a whiteboard. We’ll see that simplicity is at the heart of the approach as we will only use 3 types of building blocks as well as traditional wireframes or mockups. Further to keep things simple, we will rely on only 4 patterns of how we structure the diagram.</p>
<h3 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h3><p>When we want to adopt certain practices or processes to help one another understand and communicate, it is inversely proportional to the amount of learning individuals must do to be proficient in those methods. Put in another way, if an organization chooses to adopt a process called “X”, and X requires one book and a workshop that takes a week to go through, it nullifies the effectiveness of X, and here’s the worst part, <strong>no matter how good X is</strong>.</p>
<p>When the book is a required reading by the people in an organization, everyone will say they have read it; only half will have actually read it; half of those will claim they understood it; and only half of those will have understood it; and half of those will be able to apply it.</p>
<p>This is why Event Modeling only uses 3 moving pieces and 4 patterns based on 2 ideas. It takes a few minutes to explain and the rest of the learning is done in practice, transparently where any deficiencies in the understanding of even those few core ideas are quickly corrected.</p>
<p>This is how you get to an understanding in an organization.</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Let’s say we want to design a hotel website for a hotel chain for allowing our customers to book rooms online and for us to schedule cleaning and any other hotel concerns. We can show what events, or facts, are stored on a timeline of the year in that business. We can pretend we have the system already and ask ourselves what facts were stored as we move forward through time.</p>
<h3 id="Wireframes"><a href="#Wireframes" class="headerlink" title="Wireframes"></a>Wireframes</h3><p>To bring in the visual part of story-telling we show wireframes or web page mockups across the top. These can be organized in swim-lanes to show different people (or sometimes systems) interacting with our system. We also show any automation here with a symbol like gears to illustrate that the system is doing something. This has an easy to understand set of mechanics of a todo list that a process goes and does and marks items as done. In our hotel example, this could be a payment system or notification system.</p>
<p><img src="/images/event-modeling/innovate_large.jpg" alt="innovation"></p>
<p>At this point we have enough to be able to design some systems with some UX&#x2F;UI people. But there are 2 very fundamental pieces that must be added to the blueprint which show 2 core features of any information system: Empowering the user and informing the user.</p>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p>Most information systems must give an ability for a user to affect state of the system. In our example, we must allow the booking of a room to change the system so that we don’t over-book and when that person arrives at that future date, they have a room ready for them.</p>
<p>Intentions to change the system are encapsulated in a command. As opposed to simply saving form data to a table in a database, this allows us to have a non-technical way to show the intentions while allowing any implementation - although certain ones have advantages as we will see.</p>
<p><img src="/images/event-modeling/empower_large.jpg" alt="empower"></p>
<p>From the UI and UX perspective this drives a “command based UI” which goes a long way into helping make composable UIs. With this pattern, it’s a lot clearer what the transactional boundaries are both from the technical and business perspectives. The hotel guest either registered successfully or not.</p>
<p>When there are nuances to what the prerequisites are for having a command succeed, they are elaborated on “Given-When-Then” style specifications. This is, again, a way to tell a story of what success looks like. There may be a few of these stories to show how a command can and cannot succeed.</p>
<p>An example might be “<strong>Given</strong>: We have registered, and added a payment method, <strong>When</strong>: We try to book a room, <strong>Then</strong>: a room is booked.” This form of specification is also referred to as “Arrange, Act, Assert” and in the UX&#x2F;UI world “Situation, Motivation, Value”.</p>
<h3 id="Views-or-Read-Models"><a href="#Views-or-Read-Models" class="headerlink" title="Views (or Read Models)"></a>Views (or Read Models)</h3><p>The second part of any information system is the ability to inform the user about the state of the system. Our hotel guest should know about what days are available for certain types of rooms they are interested in staying in. There are usually many of these and support the multi-model aspect of information systems.</p>
<p><img src="/images/event-modeling/inform_large.jpg" alt="inform"></p>
<p>A view into the facts already in the system has been changing as these new events were being stored. In our hotel system, this calendar view was being updated as new events that affected inventory were happening. Other views may be for the cleaning staff to see which rooms are ready to be cleaned as events about guests checking out are being stored.</p>
<p>Specifying how a view behaves is very similar to the way we specify how we accept commands with one difference. The views are passive and cannot reject an event after it’s been stored in the system. We have “<strong>Given</strong>: hotel is set up with 12 ocean view rooms, ocean view room was booked from April 4th - 12th X 12, <strong>Then</strong>: the calendar should show all dates except April 4th - 12th for ocean view availability”.</p>
<h3 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h3><p>We just covered the first 2 patterns of the 4 that are needed to describe most systems. Systems can get information from other systems and send information to other systems. It would be tempting to force these 2 patterns to be an extension of the first 2 and share the same space. However, these interactions are harder to communicate as they don’t have that human-visible aspect to them and require some higher level patterns.</p>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>When we have an external system that’s providing us with information, it’s helpful to translate that information into a form that is more familiar in our own system. In our hotel system, we may get events from guests’ GPS coordinates if they opted in to our highly reactive cleaning crew. We would not want to use longitude and latitude pairs as events to specify preconditions in our system. We would rather have events that mean something to us like “Guest left hotel”, “Guest returned to hotel room”.</p>
<p><img src="/images/event-modeling/understand_large.jpg" alt="understand"></p>
<p>Often, translations are simple enough to represent as views that get their information from external events. If we don’t use them as any “Given” parts of tests, the values they store in that view model are simply represented in the command parameters in our state change tests.</p>
<h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h3><p>Our system is going to need to communicate with external services. When the guests in our hotel are paying for their stay when they check out, our system makes a call to a payment processor. We can make the concept of how this occurs with the idea of a “todo list” for some processor in our system. This todo list shows tasks we need to complete. Our processor goes through that list from time to time (could be milliseconds or days) and sends out a command to the external system to process the payment, as an example. The reply from the external system is then translated into an event that we store back in our system. This way we keep the building blocks that we use in our system as something that’s meaningful to us.</p>
<p><img src="/images/event-modeling/automate_large.jpg" alt="automate"></p>
<p>We show this by putting a processor in the top of our blueprint which has the wireframes. This shows that there are things not evident on the screen but are happening behind the scenes. A user may expect a spinning icon to indicate a delay due to background tasks needing to finish. The specification for this has the form of “<strong>Given</strong>: A view of the tasks to do, <strong>When</strong> This command is launched for each item, <strong>Then</strong> These events are expected back.”</p>
<p>In reality, these may be implemented in many different ways such as queues, reactive or real-time constructs. They may even actually be manual todo lists that our employees use. The goal here is to communicate how our system communicates with the outside world when it needs to affect it. </p>
<h2 id="Workshop-Format-The-7-Steps"><a href="#Workshop-Format-The-7-Steps" class="headerlink" title="Workshop Format - The 7 Steps"></a>Workshop Format - The 7 Steps</h2><p>Event Modeling is done in 7 steps. We explained the end-goal already. So let’s rewind to the beginning and show how to build up to the blueprint:</p>
<h3 id="1-Brain-Storming"><a href="#1-Brain-Storming" class="headerlink" title="1. Brain Storming"></a>1. Brain Storming</h3><p><img src="/images/event-modeling/Step-1_large.jpg" alt="Step 1"></p>
<p>We have someone explain the goals of the project and other information. The participants then envision what system would look and behave like. They put down all the events that they can conceive of having happened. Here we gently introduce the concept that only state-changing events are to be specified. Often, people will name “guest viewed calendar for room availability”. We put those aside for now - they are not events.</p>
<h3 id="2-The-Plot"><a href="#2-The-Plot" class="headerlink" title="2. The Plot"></a>2. The Plot</h3><p><img src="/images/event-modeling/Step-2_large.jpg" alt="Step 2"></p>
<p>Now the task is to create a plausible story made of these events. So they are arranged in a line and everyone reviews this time line to understand that this makes sense as events that happen in order.</p>
<h3 id="3-The-Story-Board"><a href="#3-The-Story-Board" class="headerlink" title="3. The Story Board"></a>3. The Story Board</h3><p><img src="/images/event-modeling/Step-3_large.jpg" alt="Step 3"></p>
<p>Next, the wireframes or mockups of the story are needed to address those that are visual learners. More importantly, each field must be represented so that the blueprint for the system has the source of and destination of the information represented from the user’s perspective.</p>
<h4 id="3-1-UX-Concurrency"><a href="#3-1-UX-Concurrency" class="headerlink" title="3.1 UX Concurrency"></a>3.1 UX Concurrency</h4><p>The wireframes are generally put at the top of the blueprint. They can be divided into separate swimlanes to show what each user sees if there is more than one. There are no screens that appear above one another as we need to capture each change in the system state as a separate vertical slice of the blueprint. The different ordering can be shown in the various specifications. If it is core to the system or very important to communicate, alternate workflows will need to be added to the blueprint. This is part of the last step that shows organization but can be done earlier if helpful.</p>
<h3 id="4-Identify-Inputs"><a href="#4-Identify-Inputs" class="headerlink" title="4. Identify Inputs"></a>4. Identify Inputs</h3><p><img src="/images/event-modeling/Step-4_large.jpg" alt="Step 4"></p>
<p>From the earlier section we saw that we need to show how we enable the user to change the state of the system. This is usually the step in which we do this introduction of these blue boxes. Each time an event is stored due to a users action, we link that to the UI by a command that shows what we are getting from the screen or implicitly from client state if it’s a web application.</p>
<h3 id="5-Identify-Outputs"><a href="#5-Identify-Outputs" class="headerlink" title="5. Identify Outputs"></a>5. Identify Outputs</h3><p><img src="/images/event-modeling/Step-5_large.jpg" alt="Step 5"></p>
<p>Again looking back at our goals for the blueprint, we now have to link information accumulated by storing events back into the UI via views (aka read-models). These may be things like the calendar view in our hotel system that will show the availability of rooms when a user is looking to book a room. </p>
<h3 id="6-Apply-Conway’s-Law"><a href="#6-Apply-Conway’s-Law" class="headerlink" title="6. Apply Conway’s Law"></a>6. Apply Conway’s Law</h3><p><img src="/images/event-modeling/Step-6_large.jpg" alt="Step 6"></p>
<p>Now that we know how information gets in and out of our system, we can start to look at organizing the events themselves into swimlanes. We need to do this to allow the system to exist as a set of autonomous parts that separate teams can own. This allows specialization to happen to a level that we control instead of falling out of the composition of teams. See <a target="_blank" rel="noopener" href="http://melconway.com/Home/Conways_Law.html">Conway’s Law</a> by Mel Conway.</p>
<h3 id="7-Elaborate-Scenarios"><a href="#7-Elaborate-Scenarios" class="headerlink" title="7. Elaborate Scenarios"></a>7. Elaborate Scenarios</h3><p>Each workflow step is tied to either a command or a view&#x2F;read-model. The specifications were explained earlier on. How we make them is still collaboratively with all participants in the same space. A Give-When-Then or Given-Then can be constructed one after the other very rapidly while being reviewed by multiple role representatives. This allows what is traditionally done as user story writing by a dedicated product owner in isolation in a text format, to be done visually in a very small amount of time collaboratively. What’s very critical here, is that each specification is tied to exactly one command or view.</p>
<h3 id="Completeness-Check"><a href="#Completeness-Check" class="headerlink" title="Completeness Check"></a>Completeness Check</h3><p>At this time the event model should have every field accounted for. All information has to have an origin and a destination. Events must facilitate this transition and hold the necessary fields to do so. This rigor is what is required to get the most benefits of the technique.</p>
<p>A variation of this is where we don’t do this final check and rely on absorbing the rework costs. There are scenarios where this is desired.</p>
<h2 id="Project-Management"><a href="#Project-Management" class="headerlink" title="Project Management"></a>Project Management</h2><p>The final output of the exercise if done to completion is a set of very small projects defined by all the scenarios for each workflow step. They are in a format that allows them to be directly translated to what developers will use to make their unit tests. They are also coupled to the adjacent workflow steps by only the contract.</p>
<p><img src="/images/event-modeling/parallel_large.jpg" alt="parallel effort"></p>
<h3 id="Strong-Contracts"><a href="#Strong-Contracts" class="headerlink" title="Strong Contracts"></a>Strong Contracts</h3><p>Many project management, business and coordination issues are mitigated by the fact that we have made explicit contracts as to the shape of the information of when we start a particular step of the workflow and what is the shape of the data when it’s finished. These pre- and post-conditions are what allows the work to be completed in relative isolation and later snap together with the adjoining steps as designed.</p>
<h4 id="Flat-Cost-Curve"><a href="#Flat-Cost-Curve" class="headerlink" title="Flat Cost Curve"></a>Flat Cost Curve</h4><p>The biggest impact of using Event Modeling is the flat cost curve of the average feature cost. This is due to the fact that the effort of building each workflow step is not impacted by the development of other workflows. One important thing to understand, is that a workflow step is considered to be repeated on the event model if it uses the same command or view. </p>
<p><img src="/images/event-modeling/flat-cost-curve.jpg" alt="flat cost curve"></p>
<p>The impact of this is very far reaching because it is what changes software development back into an engineering practice. It’s what makes creating an information system work like the construction of a house. Features can be created in any order. Traditional development cannot rely on estimates because whether the feature gets developed early on versus later in the project impacts the amount of work required. Reprioritizing work makes any previous estimates unreliable.</p>
<h4 id="Done-is-Done-Done-Right"><a href="#Done-is-Done-Done-Right" class="headerlink" title="Done is Done Done Right"></a>Done is Done Done Right</h4><p>When a workflow step is implemented, the act of implementing any other workflow step does not cause the need to revisit this already complete workflow step. It’s the reason that the constant feature cost curve can be realized.</p>
<h4 id="Estimates-without-Estimating"><a href="#Estimates-without-Estimating" class="headerlink" title="Estimates without Estimating"></a>Estimates without Estimating</h4><p>With a constant cost curve, the effort for an organization to implement can simply be measured over many features over time. This is an impartial way to empirically determine the velocity of teams. These numbers are then used to scope, schedule and cost out future projects.</p>
<h5 id="Technical-Side-Note-About-Test-Driven-Development"><a href="#Technical-Side-Note-About-Test-Driven-Development" class="headerlink" title="Technical Side-Note About Test Driven Development"></a>Technical Side-Note About Test Driven Development</h5><p>This is the impact of the adoption of Agile practices in the industry to put band-aids over the core issue of lack of design. Because the scope of each set of requirements is now per workflow step, the refactoring step of TDD does not impact other workflow steps in the event model. When we don’t have an event model, refactoring goes unrestricted and previously completed pieces of work have to be adjusted. The more work is already completed, the more that has to be reviewed and adjusted with each new addition as we build the solution.</p>
<h4 id="Subcontracting"><a href="#Subcontracting" class="headerlink" title="Subcontracting"></a>Subcontracting</h4><p>The constant cost curve gives the opportunity to do fixed-cost projects. Once there is a velocity established for a team, you have the cost of the software for your organization. With this number, you now can price out what you are willing to give contractors in pay for each workflow step they complete.</p>
<h5 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h5><p>Since each workflow step is protected from being affected by other workflow steps, any deficiencies are to be guaranteed by who is delivering them with non-billable work. So in the case of a subcontractor doing a bad job just to get more billable items done quickly, they will have to have the next hours of work dedicated to fixing deficiencies of work already done before. This evens out their effective rate of pay because they are not working on new delivarables.</p>
<p>This can be carried out over longer periods within an employee engagement by making these metrics available through different checkpoints for performance.</p>
<p>Due to the effective pay self-adjusting to the capability of the individual, it is also a way to on-board new employees and pay them fairly while they are in the probation stage of the engagement. This contract-to-hire process removes the subjective and largely ineffective interview process for technical positions.</p>
<h4 id="Prioritization"><a href="#Prioritization" class="headerlink" title="Prioritization"></a>Prioritization</h4><p>Moving work on a schedule as to what steps are going to be implemented first is done without changing the estimated costs of each item. This ensures that prioritization of work has no impact in the total cost also. The constant cost curve is required to allow this “agility” of reprioritizing features.</p>
<h4 id="Change-Management"><a href="#Change-Management" class="headerlink" title="Change Management"></a>Change Management</h4><p>When the plans change, we simply adjust the event model. This is usually done by just copying the current one and adjusting. Now we can see where the differences are. If a new piece of information is added to one event, that constitutes a new version of the workflow that creates it. Same with the views. If these have not been implemented yet, they don’t change our estimate. If they are already implemented, they add another unit of work to our plan because it’s considered a replacement. There are a few more rules around this. The end result is a definitive guide for change management.</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p><img src="/images/event-modeling/arrows_large.jpg" alt="security arrows"></p>
<p>With an event model, the solution shows exactly where, and equally importantly, when sensitive data crosses boundaries. With traditional audits, the number of interviews with staff was time consuming and at risk of missing important areas. Security concerns are addressed most responsibly when the applications have an event model to reference.</p>
<h2 id="Legacy-Systems"><a href="#Legacy-Systems" class="headerlink" title="Legacy Systems"></a>Legacy Systems</h2><p>Most of the scenarios that real organizations face is where a system is already in place. The main way to deal with a system that is hard to manage because of complexity and lack of understanding is to either rewrite it or to refactor it while it runs. Both of these are very costly.</p>
<p>A third, less risky option exists: Freeze the old system. With proper buy-in, the organization can agree to not alter the existing system. Instead, dealing with bugs and adding new functionality is done on the side as a side-car solution.</p>
<p>Events can be gathered from the database of the old system and make views of that state - employing the <a href="#translation">translate</a> pattern described previously. Y-valve redirection of user action can add new functionality in the side solution. An example which fixes a bug (notice that we use the <a href="./#automation">external integration pattern</a> and extends the old system to add profile pictures is shown here:</p>
<p><img src="/images/event-modeling/event-modeling-legacy-side-car.jpg" alt="legacy side car event model"></p>
<p>This pattern allows an organization to stop putting energy into the sub-optimal existing system and get unblocked from delivering value via the patterns that enable the benefits of the Event Model.</p>
<h2 id="Conclusion-for-Now"><a href="#Conclusion-for-Now" class="headerlink" title="Conclusion for Now"></a>Conclusion for Now</h2><p>Event Modeling is changing how information systems are built. With simple repeatable patterns, information systems are as predicable as engineering efforts should be.</p>
<h2 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h2><p>This content reprinted from <a target="_blank" rel="noopener" href="https://eventmodeling.org/posts/what-is-event-modeling/">Event Modeling: What is it?</a></p>
<p>Thanks.</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/9/cover.png" alt="\#9\ 一般树与树节点遍历"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1775个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/">\#9\ 一般树与树节点遍历</a></h1><div class="content"><p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p>
<ul>
<li>等级关系的描述</li>
<li>分类数据的管理</li>
<li>分类查找操作</li>
</ul>
<p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>类似链表，树也是由节点构成的。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/node.png"></p>
<p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p>
<h3 id="父节点和子节点"><a href="#父节点和子节点" class="headerlink" title="父节点和子节点"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p>
<p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png"></p>
<h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/root.png"></p>
<h3 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png"></p>
<h2 id="Swift树结构实现"><a href="#Swift树结构实现" class="headerlink" title="Swift树结构实现"></a>Swift树结构实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">TreeNode</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p>
<p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节点添加新的子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">child</span>: <span class="type">TreeNode</span>) &#123;</span><br><span class="line">    children.append(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time to give it a whirl.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Create a tree&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> beverages <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    beverages.add(hot)</span><br><span class="line">    beverages.add(cold)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(beverages.value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">0</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">1</span>].value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Create a tree---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">Hot</span></span><br><span class="line"><span class="comment">Cold</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png"></p>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png"></p>
<p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png"></p>
<p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachDepthFirst</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.forEachDepthFirst(visit: visit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeBeverageTree</span>() -&gt; <span class="type">TreeNode</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> coffee <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chocolate <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> blackTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> greenTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chaiTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> soda <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;sida&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> milk <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> gingerAle <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bitterLemon <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    </span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    </span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    </span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    </span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该树的形态如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png"></p>
<p>接下来在这棵树上测试深度优先遍历。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;depth-first traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of depth-first traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachLevelOrder</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&gt;()</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            queue.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst() &#123;</span><br><span class="line">            visit(node)</span><br><span class="line">            node.children.forEach &#123;</span><br><span class="line">                queue.append(<span class="variable">$0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;level-order traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachLevelOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of level-order traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">search</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">TreeNode</span>?</span><br><span class="line">        forEachLevelOrder &#123; node <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">                result <span class="operator">=</span> node</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;searching for a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult1 <span class="operator">=</span> tree.search(<span class="string">&quot;ginger ale&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found node: <span class="subst">\(searchResult1.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult2 <span class="operator">=</span> tree.search(<span class="string">&quot;WKD Blue&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(searchResult2.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of searching for a node---</span></span><br><span class="line"><span class="comment">Found node: ginger ale</span></span><br><span class="line"><span class="comment">Couldn&#x27;t find WKD Blue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li>
<li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li>
<li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li>
</ul>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png"></p>
<p>打印的结果应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 </span><br><span class="line">1 17 20 </span><br><span class="line">1 5 0 2 5 7</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printEachLevel</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">tree</span>: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    queue.append(tree)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>queue.isEmpty &#123;</span><br><span class="line">        nodesLeftInCurrentLevel <span class="operator">=</span> queue.count</span><br><span class="line">        <span class="keyword">while</span> nodesLeftInCurrentLevel <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst()  <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(node.value)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">            node.children.forEach &#123; queue.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">            nodesLeftInCurrentLevel <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/13/cover.jpg" alt="\#13\ 字典树（Tries Tree）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">19 分钟读完 (大约2865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/">\#13\ 字典树（Tries Tree）</a></h1><div class="content"><p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>例如利用Tries表示一个英语单词，可以表示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png"></p>
<p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> words: [<span class="type">String</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">words</span>(<span class="params">matching</span> <span class="params">prefix</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> words.filter &#123; <span class="variable">$0</span>.hasPrefix(<span class="keyword">prefix</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p>
<p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p>
<p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p>
<p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png"></p>
<p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p>
<p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png"></p>
<p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png"></p>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p>
<h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Key</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> parent: <span class="type">TrieNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">Key</span>: <span class="type">TrieNode</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">key</span>: <span class="type">Key</span>?, <span class="params">parent</span>: <span class="type">TrieNode</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tries的节点结构和其他树型数据结构有明显的不同。</p>
<ul>
<li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li>
<li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li>
<li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li>
<li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li>
</ul>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&lt;<span class="title class_">CollectionType</span>: <span class="title class_">Collection</span>&gt; <span class="title class_">where</span> <span class="title class_">CollectionType</span>.<span class="title class_">Element</span>: <span class="title class_">Hashable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> <span class="operator">=</span> <span class="type">TrieNode</span>&lt;<span class="type">CollectionType</span>.<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> root <span class="operator">=</span> <span class="type">Node</span>(key: <span class="literal">nil</span>, parent: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p>
<p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p>
<h2 id="操作算法实现"><a href="#操作算法实现" class="headerlink" title="操作算法实现"></a>操作算法实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[element] <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[element] <span class="operator">=</span> <span class="type">Node</span>(key: element, parent: current)</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> current.children[element]<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    current.isTerminating <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li>
<li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li>
<li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p>
<h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isTerminating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p>
<p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insert and contains&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> trie.contains(<span class="string">&quot;cute&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cute is in the trie&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insert and contains---</span></span><br><span class="line"><span class="comment">cute is in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> current.isTerminating <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent <span class="operator">=</span> current.parent, current.children.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>current.isTerminating &#123;</span><br><span class="line">            parent.children[current.key<span class="operator">!</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            current <span class="operator">=</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li>
<li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li>
<li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** Before removeing ***&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cut<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** After removing cut ***&quot;</span>)</span><br><span class="line">    trie.remove(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is still in the trie&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of remove---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Before removeing ***</span></span><br><span class="line"><span class="comment">&quot;cut&quot; is in the trie</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is in the trie</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** After removing cut ***</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is still in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Prefix-matching"><a href="#Prefix-matching" class="headerlink" title="Prefix matching"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> <span class="title class_">where</span> <span class="title class_">CollectionType</span>: <span class="title class_">RangeReplaceableCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">prefix</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> collections(startingWith: <span class="keyword">prefix</span>, after: current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li>
<li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">CollectionType</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.isTerminating &#123;</span><br><span class="line">        results.append(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children.values &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">        <span class="keyword">prefix</span>.append(child.key<span class="operator">!</span>)</span><br><span class="line">        results.append(contentsOf: collections(startingWith: <span class="keyword">prefix</span>, after: child))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li>
<li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li>
</ul>
<p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p>
<p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;prefix matching&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;car&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;card&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;care&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cared&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cars&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carbs&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carapace&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cargo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>car<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCar <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;car&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCar)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>care<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCare <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;care&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of prefix matching---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;car&quot;</span></span><br><span class="line"><span class="comment">[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;care&quot;</span></span><br><span class="line"><span class="comment">[&quot;care&quot;, &quot;cared&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>Trie树在前缀匹配上有着卓越的性能表现；</li>
<li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/19/cover.jpg" alt="\#19\ 基数排序（Radix Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">9 分钟读完 (大约1354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/">\#19\ 基数排序（Radix Sort）</a></h1><div class="content"><p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p>
<p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>基数排序依赖于整数的位置表示法，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png"></p>
<p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png"></p>
<p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">410</span>, <span class="number">20</span>, <span class="number">1772</span>, <span class="number">88</span>]</span><br></pre></td></tr></table></figure>

<p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png"></p>
<p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p>
<p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png"></p>
<p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>最后，在堆集合中的元素进行千位拆解：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png"></p>
<p>重新按照千位拆解结果进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">radixSort</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> base <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> digits <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>done &#123;</span><br><span class="line">            <span class="comment">// more to come</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p>
<ol>
<li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li>
<li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li>
</ol>
<p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p>
<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buckets: [[<span class="type">Int</span>]] <span class="operator">=</span> .<span class="keyword">init</span>(repeating: [], count: base)</span><br><span class="line">            </span><br><span class="line">forEach &#123;</span><br><span class="line">    number <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> remainingPart <span class="operator">=</span> number <span class="operator">/</span> digits</span><br><span class="line">    <span class="keyword">let</span> digit <span class="operator">=</span> remainingPart <span class="operator">%</span> base</span><br><span class="line">    buckets[digit].append(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digits <span class="operator">*=</span> base</span><br><span class="line"><span class="keyword">self</span> <span class="operator">=</span> buckets.flatMap &#123; <span class="variable">$0</span> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li>
<li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li>
<li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li>
</ol>
<p><strong>循环何时结束？</strong></p>
<p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p>
<ol>
<li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li>
<li>在forEach闭包结构中，增加如下语句：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remainingPart <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;radix sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    array.radixSort()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Radix sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of radix sort---</span></span><br><span class="line"><span class="comment">Original: [88, 410, 1772, 20]</span></span><br><span class="line"><span class="comment">Radix sorted: [20, 88, 410, 1772]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p>
<p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p>
</li>
<li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p>
</li>
<li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/"><img class="fill" src="/images/keras-mnist-for-ios/cover.jpg" alt="从Keras开始构建iOS平台手写数字实时识别"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">36 分钟读完 (大约5406个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/">从Keras开始构建iOS平台手写数字实时识别</a></h1><div class="content"><p>本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。</p>
<h1 id="10步之内完成模型的构建、训练和发布使用"><a href="#10步之内完成模型的构建、训练和发布使用" class="headerlink" title="10步之内完成模型的构建、训练和发布使用"></a><strong>10步之内完成模型的构建、训练和发布使用</strong></h1><p><strong>TLDR；</strong></p>
<p>本文中暂时不会介绍卷积神经网络的细节内容，例如如何使用卷积层、池化层训练深度学习网络，以及如何使用预训练模型识别目标等，相关卷积神经网络细节的内容将会放在本文内容之后，进行详细的介绍。本文旨在介绍如何一步一步的从数据的获取、整理、模型的构建、训练以及后面的格式转换、使用等介绍Keras框架的基本使用和如何使用CoreML体系在一个实实在在的应用程序中使用模型等。</p>
<p>下图是最终结果的预览：</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<p>接下来，开始一步步的实现相关的过程等。</p>
<h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1. 如何开始"></a>1. <strong>如何开始</strong></h2><p>To have a fully working example I thought we’d start with a toy dataset like the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST set of handwritten letters</a> and train a deep learning network to recognize those. Once it’s working nicely on our PC, we will port it to an iPhone X using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">CoreML standard</a>.</p>
<p>在计算机程序设计学习的过程中，几乎都是以一个经典的“Hello World”程序开始的。而在机器学习领域，同样具有类似“Hello World”的一个经典入门级数据集——<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST</a>，该数据集是一系列手写数字0到9的图片文件，这里的目的是使用这个数据集训练一个深度学习网络来识别它们。在开始之前，你或许对iOS平台的CoreML以及keras还很陌生，你可以先了解一下它们的体系和设计：</p>
<ul>
<li>CoreML：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">Core ML | Apple Developer Documentation</a></p>
<ul>
<li>Keras：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://keras.io/zh/">Keras 中文文档</a></p>
<h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>在大多数的Python机器学习类库中，都有内置的数据集访问接口，以方便使用者的使用，在Keras中也不例外，可以很方便的使用其内置的数据集访问接口获取数据集，具体的接口定义在<code>keras.datasets</code>中，具体的使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Keras内置数据集访问接口导入数据集并对数据集进行转换</span></span><br><span class="line">    <span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">    <span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line">    <span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mnist_data</span>():</span><br><span class="line">        <span class="comment"># 定义输入图像的维度</span></span><br><span class="line">        img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line">        <span class="comment"># 加载数据集</span></span><br><span class="line">        (X_train, Y_train), (X_test, Y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 数据缩放，将原来的 [0, 255] 缩放至 [0, 1]</span></span><br><span class="line">        X_train = X_train.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">        X_test = X_test.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 对原始数据中的目标值进行One-Hot Encoding，使得目标数据更加的稀疏</span></span><br><span class="line">        Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">        Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> (X_train, Y_train), (X_test, Y_test), input_shape</span><br><span class="line">    </span><br><span class="line">    (X_train, Y_train), (X_test, Y_test), input_shape = mnist_data()</span><br></pre></td></tr></table></figure>

<h2 id="3-正确地编码"><a href="#3-正确地编码" class="headerlink" title="3. 正确地编码"></a>3. 正确地编码</h2><p>当处理图片数据的时候，必须要区分想要的编码方式。Keras是一个可以处理多个“后端”的高级库，例如<a target="_blank" rel="noopener" href="https://www.tensorflow.org/">Tensorflow</a>, <a target="_blank" rel="noopener" href="http://deeplearning.net/software/theano/">Theano</a> 和 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/cognitive-toolkit/">CNTK</a>，首先我们要了解我们所使用的后端是如何编码数据的。在Keras默认使用的TensorFlow后端中，针对图像的处理通常是以“通道优先”或“通道末尾”的方式进行编码的，因此在我们的使用TensorFlow作为后端的时候，编码结果其实是一个张量，其形状为(batch_size, rows, cols, channels)。意味着首先是输入的batch_size，然后输入28行28列的图像维度，最后输入1作为通道数，因为我们使用的是灰度图像数据。</p>
<p>我们可以看看前6张图像具体是什么样子，可以使用如下代码查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化数据集中前6张图像</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    %matplotlib inline</span><br><span class="line">    <span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line">    (X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">6</span>, i+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        ax.imshow(X_train[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="built_in">str</span>(y_train[i]))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://liip.rokka.io/www_inarticle/7cce04/numbers.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-规范化数据"><a href="#4-规范化数据" class="headerlink" title="4. 规范化数据"></a>4. 规范化数据</h2><p>可以看到，在黑色背景中显示了白色数字，每一张图像中的数字都是居中的，而且分辨率都很低——在这个例子中我们使用的是28x28像素。</p>
<p>你可能已经注意到，在上述获取数据的部分，我们对每一张图片除以255来缩放了图像像素，这导致像素值在0和1之间，这对于任何类型的训练都非常有用。每个图像像素值在转换之前都是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用像素值可视化一个数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_input</span>(<span class="params">img, ax</span>):</span><br><span class="line">    ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    width, height = img.shape</span><br><span class="line">    thresh = img.<span class="built_in">max</span>()/<span class="number">2.5</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            ax.annotate(<span class="built_in">str</span>(<span class="built_in">round</span>(img[x][y], <span class="number">2</span>)),</span><br><span class="line">                        xy=(y, x),</span><br><span class="line">                        horizontalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        verticalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        color=<span class="string">&#x27;white&#x27;</span> <span class="keyword">if</span> img[x][y] &lt; thresh <span class="keyword">else</span> <span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">visualize_input(X_train[<span class="number">0</span>], ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/keras-mnist-for-ios/pixes-daf69647-717f-499d-aa39-fa83904d7675.png"></p>
<p>可以看到图像中的每个灰度像素都是介于0到255之间的，并且当像素为255时，背景色为白色，像素为0时，背景色为黑色。在这里使用的是<code>mnist.load_data()</code>加载的数据集，此时并没有对图像进行像素缩放，而在我们自定义的数据集加载方法<code>mnist_data()</code>方法中，我们进行了像素的缩放，<code>X_train = X_train.astype(&#39;float32&#39;)/255</code> 。</p>
<h2 id="5-One-Hot-编码"><a href="#5-One-Hot-编码" class="headerlink" title="5. One-Hot 编码"></a>5. One-Hot 编码</h2><p>最初，数据以Y-Vector包含X Vector（像素数据）包含的数值的方式编码。例如，如果图像看起来像7，那么Y-Vector中必定包含数字7。但是这种方式不利于我们在网络结构中直接使用，我们需要进行这种转换，希望将数据的输出映射到网络中的10个输出神经元，此时当相应的数字被识别时，相应的神经元就会触发，从而达到有效的识别。</p>
<p><img src="https://liip.rokka.io/www_inarticle/46a2ef/onehot.png"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="6-网络模型化"><a href="#6-网络模型化" class="headerlink" title="6. 网络模型化"></a>6. 网络模型化</h2><p>了解了数据集的基本情况以及进行合理的数据转换后，该是定义卷积神经网络的时候了。这里讲直接使用卷积神经网络中的卷积层和池化层来定义网络，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义网络模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adadelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">network</span>():</span><br><span class="line">    model = Sequential()</span><br><span class="line">    input_shape = (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">500</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型概述</span></span><br><span class="line">    <span class="built_in">print</span>(model.summary())</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>在模型的定义中，我们以内核大小为3的<a target="_blank" rel="noopener" href="https://keras.io/layers/convolutional/">卷积</a>，这也意味着窗口为3x3像素，输入形状的大小为28x28像素。紧跟着使用了一个池化大小为2的<a target="_blank" rel="noopener" href="https://keras.io/layers/pooling/">池化层</a>，这里的池化大小为2，意味着将会对每一个输入缩减为原来的一般，因此在下一个卷积层中，输入大小为14x14像素。按照此方式重复两次后，最终的卷积输入大小转换为3x3像素。接下来，使用了<a target="_blank" rel="noopener" href="https://keras.io/layers/core/#dropout">Dropout层</a>，将30%的输入单元随机设置为0，以防止训练的过拟合。最后，展平输入层（此例子中为3x3x32&#x3D;288），并将它们连接到一个具有500个输入的密度层。在这些步骤之后，添加了另一个Dropout层，之后连接到最后的密度层，该密度层中包含10个输出单元，这些输出单元对应着我们的目标类别，0到9之间的数字。</p>
<pre><code>_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_1 (Conv2D)            (None, 28, 28, 32)        320       
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 14, 14, 32)        0         
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 14, 14, 32)        4128      
_________________________________________________________________
max_pooling2d_2 (MaxPooling2 (None, 7, 7, 32)          0         
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 7, 7, 32)          4128      
_________________________________________________________________
max_pooling2d_3 (MaxPooling2 (None, 3, 3, 32)          0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 3, 3, 32)          0         
_________________________________________________________________
flatten_1 (Flatten)          (None, 288)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 500)               144500    
_________________________________________________________________
dropout_2 (Dropout)          (None, 500)               0         
_________________________________________________________________
dense_2 (Dense)              (None, 10)                5010      
=================================================================
Total params: 158,086
Trainable params: 158,086
Non-trainable params: 0
_________________________________________________________________
</code></pre>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7. 训练模型"></a>7. 训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = network()</span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=Adadelta(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用训练数据拟合模型</span></span><br><span class="line">model.fit(X_train, Y_train, batch_size=<span class="number">512</span>, epochs=<span class="number">6</span>, verbose=<span class="number">1</span>, validation_data=(X_test, Y_test))</span><br><span class="line"><span class="comment"># 模型评估分数</span></span><br><span class="line">score = model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>categorical_crossentropy</code>作为损失函数，因为我们的目标类别有多个（0至9），Keras库提供了多种<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#usage-of-optimizers">优化器</a>，你可以选择任意一个进行模型训练，并最终找到一个最好的。经过尝试之后，这里选择<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adadelta"><code>AdaDelta</code></a>作为优化器进行模型训练，当然你也可以尝试AdaDelta的高级版<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adagrad">AdaGrad</a>。</p>
<p><img src="https://liip.rokka.io/www_inarticle/42b4b8/train.png"></p>
<p>可以看到，经过训练，所得到的模型识别准确率达到了98%，考虑到这里仅仅使用了简单的网络结构，达到这样的准确率已经是非常出色了。在上述截图中，每次迭代的准确性都是在提高，可以说明这里使用的简单结构是合理的，训练得到的模型可以很好地预测输入28x28像素所表示的数字。</p>
<h2 id="8-保存模型"><a href="#8-保存模型" class="headerlink" title="8. 保存模型"></a>8. 保存模型</h2><p>由于我们想要在iOS设备上使用该模型，因此需要将该模型转换为iOS系统能够理解的格式。实际上，微软、Facebook以及亚马逊等企业已经研发出了一套能够在所有深度学习网络格式见转换的协议，以便能够在任何设备上使用的可交换的开放式神经网络交换格式——<a target="_blank" rel="noopener" href="https://onnx.ai/">ONNX</a>。</p>
<p>但是，截止目前，Apple设备上仅仅能够使用的是CoreML格式。为了能够将Keras模型转换为CoreML格式，Apple特意推出来一个非常方便的帮助类库——<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">coremltools</a>，这里我们就可以使用该类库来完成工作。该类库能够将scikit-learn、Keras、XGBoost等机器学习类库训练的模型转换为CoreML支持的格式，从而使得模型能够直接在Apple设备上使用。如果你还未安装coremltools类库，可以使用<code>pip install coremltools</code>进行安装，然后再使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coreml_model = coremltools.converters.keras.convert(model,</span><br><span class="line">                                                        input_names=<span class="string">&quot;image&quot;</span>,</span><br><span class="line">                                                        image_input_names=<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">                                                        class_labels=[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">                                                        )</span><br></pre></td></tr></table></figure>

<p>在进行模型转换的时候，最重要的参数是class_labels，它定义了模型尝试预测的类数，以及input_names或者image_input_names。通过将它们设置为图像，Xcode会自动识别该模型是关于接收图像并从中预测某些内容，也就是说这些参数是告诉Xcode，该模型是关于那方面的任务。根据应用程序和模型的特定功能，需要研究<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">官方文档</a>进一步的了解这些参数的可选值等。</p>
<p>另外还有一些可以定义模型元信息的参数，这些参数可以给模型一个简要的说明，甚至作者、license等，可以让使用者能够方便的查阅模型所针对的特定任务等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑模型元信息</span></span><br><span class="line">coreml_model.author = <span class="string">&#x27;Robin&#x27;</span></span><br><span class="line">coreml_model.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">coreml_model.short_description = <span class="string">&#x27;MNIST handwriting recognition with a 3 layer network&#x27;</span></span><br><span class="line">coreml_model.input_description[<span class="string">&#x27;image&#x27;</span>] = <span class="string">&#x27;28x28 grayscaled pixel values between 0-1&#x27;</span></span><br><span class="line">coreml_model.save(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coreml_model)</span><br></pre></td></tr></table></figure>

<h2 id="9-使用模型预测"><a href="#9-使用模型预测" class="headerlink" title="9. 使用模型预测"></a>9. 使用模型预测</h2><p>在将模型保存为CoreML格式之后，我们可以尝试使用转换后的模型进行一个预测，来确定模型是否工作正常。在这里我们将从MNIST数据集中选择一张图像进行预测验证。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用CoreML模型预测验证</span></span><br><span class="line"> <span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> model =  coremltools.models.MLModel(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"> im = Image.fromarray((np.reshape(mnist_data()[<span class="number">0</span>][<span class="number">0</span>][<span class="number">12</span>]*<span class="number">255</span>, (<span class="number">28</span>, <span class="number">28</span>))).astype(np.uint8),<span class="string">&quot;L&quot;</span>)</span><br><span class="line"> plt.imshow(im)</span><br><span class="line"> predictions = model.predict(&#123;<span class="string">&#x27;image&#x27;</span>: im&#125;)</span><br><span class="line"> <span class="built_in">print</span>(predictions)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<pre><code>&#123;u&#39;classLabel&#39;: u&#39;3&#39;, 
u&#39;output1&#39;: &#123;u&#39;1&#39;: 0.0, 
                        u&#39;0&#39;: 0.0, 
                        u&#39;3&#39;: 1.0, 
                        u&#39;2&#39;: 0.0, 
                        u&#39;5&#39;: 0.0, 
                        u&#39;4&#39;: 0.0, 
                        u&#39;7&#39;: 0.0, 
                        u&#39;6&#39;: 0.0, 
                        u&#39;9&#39;: 0.0, 
                        u&#39;8&#39;: 0.0
                        &#125;
&#125;
</code></pre>
<p><img src="/images/keras-mnist-for-ios/download-45f07bef-9ca6-4ea6-a674-789607207e9c.png"></p>
<p>可以看到，预测过程和结果均符合预期。接下来是时候在Xcode项目中使用该模型了。</p>
<h1 id="10步完成模型在Xcode项目中的应用"><a href="#10步完成模型在Xcode项目中的应用" class="headerlink" title="10步完成模型在Xcode项目中的应用"></a>10步完成模型在Xcode项目中的应用</h1><p>为了能够让几乎所有人了解机器学习模型文件是如何一步一步在Xcode项目中使用的，这里将会从最为基础的Xcode安装、项目创建等说起，如果你是iOS开发的老鸟，部分内容请自行略过。</p>
<h2 id="1-安装Xcode"><a href="#1-安装Xcode" class="headerlink" title="1. 安装Xcode"></a>1. 安装Xcode</h2><p>对于iOS体系来说，Xcode是开发iOS应用程序必须的工具之一，因此如果你还未安装Xcode，需要安装Xcode，最为简单的方式是在Mac App Store中搜索并安装。如果你已经安装了Xcode，需要确保Xcode的版本至少在9.0或以上。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>安装好Xcode之后，开启Xcode，选择iOS平台下的单视图应用，命名项目，这里命名为“MNIST-Demo”，选择一个保存项目文件的位置，创建项目即可。</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-78fa75ca-4376-49e8-b194-bde1699f9be3.png"></p>
<h2 id="3-添加CoreML模型文件"><a href="#3-添加CoreML模型文件" class="headerlink" title="3. 添加CoreML模型文件"></a>3. 添加CoreML模型文件</h2><p>现在，你可以将通过coremltools转换得到的CoreML模型加入到项目中了。最简单的方式是直接拖拽模型文件到项目目录中，如果为了之后更新模型而不用去删掉重新添加，你可以在弹出的选项框中选择“add as Reference”。</p>
<p><img src="/images/keras-mnist-for-ios/add-model-98101cf6-8cf8-4d2a-b58e-30d397c98354.png"></p>
<h2 id="4-删除不需要的视图或者故事版"><a href="#4-删除不需要的视图或者故事版" class="headerlink" title="4. 删除不需要的视图或者故事版"></a>4. 删除不需要的视图或者故事版</h2><p>因为我们仅仅使用相机并显示标签，因此这里会删除掉项目中默认的一些用户界面，也就是项目中的视图控制器和故事面板。当然你也可以选择不删除，直接使用现有的视图和故事面板进行开发，不论选择哪种方式都能达到目的。这里要注意的是，如果选择编码的方式构建应用，再删除了主故事面板文件后，需要在项目的TARGETS中同步删除”Main Interface”的默认设置。</p>
<p><img src="/images/keras-mnist-for-ios/ScreenShot2018-11-22at10-9150b677-f351-4732-bfb6-d74019527380.32.46AM.png"></p>
<h2 id="5-程序化创建根视图控制器"><a href="#5-程序化创建根视图控制器" class="headerlink" title="5. 程序化创建根视图控制器"></a>5. 程序化创建根视图控制器</h2><p>接下来我们将使用代码的方式，重新制定应用程序的根视图。具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码的方式指定根视图控制器</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     <span class="comment">// 创建窗口</span></span><br><span class="line">     window <span class="operator">=</span> <span class="type">UIWindow</span>()</span><br><span class="line">     window<span class="operator">?</span>.makeKeyAndVisible()</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// 指定根视图控制器</span></span><br><span class="line">     <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">ViewController</span>()</span><br><span class="line">     window<span class="operator">?</span>.rootViewController <span class="operator">=</span> vc</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构建视图控制器细节"><a href="#6-构建视图控制器细节" class="headerlink" title="6. 构建视图控制器细节"></a>6. 构建视图控制器细节</h2><p>接下来就是构建视图控制器的详细内容细节了。我们需要以下可交互的元素组件，例如按钮，也需要作为展示结果或者状态的标签等，另外重要的是，由于需要使用相机，因此AVFoundation类库是必须要添加的，该库用来访问和控制iOS设备上的相机，还需要Vision库，该库是iOS推出的用于计算机视觉相关任务的工具库，能够很好的和CoreML模型之间进行交互等。</p>
<p>具体的代码细节，这里不再累述，完成之后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义视图控制器</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> Vision</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要使用到相机设备进行视频流的输入，因此这里要继承AVCaptureVideoDataOutputSampleBufferDelegate协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">AVCaptureVideoDataOutputSampleBufferDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文本标签用来显示识别结果</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">UILabel</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.textColor <span class="operator">=</span> .white</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Label&quot;</span></span><br><span class="line">        label.font <span class="operator">=</span> label.font.withSize(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="comment">// 调用相机设备设置方法、文本标签设置方法</span></span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()       </span><br><span class="line">        setupCaptureSession()</span><br><span class="line">        view.addSubview(label)</span><br><span class="line">        setupLabel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相机设备session</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupCaptureSession</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的捕获session</span></span><br><span class="line">        <span class="keyword">let</span> captureSession <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找可用的相机设备</span></span><br><span class="line">        <span class="keyword">let</span> availableDevices <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.<span class="type">DiscoverySession</span>(deviceTypes: [.builtInWideAngleCamera], mediaType: <span class="type">AVMediaType</span>.video, position: .back).devices</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 选择首个设备并设置为输入源</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> captureDevice <span class="operator">=</span> availableDevices.first &#123;</span><br><span class="line">                captureSession.addInput(<span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: captureDevice))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未找到相机设备，则打印错误信息</span></span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将视频输出设置到屏幕并将输出添加到我们的捕获会话</span></span><br><span class="line">        <span class="keyword">let</span> captureOutput <span class="operator">=</span> <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">        captureSession.addOutput(captureOutput)</span><br><span class="line">        <span class="keyword">let</span> previewLayer <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>(session: captureSession)</span><br><span class="line">        previewLayer.frame <span class="operator">=</span> view.frame</span><br><span class="line">        view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲视频并启动捕获会话</span></span><br><span class="line">        captureOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;videoQueue&quot;</span>))</span><br><span class="line">        captureSession.startRunning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">captureOutput</span>(<span class="keyword">_</span> <span class="params">output</span>: <span class="type">AVCaptureOutput</span>, <span class="params">didOutput</span> <span class="params">sampleBuffer</span>: <span class="type">CMSampleBuffer</span>, <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载Core ML 模型</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">VNCoreMLModel</span>(for: <span class="type">SimpleMnist</span>().model) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Core ML运行推理</span></span><br><span class="line">        <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNCoreMLRequest</span>(model: model) &#123; (finishedRequest, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> results <span class="operator">=</span> finishedRequest.results <span class="keyword">as?</span> [<span class="type">VNClassificationObservation</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获得分最高的推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="type">Observation</span> <span class="operator">=</span> results.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建最终显示的文本格式</span></span><br><span class="line">            <span class="keyword">let</span> predclass <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(Observation.identifier)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示在文本标签内</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async(execute: &#123;</span><br><span class="line">                <span class="keyword">self</span>.label.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(predclass)</span> &quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建一个核心视频像素缓冲区，它是一个图像缓冲区，用于保存主存储器中的像素生成帧，</span></span><br><span class="line">                <span class="comment">// 压缩或解压缩视频或使用核心图像的应用程序都可以使用核心视频像素缓冲区</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> pixelBuffer: <span class="type">CVPixelBuffer</span> <span class="operator">=</span> <span class="type">CMSampleBufferGetImageBuffer</span>(sampleBuffer) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="keyword">try?</span> <span class="type">VNImageRequestHandler</span>(cvPixelBuffer: pixelBuffer, options: [:]).perform([request])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupLabel</span>() &#123;</span><br><span class="line">        label.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        label.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: <span class="operator">-</span><span class="number">50</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你直接使用上述代码，请记得修改模型的名称。</p>
</blockquote>
<p><img src="/images/keras-mnist-for-ios/Untitled-503351b4-b11a-4e7b-a7ad-de4017cbac28.png"></p>
<h2 id="6-添加隐私说明信息"><a href="#6-添加隐私说明信息" class="headerlink" title="6. 添加隐私说明信息"></a>6. 添加隐私说明信息</h2><p>由于我们要使用相机设备进行视频数据流的获取，因此需要在Xcode工程项目中的info.plist文件中添加相应的权限申请说明“<em>Privacy - Camera Usage Description</em>”，并附带相应的说明性文字：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-8e6fa826-e368-47d0-8256-588a136119db.png"></p>
<h2 id="7-加入苹果开发者计划"><a href="#7-加入苹果开发者计划" class="headerlink" title="7. 加入苹果开发者计划"></a>7. 加入苹果开发者计划</h2><p>为了能够让该应用程序运行在你的手机设备上，你可能需要注册<a target="_blank" rel="noopener" href="https://developer.apple.com/programs/enroll/">苹果的开发者计划</a>。当然如果你不想为了运行项目而花费金钱，你也可以按照<a target="_blank" rel="noopener" href="https://9to5mac.com/2016/03/27/how-to-create-free-apple-developer-account-sideload-apps/">此教程</a>注册免费的账户。</p>
<h2 id="8-在iPhone设备上发布应用"><a href="#8-在iPhone设备上发布应用" class="headerlink" title="8. 在iPhone设备上发布应用"></a>8. 在iPhone设备上发布应用</h2><p>一切准备好之后，你就可以将该应用程序发布到你的手机设备上了。你可以按照如下图所示的方式发布项目，也可以直接在Xcode中选定目标设备，然后使用快捷键CMD+R的方式构建：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-1a74e4bf-8c84-4e49-95f2-4b46f8f4102f.png"></p>
<h2 id="9-使用应用程序"><a href="#9-使用应用程序" class="headerlink" title="9. 使用应用程序"></a>9. 使用应用程序</h2><p>经过上述各种设置和编码之后，终于可以在设备上运行我们的应用程序了。如果一切正常，首次应用程序启动的时候，会询问你是否允许应用程序访问设备的相机，这里需要允许，否则我们的应用程序则无法正常工作。</p>
<p>另外，我们这里所训练的模型以及制作的应用程序，没有进行详细的设计和优化，在识别的过程中，可能会遇到识别不出来以及识别错误的情况，如果需要将此功能应用在你的产品中，需要严格重新审查你所拥有的数据，以及模型的训练，app的使用等，以免出现不可预知的错误等问题。</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，希望能够让你了解如何使用Keras训练所需要的模型，以及如何将其应用在iOS平台下的应用程序中，虽然介绍的不够深入，但是希望能够带给你继续深入理解Keras、了解Core ML的欲望，早日在你的应用程序中实现AI的能力，为你的应用程序增添色彩。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>