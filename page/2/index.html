<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-iOS_VMManage/"><img class="fill" src="/images/vm/memory_manage.jpg" alt="iOS虚拟内存管理"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.794Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:44:53.482Z" title="4/30/2022, 3:44:53 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">28 分钟读完 (大约4166个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-iOS_VMManage/">iOS虚拟内存管理</a></h1><div class="content"><p>虚拟内存是一种允许操作系统避开物理RAM限制的内存管理机制。虚拟内存管理器为每个进程创建一个逻辑地址空间或者虚拟内存地址空间，并且将它分配为相同大小的内存块，可称为页。处理器与内存管理单元MMU维持一个页表来映射程序逻辑地址空间到计算机RAM的硬件地址。当程序的代码访问内存中的一个地址时，MMU利用页表将指定的逻辑地址转换为真实的硬件内存地址，这种转换自动发生并且对于运行的应用是透明的。</p>
<h2 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h2><p>就程序而言，在它逻辑地址空间的地址永远可用。然而，当应用访问一个当前并没有在物理RAM中的内存页的地址时，就会发生页错误。当这种情况发生时，虚拟内存系统调用一个专用的页错误处理器来立即响应错误。页错误处理器停止当前执行的代码，定位到物理内存的一个空闲页，从磁盘加载包含必要数据的页，更新页表，之后返回对程序代码的控制，程序代码就可以正常访问内存地址了。这个过程被称为分页。</p>
<p>如果在物理内存中没有空闲页，页错误处理器必须首先释放一个已经存在的页从而为新页提供空间。由系统平台决定系统如何释放页。在OS X，虚拟内存系统常常将页写入备份存储。备份存储是一个基于磁盘的仓库,包含了给定进程内存页的拷贝。将数据从物理内存移到备份存储被称为页面换出；将数据从备份存储移到物理内存被称为页面换入。在iOS，没有备份存储，所以页面永远不会换出到磁盘，但是只读页仍可以根据需要从磁盘换入。</p>
<p>在OS X and iOS中，页大小为4kb。因此，每次页错误发生时，系统会从磁盘读取4kb。当系统花费过度的时间处理页错误并且读写页，而并不是执行代码时，会发生磁盘震荡（disk thrashing）。</p>
<p>无论页换出／换入，磁盘震荡会降低性能。因为它强迫系统花费大量时间进行磁盘的读写。从备份存储读取页花费相当长的时间，并且比直接从RAM读取要慢很多。如果系统从磁盘读取另一个页之前，不得不将一个页写入磁盘时，性能影响会更糟。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-01-22-iOS_VMManage/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-10-23-what-is-event-modeling/"><img class="fill" src="/images/img/hero.jpg" alt="What is Event Modeling?"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.167Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.168Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">27 分钟读完 (大约4029个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-10-23-what-is-event-modeling/">What is Event Modeling?</a></h1><div class="content"><p>Event Modeling is a way to design a blueprint for an Information System of any size or scale. It is done in a way that allows the clearest communication of the system’s workings to the largest possible cross-section of roles in an organization. The system can be checked for completeness by following the single thread of data propagation through it.</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Moore’s-Law"><a href="#Moore’s-Law" class="headerlink" title="Moore’s Law"></a>Moore’s Law</h3><p>Digitized Information Systems are a relatively new concept. Humans have been working with information systems for thousands of years. Over centuries banks, insurance companies and many other large scale organizations have managed to succeed.</p>
<p>With the advent of the transistor, the speed and accuracy of processing information increased by orders of magnitude. What did not gain the same quantum leap is digital storage. This imbalance caused information systems to be optimized for a very small amount of online information. You can see this in the advent of RDBMS technology. What it mean is that the compromise was to throw information away.</p>
<h3 id="Human-Memory"><a href="#Human-Memory" class="headerlink" title="Human Memory"></a>Human Memory</h3><p>Story telling is something that enables humans to pass knowledge on to subsequent generations and relies heavily on how we store memories - whether logical, visual, auditory or other. This is important because there is a parallel with how information systems were constructed. There is a “memory” of all your visits to the doctor. It’s the ledger of the forms that are filled in with each visit.</p>
<p>Specifications by example are a way to show how something is supposed to work. This can be seen in successful practices in software such as Behaviour Driven Development. This works well because we communicate by stories more effectively. It ties back to story telling as a way to keep information in society. Our brains are built for it more than they are built for flow-charts and other formats. </p>
<h2 id="Life-After-the-Dawn-of-the-Computer-Age"><a href="#Life-After-the-Dawn-of-the-Computer-Age" class="headerlink" title="Life After the Dawn of the Computer Age"></a>Life After the Dawn of the Computer Age</h2><p>In recent decades, Moore’s Law from the side of online storage has caught up. This means that after the initial few decades of living with computer systems, our information systems that are now digitized can use the mechanics that made them effective throughout history.</p>
<p>This means we have enough storage to not throw away information. The ability to be able to keep a history of all that has happened allows systems to be more reliable by means of audit and specification by example that literally translates to how the system is implemented.</p>
<p>We also have enough storage to have a cache of different views into what has happened in the system. This is important as we now have made the task of trying to fit all our concerns into one model an unnecessary constraint. In 1956, an IBM harddrive that stored 10MB cost $1M and required $30K monthly budget.</p>
<h3 id="Reality-of-Current-Tooling"><a href="#Reality-of-Current-Tooling" class="headerlink" title="Reality of Current Tooling"></a>Reality of Current Tooling</h3><p>So we are now at a cross-roads where we have very mature tooling, but that tooling is made for solving a problem we no longer have - being efficient with storage constraints. The new tooling that we see on the rise is what information systems always had: a ledger of what happened - storage is not a major issue anymore. There are many benefits to keeping ledger. They represent the natural way we think about systems - digital or not.</p>
<h2 id="The-Model-That-Works"><a href="#The-Model-That-Works" class="headerlink" title="The Model That Works"></a>The Model That Works</h2><p><img src="/images/event-modeling/blueprint_large.jpg" alt="blueprint"></p>
<p>Time is a concept that is now a core piece of describing a system. The components and classes that we saw in computing are not as important. We can show, by example, what a system is supposed to do from start to finish, on a time line and with no branching - again to make use of that memory aspect of our brains. This is the Event Model. It is used to follow all field values in the UI to the storage of those value to where they finally end up on a report or a screen. It’s generally done with sticky notes on a wall or whiteboard - or an online version of a whiteboard. We’ll see that simplicity is at the heart of the approach as we will only use 3 types of building blocks as well as traditional wireframes or mockups. Further to keep things simple, we will rely on only 4 patterns of how we structure the diagram.</p>
<h3 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h3><p>When we want to adopt certain practices or processes to help one another understand and communicate, it is inversely proportional to the amount of learning individuals must do to be proficient in those methods. Put in another way, if an organization chooses to adopt a process called “X”, and X requires one book and a workshop that takes a week to go through, it nullifies the effectiveness of X, and here’s the worst part, <strong>no matter how good X is</strong>.</p>
<p>When the book is a required reading by the people in an organization, everyone will say they have read it; only half will have actually read it; half of those will claim they understood it; and only half of those will have understood it; and half of those will be able to apply it.</p>
<p>This is why Event Modeling only uses 3 moving pieces and 4 patterns based on 2 ideas. It takes a few minutes to explain and the rest of the learning is done in practice, transparently where any deficiencies in the understanding of even those few core ideas are quickly corrected.</p>
<p>This is how you get to an understanding in an organization.</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Let’s say we want to design a hotel website for a hotel chain for allowing our customers to book rooms online and for us to schedule cleaning and any other hotel concerns. We can show what events, or facts, are stored on a timeline of the year in that business. We can pretend we have the system already and ask ourselves what facts were stored as we move forward through time.</p>
<h3 id="Wireframes"><a href="#Wireframes" class="headerlink" title="Wireframes"></a>Wireframes</h3><p>To bring in the visual part of story-telling we show wireframes or web page mockups across the top. These can be organized in swim-lanes to show different people (or sometimes systems) interacting with our system. We also show any automation here with a symbol like gears to illustrate that the system is doing something. This has an easy to understand set of mechanics of a todo list that a process goes and does and marks items as done. In our hotel example, this could be a payment system or notification system.</p>
<p><img src="/images/event-modeling/innovate_large.jpg" alt="innovation"></p>
<p>At this point we have enough to be able to design some systems with some UX&#x2F;UI people. But there are 2 very fundamental pieces that must be added to the blueprint which show 2 core features of any information system: Empowering the user and informing the user.</p>
<h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h3><p>Most information systems must give an ability for a user to affect state of the system. In our example, we must allow the booking of a room to change the system so that we don’t over-book and when that person arrives at that future date, they have a room ready for them.</p>
<p>Intentions to change the system are encapsulated in a command. As opposed to simply saving form data to a table in a database, this allows us to have a non-technical way to show the intentions while allowing any implementation - although certain ones have advantages as we will see.</p>
<p><img src="/images/event-modeling/empower_large.jpg" alt="empower"></p>
<p>From the UI and UX perspective this drives a “command based UI” which goes a long way into helping make composable UIs. With this pattern, it’s a lot clearer what the transactional boundaries are both from the technical and business perspectives. The hotel guest either registered successfully or not.</p>
<p>When there are nuances to what the prerequisites are for having a command succeed, they are elaborated on “Given-When-Then” style specifications. This is, again, a way to tell a story of what success looks like. There may be a few of these stories to show how a command can and cannot succeed.</p>
<p>An example might be “<strong>Given</strong>: We have registered, and added a payment method, <strong>When</strong>: We try to book a room, <strong>Then</strong>: a room is booked.” This form of specification is also referred to as “Arrange, Act, Assert” and in the UX&#x2F;UI world “Situation, Motivation, Value”.</p>
<h3 id="Views-or-Read-Models"><a href="#Views-or-Read-Models" class="headerlink" title="Views (or Read Models)"></a>Views (or Read Models)</h3><p>The second part of any information system is the ability to inform the user about the state of the system. Our hotel guest should know about what days are available for certain types of rooms they are interested in staying in. There are usually many of these and support the multi-model aspect of information systems.</p>
<p><img src="/images/event-modeling/inform_large.jpg" alt="inform"></p>
<p>A view into the facts already in the system has been changing as these new events were being stored. In our hotel system, this calendar view was being updated as new events that affected inventory were happening. Other views may be for the cleaning staff to see which rooms are ready to be cleaned as events about guests checking out are being stored.</p>
<p>Specifying how a view behaves is very similar to the way we specify how we accept commands with one difference. The views are passive and cannot reject an event after it’s been stored in the system. We have “<strong>Given</strong>: hotel is set up with 12 ocean view rooms, ocean view room was booked from April 4th - 12th X 12, <strong>Then</strong>: the calendar should show all dates except April 4th - 12th for ocean view availability”.</p>
<h3 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h3><p>We just covered the first 2 patterns of the 4 that are needed to describe most systems. Systems can get information from other systems and send information to other systems. It would be tempting to force these 2 patterns to be an extension of the first 2 and share the same space. However, these interactions are harder to communicate as they don’t have that human-visible aspect to them and require some higher level patterns.</p>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>When we have an external system that’s providing us with information, it’s helpful to translate that information into a form that is more familiar in our own system. In our hotel system, we may get events from guests’ GPS coordinates if they opted in to our highly reactive cleaning crew. We would not want to use longitude and latitude pairs as events to specify preconditions in our system. We would rather have events that mean something to us like “Guest left hotel”, “Guest returned to hotel room”.</p>
<p><img src="/images/event-modeling/understand_large.jpg" alt="understand"></p>
<p>Often, translations are simple enough to represent as views that get their information from external events. If we don’t use them as any “Given” parts of tests, the values they store in that view model are simply represented in the command parameters in our state change tests.</p>
<h3 id="Automation"><a href="#Automation" class="headerlink" title="Automation"></a>Automation</h3><p>Our system is going to need to communicate with external services. When the guests in our hotel are paying for their stay when they check out, our system makes a call to a payment processor. We can make the concept of how this occurs with the idea of a “todo list” for some processor in our system. This todo list shows tasks we need to complete. Our processor goes through that list from time to time (could be milliseconds or days) and sends out a command to the external system to process the payment, as an example. The reply from the external system is then translated into an event that we store back in our system. This way we keep the building blocks that we use in our system as something that’s meaningful to us.</p>
<p><img src="/images/event-modeling/automate_large.jpg" alt="automate"></p>
<p>We show this by putting a processor in the top of our blueprint which has the wireframes. This shows that there are things not evident on the screen but are happening behind the scenes. A user may expect a spinning icon to indicate a delay due to background tasks needing to finish. The specification for this has the form of “<strong>Given</strong>: A view of the tasks to do, <strong>When</strong> This command is launched for each item, <strong>Then</strong> These events are expected back.”</p>
<p>In reality, these may be implemented in many different ways such as queues, reactive or real-time constructs. They may even actually be manual todo lists that our employees use. The goal here is to communicate how our system communicates with the outside world when it needs to affect it. </p>
<h2 id="Workshop-Format-The-7-Steps"><a href="#Workshop-Format-The-7-Steps" class="headerlink" title="Workshop Format - The 7 Steps"></a>Workshop Format - The 7 Steps</h2><p>Event Modeling is done in 7 steps. We explained the end-goal already. So let’s rewind to the beginning and show how to build up to the blueprint:</p>
<h3 id="1-Brain-Storming"><a href="#1-Brain-Storming" class="headerlink" title="1. Brain Storming"></a>1. Brain Storming</h3><p><img src="/images/event-modeling/Step-1_large.jpg" alt="Step 1"></p>
<p>We have someone explain the goals of the project and other information. The participants then envision what system would look and behave like. They put down all the events that they can conceive of having happened. Here we gently introduce the concept that only state-changing events are to be specified. Often, people will name “guest viewed calendar for room availability”. We put those aside for now - they are not events.</p>
<h3 id="2-The-Plot"><a href="#2-The-Plot" class="headerlink" title="2. The Plot"></a>2. The Plot</h3><p><img src="/images/event-modeling/Step-2_large.jpg" alt="Step 2"></p>
<p>Now the task is to create a plausible story made of these events. So they are arranged in a line and everyone reviews this time line to understand that this makes sense as events that happen in order.</p>
<h3 id="3-The-Story-Board"><a href="#3-The-Story-Board" class="headerlink" title="3. The Story Board"></a>3. The Story Board</h3><p><img src="/images/event-modeling/Step-3_large.jpg" alt="Step 3"></p>
<p>Next, the wireframes or mockups of the story are needed to address those that are visual learners. More importantly, each field must be represented so that the blueprint for the system has the source of and destination of the information represented from the user’s perspective.</p>
<h4 id="3-1-UX-Concurrency"><a href="#3-1-UX-Concurrency" class="headerlink" title="3.1 UX Concurrency"></a>3.1 UX Concurrency</h4><p>The wireframes are generally put at the top of the blueprint. They can be divided into separate swimlanes to show what each user sees if there is more than one. There are no screens that appear above one another as we need to capture each change in the system state as a separate vertical slice of the blueprint. The different ordering can be shown in the various specifications. If it is core to the system or very important to communicate, alternate workflows will need to be added to the blueprint. This is part of the last step that shows organization but can be done earlier if helpful.</p>
<h3 id="4-Identify-Inputs"><a href="#4-Identify-Inputs" class="headerlink" title="4. Identify Inputs"></a>4. Identify Inputs</h3><p><img src="/images/event-modeling/Step-4_large.jpg" alt="Step 4"></p>
<p>From the earlier section we saw that we need to show how we enable the user to change the state of the system. This is usually the step in which we do this introduction of these blue boxes. Each time an event is stored due to a users action, we link that to the UI by a command that shows what we are getting from the screen or implicitly from client state if it’s a web application.</p>
<h3 id="5-Identify-Outputs"><a href="#5-Identify-Outputs" class="headerlink" title="5. Identify Outputs"></a>5. Identify Outputs</h3><p><img src="/images/event-modeling/Step-5_large.jpg" alt="Step 5"></p>
<p>Again looking back at our goals for the blueprint, we now have to link information accumulated by storing events back into the UI via views (aka read-models). These may be things like the calendar view in our hotel system that will show the availability of rooms when a user is looking to book a room. </p>
<h3 id="6-Apply-Conway’s-Law"><a href="#6-Apply-Conway’s-Law" class="headerlink" title="6. Apply Conway’s Law"></a>6. Apply Conway’s Law</h3><p><img src="/images/event-modeling/Step-6_large.jpg" alt="Step 6"></p>
<p>Now that we know how information gets in and out of our system, we can start to look at organizing the events themselves into swimlanes. We need to do this to allow the system to exist as a set of autonomous parts that separate teams can own. This allows specialization to happen to a level that we control instead of falling out of the composition of teams. See <a target="_blank" rel="noopener" href="http://melconway.com/Home/Conways_Law.html">Conway’s Law</a> by Mel Conway.</p>
<h3 id="7-Elaborate-Scenarios"><a href="#7-Elaborate-Scenarios" class="headerlink" title="7. Elaborate Scenarios"></a>7. Elaborate Scenarios</h3><p>Each workflow step is tied to either a command or a view&#x2F;read-model. The specifications were explained earlier on. How we make them is still collaboratively with all participants in the same space. A Give-When-Then or Given-Then can be constructed one after the other very rapidly while being reviewed by multiple role representatives. This allows what is traditionally done as user story writing by a dedicated product owner in isolation in a text format, to be done visually in a very small amount of time collaboratively. What’s very critical here, is that each specification is tied to exactly one command or view.</p>
<h3 id="Completeness-Check"><a href="#Completeness-Check" class="headerlink" title="Completeness Check"></a>Completeness Check</h3><p>At this time the event model should have every field accounted for. All information has to have an origin and a destination. Events must facilitate this transition and hold the necessary fields to do so. This rigor is what is required to get the most benefits of the technique.</p>
<p>A variation of this is where we don’t do this final check and rely on absorbing the rework costs. There are scenarios where this is desired.</p>
<h2 id="Project-Management"><a href="#Project-Management" class="headerlink" title="Project Management"></a>Project Management</h2><p>The final output of the exercise if done to completion is a set of very small projects defined by all the scenarios for each workflow step. They are in a format that allows them to be directly translated to what developers will use to make their unit tests. They are also coupled to the adjacent workflow steps by only the contract.</p>
<p><img src="/images/event-modeling/parallel_large.jpg" alt="parallel effort"></p>
<h3 id="Strong-Contracts"><a href="#Strong-Contracts" class="headerlink" title="Strong Contracts"></a>Strong Contracts</h3><p>Many project management, business and coordination issues are mitigated by the fact that we have made explicit contracts as to the shape of the information of when we start a particular step of the workflow and what is the shape of the data when it’s finished. These pre- and post-conditions are what allows the work to be completed in relative isolation and later snap together with the adjoining steps as designed.</p>
<h4 id="Flat-Cost-Curve"><a href="#Flat-Cost-Curve" class="headerlink" title="Flat Cost Curve"></a>Flat Cost Curve</h4><p>The biggest impact of using Event Modeling is the flat cost curve of the average feature cost. This is due to the fact that the effort of building each workflow step is not impacted by the development of other workflows. One important thing to understand, is that a workflow step is considered to be repeated on the event model if it uses the same command or view. </p>
<p><img src="/images/event-modeling/flat-cost-curve.jpg" alt="flat cost curve"></p>
<p>The impact of this is very far reaching because it is what changes software development back into an engineering practice. It’s what makes creating an information system work like the construction of a house. Features can be created in any order. Traditional development cannot rely on estimates because whether the feature gets developed early on versus later in the project impacts the amount of work required. Reprioritizing work makes any previous estimates unreliable.</p>
<h4 id="Done-is-Done-Done-Right"><a href="#Done-is-Done-Done-Right" class="headerlink" title="Done is Done Done Right"></a>Done is Done Done Right</h4><p>When a workflow step is implemented, the act of implementing any other workflow step does not cause the need to revisit this already complete workflow step. It’s the reason that the constant feature cost curve can be realized.</p>
<h4 id="Estimates-without-Estimating"><a href="#Estimates-without-Estimating" class="headerlink" title="Estimates without Estimating"></a>Estimates without Estimating</h4><p>With a constant cost curve, the effort for an organization to implement can simply be measured over many features over time. This is an impartial way to empirically determine the velocity of teams. These numbers are then used to scope, schedule and cost out future projects.</p>
<h5 id="Technical-Side-Note-About-Test-Driven-Development"><a href="#Technical-Side-Note-About-Test-Driven-Development" class="headerlink" title="Technical Side-Note About Test Driven Development"></a>Technical Side-Note About Test Driven Development</h5><p>This is the impact of the adoption of Agile practices in the industry to put band-aids over the core issue of lack of design. Because the scope of each set of requirements is now per workflow step, the refactoring step of TDD does not impact other workflow steps in the event model. When we don’t have an event model, refactoring goes unrestricted and previously completed pieces of work have to be adjusted. The more work is already completed, the more that has to be reviewed and adjusted with each new addition as we build the solution.</p>
<h4 id="Subcontracting"><a href="#Subcontracting" class="headerlink" title="Subcontracting"></a>Subcontracting</h4><p>The constant cost curve gives the opportunity to do fixed-cost projects. Once there is a velocity established for a team, you have the cost of the software for your organization. With this number, you now can price out what you are willing to give contractors in pay for each workflow step they complete.</p>
<h5 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h5><p>Since each workflow step is protected from being affected by other workflow steps, any deficiencies are to be guaranteed by who is delivering them with non-billable work. So in the case of a subcontractor doing a bad job just to get more billable items done quickly, they will have to have the next hours of work dedicated to fixing deficiencies of work already done before. This evens out their effective rate of pay because they are not working on new delivarables.</p>
<p>This can be carried out over longer periods within an employee engagement by making these metrics available through different checkpoints for performance.</p>
<p>Due to the effective pay self-adjusting to the capability of the individual, it is also a way to on-board new employees and pay them fairly while they are in the probation stage of the engagement. This contract-to-hire process removes the subjective and largely ineffective interview process for technical positions.</p>
<h4 id="Prioritization"><a href="#Prioritization" class="headerlink" title="Prioritization"></a>Prioritization</h4><p>Moving work on a schedule as to what steps are going to be implemented first is done without changing the estimated costs of each item. This ensures that prioritization of work has no impact in the total cost also. The constant cost curve is required to allow this “agility” of reprioritizing features.</p>
<h4 id="Change-Management"><a href="#Change-Management" class="headerlink" title="Change Management"></a>Change Management</h4><p>When the plans change, we simply adjust the event model. This is usually done by just copying the current one and adjusting. Now we can see where the differences are. If a new piece of information is added to one event, that constitutes a new version of the workflow that creates it. Same with the views. If these have not been implemented yet, they don’t change our estimate. If they are already implemented, they add another unit of work to our plan because it’s considered a replacement. There are a few more rules around this. The end result is a definitive guide for change management.</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p><img src="/images/event-modeling/arrows_large.jpg" alt="security arrows"></p>
<p>With an event model, the solution shows exactly where, and equally importantly, when sensitive data crosses boundaries. With traditional audits, the number of interviews with staff was time consuming and at risk of missing important areas. Security concerns are addressed most responsibly when the applications have an event model to reference.</p>
<h2 id="Legacy-Systems"><a href="#Legacy-Systems" class="headerlink" title="Legacy Systems"></a>Legacy Systems</h2><p>Most of the scenarios that real organizations face is where a system is already in place. The main way to deal with a system that is hard to manage because of complexity and lack of understanding is to either rewrite it or to refactor it while it runs. Both of these are very costly.</p>
<p>A third, less risky option exists: Freeze the old system. With proper buy-in, the organization can agree to not alter the existing system. Instead, dealing with bugs and adding new functionality is done on the side as a side-car solution.</p>
<p>Events can be gathered from the database of the old system and make views of that state - employing the <a href="#translation">translate</a> pattern described previously. Y-valve redirection of user action can add new functionality in the side solution. An example which fixes a bug (notice that we use the <a href="./#automation">external integration pattern</a> and extends the old system to add profile pictures is shown here:</p>
<p><img src="/images/event-modeling/event-modeling-legacy-side-car.jpg" alt="legacy side car event model"></p>
<p>This pattern allows an organization to stop putting energy into the sub-optimal existing system and get unblocked from delivering value via the patterns that enable the benefits of the Event Model.</p>
<h2 id="Conclusion-for-Now"><a href="#Conclusion-for-Now" class="headerlink" title="Conclusion for Now"></a>Conclusion for Now</h2><p>Event Modeling is changing how information systems are built. With simple repeatable patterns, information systems are as predicable as engineering efforts should be.</p>
<h2 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h2><p>This content reprinted from <a target="_blank" rel="noopener" href="https://eventmodeling.org/posts/what-is-event-modeling/">Event Modeling: What is it?</a></p>
<p>Thanks.</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/9/cover.png" alt="\#9\ 一般树与树节点遍历"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1775个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/">\#9\ 一般树与树节点遍历</a></h1><div class="content"><p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p>
<ul>
<li>等级关系的描述</li>
<li>分类数据的管理</li>
<li>分类查找操作</li>
</ul>
<p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>类似链表，树也是由节点构成的。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/node.png"></p>
<p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p>
<h3 id="父节点和子节点"><a href="#父节点和子节点" class="headerlink" title="父节点和子节点"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p>
<p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png"></p>
<h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/root.png"></p>
<h3 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png"></p>
<h2 id="Swift树结构实现"><a href="#Swift树结构实现" class="headerlink" title="Swift树结构实现"></a>Swift树结构实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">TreeNode</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p>
<p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节点添加新的子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">child</span>: <span class="type">TreeNode</span>) &#123;</span><br><span class="line">    children.append(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time to give it a whirl.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Create a tree&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> beverages <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    beverages.add(hot)</span><br><span class="line">    beverages.add(cold)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(beverages.value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">0</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">1</span>].value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Create a tree---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">Hot</span></span><br><span class="line"><span class="comment">Cold</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png"></p>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png"></p>
<p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png"></p>
<p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachDepthFirst</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.forEachDepthFirst(visit: visit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeBeverageTree</span>() -&gt; <span class="type">TreeNode</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> coffee <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chocolate <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> blackTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> greenTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chaiTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> soda <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;sida&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> milk <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> gingerAle <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bitterLemon <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    </span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    </span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    </span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    </span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该树的形态如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png"></p>
<p>接下来在这棵树上测试深度优先遍历。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;depth-first traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of depth-first traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachLevelOrder</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&gt;()</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            queue.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst() &#123;</span><br><span class="line">            visit(node)</span><br><span class="line">            node.children.forEach &#123;</span><br><span class="line">                queue.append(<span class="variable">$0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;level-order traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachLevelOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of level-order traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">search</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">TreeNode</span>?</span><br><span class="line">        forEachLevelOrder &#123; node <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">                result <span class="operator">=</span> node</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;searching for a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult1 <span class="operator">=</span> tree.search(<span class="string">&quot;ginger ale&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found node: <span class="subst">\(searchResult1.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult2 <span class="operator">=</span> tree.search(<span class="string">&quot;WKD Blue&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(searchResult2.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of searching for a node---</span></span><br><span class="line"><span class="comment">Found node: ginger ale</span></span><br><span class="line"><span class="comment">Couldn&#x27;t find WKD Blue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li>
<li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li>
<li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li>
</ul>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png"></p>
<p>打印的结果应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 </span><br><span class="line">1 17 20 </span><br><span class="line">1 5 0 2 5 7</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printEachLevel</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">tree</span>: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    queue.append(tree)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>queue.isEmpty &#123;</span><br><span class="line">        nodesLeftInCurrentLevel <span class="operator">=</span> queue.count</span><br><span class="line">        <span class="keyword">while</span> nodesLeftInCurrentLevel <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst()  <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(node.value)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">            node.children.forEach &#123; queue.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">            nodesLeftInCurrentLevel <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/13/cover.jpg" alt="\#13\ 字典树（Tries Tree）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">19 分钟读完 (大约2865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/">\#13\ 字典树（Tries Tree）</a></h1><div class="content"><p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>例如利用Tries表示一个英语单词，可以表示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png"></p>
<p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> words: [<span class="type">String</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">words</span>(<span class="params">matching</span> <span class="params">prefix</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> words.filter &#123; <span class="variable">$0</span>.hasPrefix(<span class="keyword">prefix</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p>
<p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p>
<p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p>
<p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png"></p>
<p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p>
<p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png"></p>
<p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png"></p>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p>
<h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Key</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> parent: <span class="type">TrieNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">Key</span>: <span class="type">TrieNode</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">key</span>: <span class="type">Key</span>?, <span class="params">parent</span>: <span class="type">TrieNode</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tries的节点结构和其他树型数据结构有明显的不同。</p>
<ul>
<li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li>
<li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li>
<li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li>
<li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li>
</ul>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&lt;<span class="title class_">CollectionType</span>: <span class="title class_">Collection</span>&gt; <span class="title class_">where</span> <span class="title class_">CollectionType</span>.<span class="title class_">Element</span>: <span class="title class_">Hashable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> <span class="operator">=</span> <span class="type">TrieNode</span>&lt;<span class="type">CollectionType</span>.<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> root <span class="operator">=</span> <span class="type">Node</span>(key: <span class="literal">nil</span>, parent: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p>
<p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p>
<h2 id="操作算法实现"><a href="#操作算法实现" class="headerlink" title="操作算法实现"></a>操作算法实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[element] <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[element] <span class="operator">=</span> <span class="type">Node</span>(key: element, parent: current)</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> current.children[element]<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    current.isTerminating <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li>
<li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li>
<li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p>
<h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isTerminating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p>
<p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insert and contains&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> trie.contains(<span class="string">&quot;cute&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cute is in the trie&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insert and contains---</span></span><br><span class="line"><span class="comment">cute is in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> current.isTerminating <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent <span class="operator">=</span> current.parent, current.children.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>current.isTerminating &#123;</span><br><span class="line">            parent.children[current.key<span class="operator">!</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            current <span class="operator">=</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li>
<li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li>
<li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** Before removeing ***&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cut<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** After removing cut ***&quot;</span>)</span><br><span class="line">    trie.remove(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is still in the trie&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of remove---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Before removeing ***</span></span><br><span class="line"><span class="comment">&quot;cut&quot; is in the trie</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is in the trie</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** After removing cut ***</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is still in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Prefix-matching"><a href="#Prefix-matching" class="headerlink" title="Prefix matching"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> <span class="title class_">where</span> <span class="title class_">CollectionType</span>: <span class="title class_">RangeReplaceableCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">prefix</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> collections(startingWith: <span class="keyword">prefix</span>, after: current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li>
<li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">CollectionType</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.isTerminating &#123;</span><br><span class="line">        results.append(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children.values &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">        <span class="keyword">prefix</span>.append(child.key<span class="operator">!</span>)</span><br><span class="line">        results.append(contentsOf: collections(startingWith: <span class="keyword">prefix</span>, after: child))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li>
<li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li>
</ul>
<p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p>
<p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;prefix matching&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;car&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;card&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;care&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cared&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cars&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carbs&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carapace&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cargo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>car<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCar <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;car&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCar)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>care<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCare <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;care&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of prefix matching---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;car&quot;</span></span><br><span class="line"><span class="comment">[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;care&quot;</span></span><br><span class="line"><span class="comment">[&quot;care&quot;, &quot;cared&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>Trie树在前缀匹配上有着卓越的性能表现；</li>
<li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/19/cover.jpg" alt="\#19\ 基数排序（Radix Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">9 分钟读完 (大约1354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/">\#19\ 基数排序（Radix Sort）</a></h1><div class="content"><p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p>
<p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>基数排序依赖于整数的位置表示法，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png"></p>
<p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png"></p>
<p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">410</span>, <span class="number">20</span>, <span class="number">1772</span>, <span class="number">88</span>]</span><br></pre></td></tr></table></figure>

<p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png"></p>
<p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p>
<p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png"></p>
<p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>最后，在堆集合中的元素进行千位拆解：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png"></p>
<p>重新按照千位拆解结果进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">radixSort</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> base <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> digits <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>done &#123;</span><br><span class="line">            <span class="comment">// more to come</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p>
<ol>
<li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li>
<li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li>
</ol>
<p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p>
<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buckets: [[<span class="type">Int</span>]] <span class="operator">=</span> .<span class="keyword">init</span>(repeating: [], count: base)</span><br><span class="line">            </span><br><span class="line">forEach &#123;</span><br><span class="line">    number <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> remainingPart <span class="operator">=</span> number <span class="operator">/</span> digits</span><br><span class="line">    <span class="keyword">let</span> digit <span class="operator">=</span> remainingPart <span class="operator">%</span> base</span><br><span class="line">    buckets[digit].append(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digits <span class="operator">*=</span> base</span><br><span class="line"><span class="keyword">self</span> <span class="operator">=</span> buckets.flatMap &#123; <span class="variable">$0</span> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li>
<li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li>
<li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li>
</ol>
<p><strong>循环何时结束？</strong></p>
<p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p>
<ol>
<li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li>
<li>在forEach闭包结构中，增加如下语句：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remainingPart <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;radix sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    array.radixSort()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Radix sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of radix sort---</span></span><br><span class="line"><span class="comment">Original: [88, 410, 1772, 20]</span></span><br><span class="line"><span class="comment">Radix sorted: [20, 88, 410, 1772]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p>
<p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p>
</li>
<li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p>
</li>
<li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/"><img class="fill" src="/images/keras-mnist-for-ios/cover.jpg" alt="从Keras开始构建iOS平台手写数字实时识别"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">36 分钟读完 (大约5406个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/">从Keras开始构建iOS平台手写数字实时识别</a></h1><div class="content"><p>本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。</p>
<h1 id="10步之内完成模型的构建、训练和发布使用"><a href="#10步之内完成模型的构建、训练和发布使用" class="headerlink" title="10步之内完成模型的构建、训练和发布使用"></a><strong>10步之内完成模型的构建、训练和发布使用</strong></h1><p><strong>TLDR；</strong></p>
<p>本文中暂时不会介绍卷积神经网络的细节内容，例如如何使用卷积层、池化层训练深度学习网络，以及如何使用预训练模型识别目标等，相关卷积神经网络细节的内容将会放在本文内容之后，进行详细的介绍。本文旨在介绍如何一步一步的从数据的获取、整理、模型的构建、训练以及后面的格式转换、使用等介绍Keras框架的基本使用和如何使用CoreML体系在一个实实在在的应用程序中使用模型等。</p>
<p>下图是最终结果的预览：</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<p>接下来，开始一步步的实现相关的过程等。</p>
<h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1. 如何开始"></a>1. <strong>如何开始</strong></h2><p>To have a fully working example I thought we’d start with a toy dataset like the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST set of handwritten letters</a> and train a deep learning network to recognize those. Once it’s working nicely on our PC, we will port it to an iPhone X using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">CoreML standard</a>.</p>
<p>在计算机程序设计学习的过程中，几乎都是以一个经典的“Hello World”程序开始的。而在机器学习领域，同样具有类似“Hello World”的一个经典入门级数据集——<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST</a>，该数据集是一系列手写数字0到9的图片文件，这里的目的是使用这个数据集训练一个深度学习网络来识别它们。在开始之前，你或许对iOS平台的CoreML以及keras还很陌生，你可以先了解一下它们的体系和设计：</p>
<ul>
<li>CoreML：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">Core ML | Apple Developer Documentation</a></p>
<ul>
<li>Keras：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://keras.io/zh/">Keras 中文文档</a></p>
<h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>在大多数的Python机器学习类库中，都有内置的数据集访问接口，以方便使用者的使用，在Keras中也不例外，可以很方便的使用其内置的数据集访问接口获取数据集，具体的接口定义在<code>keras.datasets</code>中，具体的使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Keras内置数据集访问接口导入数据集并对数据集进行转换</span></span><br><span class="line">    <span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">    <span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line">    <span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mnist_data</span>():</span><br><span class="line">        <span class="comment"># 定义输入图像的维度</span></span><br><span class="line">        img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line">        <span class="comment"># 加载数据集</span></span><br><span class="line">        (X_train, Y_train), (X_test, Y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 数据缩放，将原来的 [0, 255] 缩放至 [0, 1]</span></span><br><span class="line">        X_train = X_train.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">        X_test = X_test.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 对原始数据中的目标值进行One-Hot Encoding，使得目标数据更加的稀疏</span></span><br><span class="line">        Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">        Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> (X_train, Y_train), (X_test, Y_test), input_shape</span><br><span class="line">    </span><br><span class="line">    (X_train, Y_train), (X_test, Y_test), input_shape = mnist_data()</span><br></pre></td></tr></table></figure>

<h2 id="3-正确地编码"><a href="#3-正确地编码" class="headerlink" title="3. 正确地编码"></a>3. 正确地编码</h2><p>当处理图片数据的时候，必须要区分想要的编码方式。Keras是一个可以处理多个“后端”的高级库，例如<a target="_blank" rel="noopener" href="https://www.tensorflow.org/">Tensorflow</a>, <a target="_blank" rel="noopener" href="http://deeplearning.net/software/theano/">Theano</a> 和 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/cognitive-toolkit/">CNTK</a>，首先我们要了解我们所使用的后端是如何编码数据的。在Keras默认使用的TensorFlow后端中，针对图像的处理通常是以“通道优先”或“通道末尾”的方式进行编码的，因此在我们的使用TensorFlow作为后端的时候，编码结果其实是一个张量，其形状为(batch_size, rows, cols, channels)。意味着首先是输入的batch_size，然后输入28行28列的图像维度，最后输入1作为通道数，因为我们使用的是灰度图像数据。</p>
<p>我们可以看看前6张图像具体是什么样子，可以使用如下代码查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化数据集中前6张图像</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    %matplotlib inline</span><br><span class="line">    <span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line">    (X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">6</span>, i+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        ax.imshow(X_train[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="built_in">str</span>(y_train[i]))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://liip.rokka.io/www_inarticle/7cce04/numbers.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-规范化数据"><a href="#4-规范化数据" class="headerlink" title="4. 规范化数据"></a>4. 规范化数据</h2><p>可以看到，在黑色背景中显示了白色数字，每一张图像中的数字都是居中的，而且分辨率都很低——在这个例子中我们使用的是28x28像素。</p>
<p>你可能已经注意到，在上述获取数据的部分，我们对每一张图片除以255来缩放了图像像素，这导致像素值在0和1之间，这对于任何类型的训练都非常有用。每个图像像素值在转换之前都是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用像素值可视化一个数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_input</span>(<span class="params">img, ax</span>):</span><br><span class="line">    ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    width, height = img.shape</span><br><span class="line">    thresh = img.<span class="built_in">max</span>()/<span class="number">2.5</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            ax.annotate(<span class="built_in">str</span>(<span class="built_in">round</span>(img[x][y], <span class="number">2</span>)),</span><br><span class="line">                        xy=(y, x),</span><br><span class="line">                        horizontalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        verticalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        color=<span class="string">&#x27;white&#x27;</span> <span class="keyword">if</span> img[x][y] &lt; thresh <span class="keyword">else</span> <span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">visualize_input(X_train[<span class="number">0</span>], ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/keras-mnist-for-ios/pixes-daf69647-717f-499d-aa39-fa83904d7675.png"></p>
<p>可以看到图像中的每个灰度像素都是介于0到255之间的，并且当像素为255时，背景色为白色，像素为0时，背景色为黑色。在这里使用的是<code>mnist.load_data()</code>加载的数据集，此时并没有对图像进行像素缩放，而在我们自定义的数据集加载方法<code>mnist_data()</code>方法中，我们进行了像素的缩放，<code>X_train = X_train.astype(&#39;float32&#39;)/255</code> 。</p>
<h2 id="5-One-Hot-编码"><a href="#5-One-Hot-编码" class="headerlink" title="5. One-Hot 编码"></a>5. One-Hot 编码</h2><p>最初，数据以Y-Vector包含X Vector（像素数据）包含的数值的方式编码。例如，如果图像看起来像7，那么Y-Vector中必定包含数字7。但是这种方式不利于我们在网络结构中直接使用，我们需要进行这种转换，希望将数据的输出映射到网络中的10个输出神经元，此时当相应的数字被识别时，相应的神经元就会触发，从而达到有效的识别。</p>
<p><img src="https://liip.rokka.io/www_inarticle/46a2ef/onehot.png"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="6-网络模型化"><a href="#6-网络模型化" class="headerlink" title="6. 网络模型化"></a>6. 网络模型化</h2><p>了解了数据集的基本情况以及进行合理的数据转换后，该是定义卷积神经网络的时候了。这里讲直接使用卷积神经网络中的卷积层和池化层来定义网络，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义网络模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adadelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">network</span>():</span><br><span class="line">    model = Sequential()</span><br><span class="line">    input_shape = (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">500</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型概述</span></span><br><span class="line">    <span class="built_in">print</span>(model.summary())</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>在模型的定义中，我们以内核大小为3的<a target="_blank" rel="noopener" href="https://keras.io/layers/convolutional/">卷积</a>，这也意味着窗口为3x3像素，输入形状的大小为28x28像素。紧跟着使用了一个池化大小为2的<a target="_blank" rel="noopener" href="https://keras.io/layers/pooling/">池化层</a>，这里的池化大小为2，意味着将会对每一个输入缩减为原来的一般，因此在下一个卷积层中，输入大小为14x14像素。按照此方式重复两次后，最终的卷积输入大小转换为3x3像素。接下来，使用了<a target="_blank" rel="noopener" href="https://keras.io/layers/core/#dropout">Dropout层</a>，将30%的输入单元随机设置为0，以防止训练的过拟合。最后，展平输入层（此例子中为3x3x32&#x3D;288），并将它们连接到一个具有500个输入的密度层。在这些步骤之后，添加了另一个Dropout层，之后连接到最后的密度层，该密度层中包含10个输出单元，这些输出单元对应着我们的目标类别，0到9之间的数字。</p>
<pre><code>_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_1 (Conv2D)            (None, 28, 28, 32)        320       
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 14, 14, 32)        0         
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 14, 14, 32)        4128      
_________________________________________________________________
max_pooling2d_2 (MaxPooling2 (None, 7, 7, 32)          0         
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 7, 7, 32)          4128      
_________________________________________________________________
max_pooling2d_3 (MaxPooling2 (None, 3, 3, 32)          0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 3, 3, 32)          0         
_________________________________________________________________
flatten_1 (Flatten)          (None, 288)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 500)               144500    
_________________________________________________________________
dropout_2 (Dropout)          (None, 500)               0         
_________________________________________________________________
dense_2 (Dense)              (None, 10)                5010      
=================================================================
Total params: 158,086
Trainable params: 158,086
Non-trainable params: 0
_________________________________________________________________
</code></pre>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7. 训练模型"></a>7. 训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = network()</span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=Adadelta(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用训练数据拟合模型</span></span><br><span class="line">model.fit(X_train, Y_train, batch_size=<span class="number">512</span>, epochs=<span class="number">6</span>, verbose=<span class="number">1</span>, validation_data=(X_test, Y_test))</span><br><span class="line"><span class="comment"># 模型评估分数</span></span><br><span class="line">score = model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>categorical_crossentropy</code>作为损失函数，因为我们的目标类别有多个（0至9），Keras库提供了多种<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#usage-of-optimizers">优化器</a>，你可以选择任意一个进行模型训练，并最终找到一个最好的。经过尝试之后，这里选择<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adadelta"><code>AdaDelta</code></a>作为优化器进行模型训练，当然你也可以尝试AdaDelta的高级版<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adagrad">AdaGrad</a>。</p>
<p><img src="https://liip.rokka.io/www_inarticle/42b4b8/train.png"></p>
<p>可以看到，经过训练，所得到的模型识别准确率达到了98%，考虑到这里仅仅使用了简单的网络结构，达到这样的准确率已经是非常出色了。在上述截图中，每次迭代的准确性都是在提高，可以说明这里使用的简单结构是合理的，训练得到的模型可以很好地预测输入28x28像素所表示的数字。</p>
<h2 id="8-保存模型"><a href="#8-保存模型" class="headerlink" title="8. 保存模型"></a>8. 保存模型</h2><p>由于我们想要在iOS设备上使用该模型，因此需要将该模型转换为iOS系统能够理解的格式。实际上，微软、Facebook以及亚马逊等企业已经研发出了一套能够在所有深度学习网络格式见转换的协议，以便能够在任何设备上使用的可交换的开放式神经网络交换格式——<a target="_blank" rel="noopener" href="https://onnx.ai/">ONNX</a>。</p>
<p>但是，截止目前，Apple设备上仅仅能够使用的是CoreML格式。为了能够将Keras模型转换为CoreML格式，Apple特意推出来一个非常方便的帮助类库——<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">coremltools</a>，这里我们就可以使用该类库来完成工作。该类库能够将scikit-learn、Keras、XGBoost等机器学习类库训练的模型转换为CoreML支持的格式，从而使得模型能够直接在Apple设备上使用。如果你还未安装coremltools类库，可以使用<code>pip install coremltools</code>进行安装，然后再使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coreml_model = coremltools.converters.keras.convert(model,</span><br><span class="line">                                                        input_names=<span class="string">&quot;image&quot;</span>,</span><br><span class="line">                                                        image_input_names=<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">                                                        class_labels=[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">                                                        )</span><br></pre></td></tr></table></figure>

<p>在进行模型转换的时候，最重要的参数是class_labels，它定义了模型尝试预测的类数，以及input_names或者image_input_names。通过将它们设置为图像，Xcode会自动识别该模型是关于接收图像并从中预测某些内容，也就是说这些参数是告诉Xcode，该模型是关于那方面的任务。根据应用程序和模型的特定功能，需要研究<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">官方文档</a>进一步的了解这些参数的可选值等。</p>
<p>另外还有一些可以定义模型元信息的参数，这些参数可以给模型一个简要的说明，甚至作者、license等，可以让使用者能够方便的查阅模型所针对的特定任务等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑模型元信息</span></span><br><span class="line">coreml_model.author = <span class="string">&#x27;Robin&#x27;</span></span><br><span class="line">coreml_model.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">coreml_model.short_description = <span class="string">&#x27;MNIST handwriting recognition with a 3 layer network&#x27;</span></span><br><span class="line">coreml_model.input_description[<span class="string">&#x27;image&#x27;</span>] = <span class="string">&#x27;28x28 grayscaled pixel values between 0-1&#x27;</span></span><br><span class="line">coreml_model.save(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coreml_model)</span><br></pre></td></tr></table></figure>

<h2 id="9-使用模型预测"><a href="#9-使用模型预测" class="headerlink" title="9. 使用模型预测"></a>9. 使用模型预测</h2><p>在将模型保存为CoreML格式之后，我们可以尝试使用转换后的模型进行一个预测，来确定模型是否工作正常。在这里我们将从MNIST数据集中选择一张图像进行预测验证。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用CoreML模型预测验证</span></span><br><span class="line"> <span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> model =  coremltools.models.MLModel(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"> im = Image.fromarray((np.reshape(mnist_data()[<span class="number">0</span>][<span class="number">0</span>][<span class="number">12</span>]*<span class="number">255</span>, (<span class="number">28</span>, <span class="number">28</span>))).astype(np.uint8),<span class="string">&quot;L&quot;</span>)</span><br><span class="line"> plt.imshow(im)</span><br><span class="line"> predictions = model.predict(&#123;<span class="string">&#x27;image&#x27;</span>: im&#125;)</span><br><span class="line"> <span class="built_in">print</span>(predictions)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<pre><code>&#123;u&#39;classLabel&#39;: u&#39;3&#39;, 
u&#39;output1&#39;: &#123;u&#39;1&#39;: 0.0, 
                        u&#39;0&#39;: 0.0, 
                        u&#39;3&#39;: 1.0, 
                        u&#39;2&#39;: 0.0, 
                        u&#39;5&#39;: 0.0, 
                        u&#39;4&#39;: 0.0, 
                        u&#39;7&#39;: 0.0, 
                        u&#39;6&#39;: 0.0, 
                        u&#39;9&#39;: 0.0, 
                        u&#39;8&#39;: 0.0
                        &#125;
&#125;
</code></pre>
<p><img src="/images/keras-mnist-for-ios/download-45f07bef-9ca6-4ea6-a674-789607207e9c.png"></p>
<p>可以看到，预测过程和结果均符合预期。接下来是时候在Xcode项目中使用该模型了。</p>
<h1 id="10步完成模型在Xcode项目中的应用"><a href="#10步完成模型在Xcode项目中的应用" class="headerlink" title="10步完成模型在Xcode项目中的应用"></a>10步完成模型在Xcode项目中的应用</h1><p>为了能够让几乎所有人了解机器学习模型文件是如何一步一步在Xcode项目中使用的，这里将会从最为基础的Xcode安装、项目创建等说起，如果你是iOS开发的老鸟，部分内容请自行略过。</p>
<h2 id="1-安装Xcode"><a href="#1-安装Xcode" class="headerlink" title="1. 安装Xcode"></a>1. 安装Xcode</h2><p>对于iOS体系来说，Xcode是开发iOS应用程序必须的工具之一，因此如果你还未安装Xcode，需要安装Xcode，最为简单的方式是在Mac App Store中搜索并安装。如果你已经安装了Xcode，需要确保Xcode的版本至少在9.0或以上。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>安装好Xcode之后，开启Xcode，选择iOS平台下的单视图应用，命名项目，这里命名为“MNIST-Demo”，选择一个保存项目文件的位置，创建项目即可。</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-78fa75ca-4376-49e8-b194-bde1699f9be3.png"></p>
<h2 id="3-添加CoreML模型文件"><a href="#3-添加CoreML模型文件" class="headerlink" title="3. 添加CoreML模型文件"></a>3. 添加CoreML模型文件</h2><p>现在，你可以将通过coremltools转换得到的CoreML模型加入到项目中了。最简单的方式是直接拖拽模型文件到项目目录中，如果为了之后更新模型而不用去删掉重新添加，你可以在弹出的选项框中选择“add as Reference”。</p>
<p><img src="/images/keras-mnist-for-ios/add-model-98101cf6-8cf8-4d2a-b58e-30d397c98354.png"></p>
<h2 id="4-删除不需要的视图或者故事版"><a href="#4-删除不需要的视图或者故事版" class="headerlink" title="4. 删除不需要的视图或者故事版"></a>4. 删除不需要的视图或者故事版</h2><p>因为我们仅仅使用相机并显示标签，因此这里会删除掉项目中默认的一些用户界面，也就是项目中的视图控制器和故事面板。当然你也可以选择不删除，直接使用现有的视图和故事面板进行开发，不论选择哪种方式都能达到目的。这里要注意的是，如果选择编码的方式构建应用，再删除了主故事面板文件后，需要在项目的TARGETS中同步删除”Main Interface”的默认设置。</p>
<p><img src="/images/keras-mnist-for-ios/ScreenShot2018-11-22at10-9150b677-f351-4732-bfb6-d74019527380.32.46AM.png"></p>
<h2 id="5-程序化创建根视图控制器"><a href="#5-程序化创建根视图控制器" class="headerlink" title="5. 程序化创建根视图控制器"></a>5. 程序化创建根视图控制器</h2><p>接下来我们将使用代码的方式，重新制定应用程序的根视图。具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码的方式指定根视图控制器</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     <span class="comment">// 创建窗口</span></span><br><span class="line">     window <span class="operator">=</span> <span class="type">UIWindow</span>()</span><br><span class="line">     window<span class="operator">?</span>.makeKeyAndVisible()</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// 指定根视图控制器</span></span><br><span class="line">     <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">ViewController</span>()</span><br><span class="line">     window<span class="operator">?</span>.rootViewController <span class="operator">=</span> vc</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构建视图控制器细节"><a href="#6-构建视图控制器细节" class="headerlink" title="6. 构建视图控制器细节"></a>6. 构建视图控制器细节</h2><p>接下来就是构建视图控制器的详细内容细节了。我们需要以下可交互的元素组件，例如按钮，也需要作为展示结果或者状态的标签等，另外重要的是，由于需要使用相机，因此AVFoundation类库是必须要添加的，该库用来访问和控制iOS设备上的相机，还需要Vision库，该库是iOS推出的用于计算机视觉相关任务的工具库，能够很好的和CoreML模型之间进行交互等。</p>
<p>具体的代码细节，这里不再累述，完成之后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义视图控制器</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> Vision</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要使用到相机设备进行视频流的输入，因此这里要继承AVCaptureVideoDataOutputSampleBufferDelegate协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">AVCaptureVideoDataOutputSampleBufferDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文本标签用来显示识别结果</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">UILabel</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.textColor <span class="operator">=</span> .white</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Label&quot;</span></span><br><span class="line">        label.font <span class="operator">=</span> label.font.withSize(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="comment">// 调用相机设备设置方法、文本标签设置方法</span></span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()       </span><br><span class="line">        setupCaptureSession()</span><br><span class="line">        view.addSubview(label)</span><br><span class="line">        setupLabel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相机设备session</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupCaptureSession</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的捕获session</span></span><br><span class="line">        <span class="keyword">let</span> captureSession <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找可用的相机设备</span></span><br><span class="line">        <span class="keyword">let</span> availableDevices <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.<span class="type">DiscoverySession</span>(deviceTypes: [.builtInWideAngleCamera], mediaType: <span class="type">AVMediaType</span>.video, position: .back).devices</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 选择首个设备并设置为输入源</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> captureDevice <span class="operator">=</span> availableDevices.first &#123;</span><br><span class="line">                captureSession.addInput(<span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: captureDevice))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未找到相机设备，则打印错误信息</span></span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将视频输出设置到屏幕并将输出添加到我们的捕获会话</span></span><br><span class="line">        <span class="keyword">let</span> captureOutput <span class="operator">=</span> <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">        captureSession.addOutput(captureOutput)</span><br><span class="line">        <span class="keyword">let</span> previewLayer <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>(session: captureSession)</span><br><span class="line">        previewLayer.frame <span class="operator">=</span> view.frame</span><br><span class="line">        view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲视频并启动捕获会话</span></span><br><span class="line">        captureOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;videoQueue&quot;</span>))</span><br><span class="line">        captureSession.startRunning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">captureOutput</span>(<span class="keyword">_</span> <span class="params">output</span>: <span class="type">AVCaptureOutput</span>, <span class="params">didOutput</span> <span class="params">sampleBuffer</span>: <span class="type">CMSampleBuffer</span>, <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载Core ML 模型</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">VNCoreMLModel</span>(for: <span class="type">SimpleMnist</span>().model) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Core ML运行推理</span></span><br><span class="line">        <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNCoreMLRequest</span>(model: model) &#123; (finishedRequest, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> results <span class="operator">=</span> finishedRequest.results <span class="keyword">as?</span> [<span class="type">VNClassificationObservation</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获得分最高的推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="type">Observation</span> <span class="operator">=</span> results.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建最终显示的文本格式</span></span><br><span class="line">            <span class="keyword">let</span> predclass <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(Observation.identifier)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示在文本标签内</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async(execute: &#123;</span><br><span class="line">                <span class="keyword">self</span>.label.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(predclass)</span> &quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建一个核心视频像素缓冲区，它是一个图像缓冲区，用于保存主存储器中的像素生成帧，</span></span><br><span class="line">                <span class="comment">// 压缩或解压缩视频或使用核心图像的应用程序都可以使用核心视频像素缓冲区</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> pixelBuffer: <span class="type">CVPixelBuffer</span> <span class="operator">=</span> <span class="type">CMSampleBufferGetImageBuffer</span>(sampleBuffer) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="keyword">try?</span> <span class="type">VNImageRequestHandler</span>(cvPixelBuffer: pixelBuffer, options: [:]).perform([request])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupLabel</span>() &#123;</span><br><span class="line">        label.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        label.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: <span class="operator">-</span><span class="number">50</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你直接使用上述代码，请记得修改模型的名称。</p>
</blockquote>
<p><img src="/images/keras-mnist-for-ios/Untitled-503351b4-b11a-4e7b-a7ad-de4017cbac28.png"></p>
<h2 id="6-添加隐私说明信息"><a href="#6-添加隐私说明信息" class="headerlink" title="6. 添加隐私说明信息"></a>6. 添加隐私说明信息</h2><p>由于我们要使用相机设备进行视频数据流的获取，因此需要在Xcode工程项目中的info.plist文件中添加相应的权限申请说明“<em>Privacy - Camera Usage Description</em>”，并附带相应的说明性文字：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-8e6fa826-e368-47d0-8256-588a136119db.png"></p>
<h2 id="7-加入苹果开发者计划"><a href="#7-加入苹果开发者计划" class="headerlink" title="7. 加入苹果开发者计划"></a>7. 加入苹果开发者计划</h2><p>为了能够让该应用程序运行在你的手机设备上，你可能需要注册<a target="_blank" rel="noopener" href="https://developer.apple.com/programs/enroll/">苹果的开发者计划</a>。当然如果你不想为了运行项目而花费金钱，你也可以按照<a target="_blank" rel="noopener" href="https://9to5mac.com/2016/03/27/how-to-create-free-apple-developer-account-sideload-apps/">此教程</a>注册免费的账户。</p>
<h2 id="8-在iPhone设备上发布应用"><a href="#8-在iPhone设备上发布应用" class="headerlink" title="8. 在iPhone设备上发布应用"></a>8. 在iPhone设备上发布应用</h2><p>一切准备好之后，你就可以将该应用程序发布到你的手机设备上了。你可以按照如下图所示的方式发布项目，也可以直接在Xcode中选定目标设备，然后使用快捷键CMD+R的方式构建：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-1a74e4bf-8c84-4e49-95f2-4b46f8f4102f.png"></p>
<h2 id="9-使用应用程序"><a href="#9-使用应用程序" class="headerlink" title="9. 使用应用程序"></a>9. 使用应用程序</h2><p>经过上述各种设置和编码之后，终于可以在设备上运行我们的应用程序了。如果一切正常，首次应用程序启动的时候，会询问你是否允许应用程序访问设备的相机，这里需要允许，否则我们的应用程序则无法正常工作。</p>
<p>另外，我们这里所训练的模型以及制作的应用程序，没有进行详细的设计和优化，在识别的过程中，可能会遇到识别不出来以及识别错误的情况，如果需要将此功能应用在你的产品中，需要严格重新审查你所拥有的数据，以及模型的训练，app的使用等，以免出现不可预知的错误等问题。</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，希望能够让你了解如何使用Keras训练所需要的模型，以及如何将其应用在iOS平台下的应用程序中，虽然介绍的不够深入，但是希望能够带给你继续深入理解Keras、了解Core ML的欲望，早日在你的应用程序中实现AI的能力，为你的应用程序增添色彩。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/6/cover.jpg" alt="\#6\ Linked List 挑战"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.106Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1703个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/">\#6\ Linked List 挑战</a></h1><div class="content"><p>本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。</p>
<h2 id="Challenge-1：创建按照反向顺序打印链表元素的函数。"><a href="#Challenge-1：创建按照反向顺序打印链表元素的函数。" class="headerlink" title="Challenge 1：创建按照反向顺序打印链表元素的函数。"></a>Challenge 1：创建按照反向顺序打印链表元素的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// outut</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 解决此问题最简单直接的方式就是使用<strong>递归</strong>。由于递归允许构建回调堆栈，因此我们可以在递归的回调中调用<strong>print</strong>打印节点元素值。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    printInReverse(node.next)</span><br><span class="line">    <span class="built_in">print</span>(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    printInReverse(list.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;printing in reverse&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverse(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of printing in reverse---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Printing in reverse: </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>该算法的核心在于递归调用的部分，当节点存在的情况下，继续遍历当前节点的下一个节点，否则就是已经到了末尾节点，在递归的过程回调堆栈中打印节点值。该算法时间复杂度为**O(n)**。</p>
<h2 id="Challenge-2：创建返回链表中间节点值的函数。"><a href="#Challenge-2：创建返回链表中间节点值的函数。" class="headerlink" title="Challenge 2：创建返回链表中间节点值的函数。"></a>Challenge 2：创建返回链表中间节点值的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nil</span><br><span class="line">// middle is 3</span><br><span class="line"></span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line">// middle is 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 该问题的解决思路是利用<strong>双指针位移的偏移量</strong>的方式来进行求解，也就是说分别定义两个初始位置相同的指针，然后对链表进行遍历，遍历的过程中，其中一个针对每次位移两个位置，另一个位移一个位置，位移快的那个移动到链表末尾时，慢的那个正好是链表的中间位置。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMiddle</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> fast <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> slow <span class="operator">=</span> list.head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> nextFast <span class="operator">=</span> fast<span class="operator">?</span>.next &#123;</span><br><span class="line">        fast <span class="operator">=</span> nextFast.next</span><br><span class="line">        slow <span class="operator">=</span> slow<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;getting the middle node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> middleNode <span class="operator">=</span> getMiddle(list) &#123;</span><br><span class="line">        <span class="built_in">print</span>(middleNode.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of getting the middle node---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度是**O(n)<strong>。也可以使用另一种解法，先遍历依次整个链表，记录节点总数，然后取链表节点总数的一半，再次进行遍历，获取中间值，但是这样的解法需要遍历两次，时间复杂度为</strong>O(n^2)**。</p>
<h2 id="Challenge-3：创建反转链表的函数。"><a href="#Challenge-3：创建反转链表的函数。" class="headerlink" title="Challenge 3：创建反转链表的函数。"></a>Challenge 3：创建反转链表的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">// Before</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">3 -&gt; 2 -&gt; 1 -&gt; nil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该问题简单的解决方案是，新建一个LinkedList，然后遍历原LinkedList，将节点一个一个的push到新的LinkedList，最后更新原LinkedList的头节点即可。但是这样的方式会有一个性能问题，就是每次调用push方法的时候，都需要分配新的节点，造成了绝大的资源成本。另一种代码较为复杂，但是性能上却相当好的方案是，构建两个变量，分别指向当前节点和上一个节点，然后遍历LinkedList，依次向后交换当前节点和上一个节点的指向，直到当前节点为nil时结束，这样就完全避免了每次新建节点的资源消耗问题。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 1</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionOne</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> tempList <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Value</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        tempList.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> tempList.head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionTwo</span>() &#123;</span><br><span class="line">    tail <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">    prev<span class="operator">?</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> current <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> next <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        current<span class="operator">?</span>.next <span class="operator">=</span> prev</span><br><span class="line">        prev <span class="operator">=</span> current</span><br><span class="line">        current <span class="operator">=</span> next</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然两种解决方案都是完整该挑战，但是在时间复杂度相同的情况下，空间复杂度更好的解决方案2，是应该遵循且掌握的方式。算法2的思路图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/reversed-list.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;reverse the list solution 2&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    list.reverseSolutionTwo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reversed list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of reverse the list solution 2---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Reversed list: 3 -&gt;2 -&gt;1 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"><a href="#Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。" class="headerlink" title="Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"></a>Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list1</span><br><span class="line">1 -&gt; 4 -&gt; 10 -&gt; 11</span><br><span class="line"></span><br><span class="line">// list2</span><br><span class="line">-1 -&gt; 2 -&gt; 3 -&gt; 6</span><br><span class="line"></span><br><span class="line">// merged list</span><br><span class="line">-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 10 -&gt; 11</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此问题的解决方案是不断从两个已排序的列表中摘取节点，并将它们添加到新列表中。由于两个列表已经排序，因此可以比较两个列表的下一个节点，以查看哪个节点应该是要添加到新列表的下一个节点。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> <span class="params">left</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">_</span> <span class="params">right</span>:<span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 检查输入的两个链表是否为空，如果其中一个为空，则直接返回另一个</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>left.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>right.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果链表的head、tail定义</span></span><br><span class="line">    <span class="keyword">var</span> newHead: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> tail: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> currentLeft <span class="operator">=</span> left.head</span><br><span class="line">    <span class="keyword">var</span> currentRight <span class="operator">=</span> right.head</span><br><span class="line">    <span class="comment">// 检查left、right的首个节点，并将小的节点赋值给newHead</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            newHead <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newHead <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="comment">// 遍历left、right，尝试挑选能够加入新链表的节点，直到其中一个链表到达末尾节点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="comment">// 比较节点值大小，并将小的链接到tail.next</span></span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> tail<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上个while循环同时以来currentLeft和currentRight，因此即使链表中还有节点，循坏也可能提前终止。需要将剩余的节点链接到处理单元中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNodes <span class="operator">=</span> currentLeft &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> leftNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> rightNodes <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> rightNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建结果链表，这里不使用push或者append的方式，而是直接指定链表的head、tail</span></span><br><span class="line">    <span class="comment">// head只有一个节点，直接复制，tail包含了很多节点，需要一个一个地进行链接</span></span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    list.head <span class="operator">=</span> newHead</span><br><span class="line">    list.tail <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next <span class="operator">=</span> tail<span class="operator">?</span>.next &#123;</span><br><span class="line">            tail <span class="operator">=</span> next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法求解过程的图示：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/MergeTwolinkedLists.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;merging two sorted list&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> list2 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">2</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;First list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Second list: <span class="subst">\(list2)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> mergedList <span class="operator">=</span> mergeSort(list1, list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merged list: <span class="subst">\(mergedList)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of merging two sorted list---</span></span><br><span class="line"><span class="comment">// First list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Second list: -3 -&gt;-2 -&gt;-1  </span></span><br><span class="line"><span class="comment">// Merged list: -3 -&gt;-2 -&gt;-1 -&gt;1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。"><a href="#Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。" class="headerlink" title="Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。"></a>Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// original list</span><br><span class="line">1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 4</span><br><span class="line"></span><br><span class="line">// list after removing all occurrences of 3</span><br><span class="line">1 -&gt; 4</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">LinkedList</span> <span class="title class_">where</span> <span class="title class_">Value</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeAll</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> head <span class="operator">=</span> <span class="keyword">self</span>.head, head.value <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">self</span>.head <span class="operator">=</span> head.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> currentNode <span class="operator">=</span> current &#123;</span><br><span class="line">            <span class="keyword">guard</span> currentNode.value <span class="operator">!=</span> value <span class="keyword">else</span> &#123;</span><br><span class="line">                prev<span class="operator">?</span>.next <span class="operator">=</span> currentNode.next</span><br><span class="line">                current <span class="operator">=</span> prev<span class="operator">?</span>.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev <span class="operator">=</span> current</span><br><span class="line">            current <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail <span class="operator">=</span> prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/delete-duplicate.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;deleting duplicate nodes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Origin list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    list1.removeAll(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete duplicate list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of deleting duplicate nodes---</span></span><br><span class="line"><span class="comment">// Origin list: 1 -&gt;1 -&gt;2 -&gt;2 -&gt;2 -&gt;3     </span></span><br><span class="line"><span class="comment">// Delete duplicate list: 1 -&gt;1 -&gt;3 </span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">23 分钟读完 (大约3452个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-08-03-ml-normal-methods/">机器学习问题的通用方法</a></h1><div class="content"><p>一位数据科学家平均每天处理大量数据，有人说，超过60-70％的时间花在了数据采集、数据清理、数据整理上，使得机器学习模型可以应用于这些数据。本文重点介绍第二部分，即应用机器学习模型，包括预处理步骤。这篇文章中讨论的流水线是我参与过的一百多次机器学习竞赛的结果。必须指出，这里的讨论虽然普通，但非常有用，也存在非常复杂的方法，可供专业人员练习。</p>
<p>我们将在这里使用python！</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>在应用机器学习模型之前，必须将数据转换为表格形式。整个过程是最耗时且最困难的过程，如下图所示。</p>
<p><img src="/images/ml-normal/1.png"></p>
<p>然后是机器学习模型应用于表格数据，表格数据是在机器学习或数据挖掘中表示数据的最常用方式。我们有一个数据表，包含不同数据样本（或X和标签y）的行。标签可以是单列或多列，具体取决于问题的类型。我们将用X表示数据，用y表示标签。</p>
<h1 id="标签的类型"><a href="#标签的类型" class="headerlink" title="标签的类型"></a>标签的类型</h1><p>标签定义了问题，可以是不同的类型，如：</p>
<ul>
<li>单列，二元值（分类问题，一个样本只属于一个类，只有两个类）</li>
<li>单列，实数值（回归问题，仅预测一个值）</li>
<li>多列，二元值（分类问题，一个样本属于一个类，但有两个以上的类）</li>
<li>多列，实数值（回归问题，多值预测）</li>
<li>多标签（分类问题，一个样本可以属于几个类）</li>
</ul>
<h1 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h1><p>对于任何类型的机器学习问题，我们必须确定将如何评估我们的结果，要评估的指标或目标是什么？例如，如果存在倾斜的二分类问题，我们通常选择受试者工作特征曲线下的面积（ROCAUC或简称AUC）。在多标签或多分类问题的情况下，我们通常选择分类交叉熵或多分类对数损失，在回归问题的情况下选择均方误差。</p>
<p>我不会详细讨论不同的评估指标，我们可以有许多不同的类型，具体取决于问题本身。</p>
<h1 id="机器学习库"><a href="#机器学习库" class="headerlink" title="机器学习库"></a>机器学习库</h1><p>要开始使用机器学习库，首先安装基本的和最重要的库，例如numpy和scipy。</p>
<p>查看和执行数据操作：pandas（<a target="_blank" rel="noopener" href="http://pandas.pydata.org/">http://pandas.pydata.org/</a>）<br>对于各种机器学习模型：scikit-learn（<a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/">http://scikit-learn.org/stable/</a>）<br>最好的梯度提升库：xgboost（<a target="_blank" rel="noopener" href="https://github.com/dmlc/xgboost">https://github.com/dmlc/xgboost</a>）<br>对于神经网络：keras（<a target="_blank" rel="noopener" href="http://keras.io/">http://keras.io/</a>）<br>可视化数据：matplotlib（<a target="_blank" rel="noopener" href="http://matplotlib.org/">http://matplotlib.org/</a>）<br>监视进度：tqdm（<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/tqdm">https://pypi.python.org/pypi/tqdm</a>）</p>
<h1 id="机器学习框架"><a href="#机器学习框架" class="headerlink" title="机器学习框架"></a>机器学习框架</h1><p>2015年，我提出了一个自动机器学习框架，该框架目前仍在开发中，将于近期发布。在这篇文章中，相同的（基础）框架如下图所示：</p>
<p><img src="/images/ml-normal/2.png"></p>
<p>本图来自：A.Thakur和A.Krohn-Grimberghe，AutoCompete：机器学习竞赛框架，AutoMLWorkshop，2015年机器学习国际会议</p>
<p>在上面显示的框架中，粉红色的线代表最常用的路径。在我们提取并将数据缩减为表格格式后，我们可以继续构建机器学习模型。</p>
<p>第一步是确定问题，这可以通过查看标签来完成。必须知道问题是二分类、多分类、多标签分类还是回归问题。在我们确定问题后，我们将数据分成两个不同的部分，一个训练集和一个验证集，如下图所示。</p>
<p><img src="/images/ml-normal/3.png"></p>
<p>数据分解为训练集和验证集“必须”考虑标签类型。如果出现任何类型的分类问题，请使用分层分割。在python中，你可以很容易地使用scikit-learn。</p>
<p><img src="/images/ml-normal/4.png"></p>
<p>在回归任务的情况下，简单的K-Fold分割就足够了。然而，有些复杂的方法往往需要训练集和验证集保持相同的标签分布，这个问题将留给读者作为练习。</p>
<p><img src="/images/ml-normal/5.png"></p>
<p>上述示例中我已经选择全部数据的10％作为eval_size或验证集的大小，此值可以根据它们所具有的数据大小进行选择。</p>
<p>数据拆分完成后，请保留此数据不要动它。必须保存在训练集上应用的任何操作，然后将其应用于验证集。在任何情况下，验证集都不应该与培训集一起使用，这样做会产生非常好的评估分数并让用户感到满意，但是会构建一个严重过拟合的无用模型。</p>
<p>下一步是识别数据中的不同变量。我们处理的变量通常有三种类型，即数字变量、分类变量和包含文本的变量。让我们以流行的泰坦尼克号数据集（<a target="_blank" rel="noopener" href="https://www.kaggle.com/c/titanic/data%EF%BC%89%E4%B8%BA%E4%BE%8B%E3%80%82">https://www.kaggle.com/c/titanic/data）为例。</a></p>
<p><img src="/images/ml-normal/6.png"></p>
<p>在这里，survival就是标签，我们已经将标签从前一步中的训练数据中分离出来了。变量pclass、sex、embarke具有不同的级别，因此它们是分类变量。像age、sibsp、parch等变量是数值变量。name是一个包含文本数据的变量，但我不认为它是预测生存的有用变量。</p>
<p>首先对于数值变量，这些变量不需要任何类型的处理，因此我们可以直接对这些变量应用规范化和机器学习模型。</p>
<p>有两种方法可以处理分类数据：</p>
<ul>
<li>将分类数据转换为标签</li>
</ul>
<p><img src="/images/ml-normal/7.png"></p>
<ul>
<li>将标签转换为二元变量（one-hot编码）</li>
</ul>
<p><img src="/images/ml-normal/8.png"></p>
<p>请记住先使用LabelEncoder将类别转换为数字，然后再应用OneHotEncoder。</p>
<p>因为泰坦尼克号的数据没有文本变量的好例子，所以让我们制定处理文本变量的一般规则。我们可以将所有文本变量合并为一个，然后使用一些对文本数据起作用的算法并将其转换为数字。</p>
<p>文本变量可以如下连接在一起：</p>
<p><img src="/images/ml-normal/9.png"></p>
<p>我们可以在变量上使用CountVectorizer或TfidfVectorizer：</p>
<p><img src="/images/ml-normal/10.png"></p>
<p>或</p>
<p><img src="/images/ml-normal/11.png"></p>
<p>TfidfVectorizer大多数时候比CountVectorizer性能都要好， TfidfVectorizer使用以下参数在很多情况下都有效。</p>
<p><img src="/images/ml-normal/12.png"></p>
<p>如果您只在训练集上应用这些vectorizer，请确保将其转储到磁盘中，以便稍后在验证集上使用它。</p>
<p><img src="/images/ml-normal/13.png"></p>
<p>接下来，我们来到stacker模块，stacker模块不是模型堆垛器，而是特征堆垛器。上述处理步骤之后的不同特征可以使用堆叠器模块进行组合。</p>
<p><img src="/images/ml-normal/14.png"></p>
<p>在通过使用numpy hstack或sparsehstack 进行进一步处理之前，您可以水平堆叠所有特征，具体取决于您是否拥有稠密或稀疏的特征。</p>
<p><img src="/images/ml-normal/15.png"></p>
<p>如果还有其他处理步骤如PCA或特征选择（我们将在本文的稍后部分讲解分解和特征选择），也可以通过FeatureUnion模块实现。</p>
<p><img src="/images/ml-normal/16.png"></p>
<p>一旦将这些特征堆叠在一起，我们可以开始应用机器学习模型。在这个阶段，你应该选择的模型应该集成基于树的模型。这些模型包括：</p>
<ul>
<li>RandomForestClassifier</li>
<li>RandomForestRegressor</li>
<li>ExtraTreesClassifier</li>
<li>ExtraTreesRegressor</li>
<li>XGBClassifier</li>
<li>XGBRegressor</li>
</ul>
<p>我们不能将线性模型应用于上述特征，因为它们没有归一化。要使用线性模型，可以使用scikit-learn中的Normalizer或StandardScaler。</p>
<p>这些归一化方法仅适用于稠密特征，如果应用于稀疏特征则不会给出非常好的结果。但可以在不使用均值的情况下在稀疏矩阵上应用StandardScaler（参数：with_mean&#x3D; False）。</p>
<p>如果上述步骤给出了一个“好”的模型，我们可以去优化超参数，如果没有，我们需要继续下面的步骤并改进我们的模型。</p>
<p><img src="/images/ml-normal/17.png"></p>
<p>为了简单起见，我们将忽略LDA和QDA转换。对于高维数据，通常使用PCA来分解数据。对于图片以10-15个component开始，并且只要结果质量显着提高，就增加此数量。对于其他类型的数据，我们最初选择了50-60个component（只要我们能够处理得了数值数据，我们就倾向于避免PCA）。</p>
<p><img src="/images/ml-normal/18.png"></p>
<p>对于文本数据，在将文本转换为稀疏矩阵后，进行奇异值分解（SVD）。可以在scikit-learn中找到称为TruncatedSVD的SVD变体。</p>
<p><img src="/images/ml-normal/19.png"></p>
<p>通常用于TF-IDF或计数的SVD component的数量在120-200之间。以上任何数字都可能会提高性能，但不会实质性降低计算能力。</p>
<p>在进一步评估模型的性能之后，我们转向数据集的缩放，以便我们也可以评估线性模型。特征被归一化或缩放后可以被发送到机器学习模型或特征选择模块。</p>
<p><img src="/images/ml-normal/20.png"></p>
<p>有多种方法可以实现特征选择。最常见的方式之一是贪婪特征选择（向前或向后）。在贪婪特征选择中，我们选择一个特征，训练一个模型并根据固定评估指标评估模型的性能，我们一个接一个不断添加和删除特征，并在每一步记录模型的性能，最后我们选择评估得分最高的特征。以AUC作为评估指标的贪婪特征选择的一个实现可以在这里找到：https：&#x2F;&#x2F;github.com&#x2F;abhishekkrthakur&#x2F;greedyFeatureSelection。必须指出的是，这种实现并不完美，必须根据要求进行修改。</p>
<p>其他更快的特征选择方法包括从模型中选择最佳特征。我们既可以查看logit模型的系数，也可以训练一个随机森林来选择最佳特征，然后在其他机器学习模型中使用这些特征。</p>
<p><img src="/images/ml-normal/21.png"></p>
<p>请记住，要保持较少的estimator和最少的超参数优化，以免过拟合。</p>
<p>使用梯度提升(GradientBoosting )也可以实现特征选择。我们在scikit-learn中推荐使用xgboost而不是GBM的实现，因为xgboost更快更灵活。</p>
<p><img src="/images/ml-normal/22.png"></p>
<p>我们也可以使用RandomForestClassifier &#x2F; RandomForestRegressor和xgboost来进行稀疏数据集的特征选择。</p>
<p>从正稀疏数据集中选择特征的另一种流行方法是基于chi-2的特征选择，我们在scikit-learn中实现了这一功能。</p>
<p><img src="/images/ml-normal/23.png"></p>
<p>在这里，我们使用chi2和SelectKBest从数据中选择20个特征。这是我们想要优化以提高机器学习模型结果的超参数。</p>
<p>不要忘记导出在所有步骤中使用的任何种类的transformer，它们将被用于在验证集上的评估性能。</p>
<p>下一个（或中间）的主要步骤是模型选择+超参数优化。</p>
<p><img src="/images/ml-normal/24.png"></p>
<p>我们通常在选择机器学习模型的过程中使用以下算法：</p>
<ul>
<li><p><strong>分类</strong></p>
<ul>
<li>Random Forest</li>
<li>GBM</li>
<li>Logistic Regression</li>
<li>Naive Bayes</li>
<li>Support Vector Machines</li>
<li>k-Nearest Neighbors</li>
</ul>
</li>
<li><p><strong>回归</strong></p>
<ul>
<li>Random Forest</li>
<li>GBM</li>
<li>Linear Regression</li>
<li>Ridge</li>
<li>Lasso</li>
<li>SVR</li>
</ul>
</li>
</ul>
<p>我们应该优化哪些参数？如何选择趋近最佳的参数？这些是大多数人想到得到的几个问题。如果没有大量数据集上不同模型+参数的经验，就无法得到这些问题的答案，可能也有有经验的人不愿意分享他们的秘密。幸运的是，我也有相当多的经验，同时我愿意分享一些东西。</p>
<p>让我们分解超参数，使模型更智能：</p>
<p><img src="/images/ml-normal/25.png"></p>
<p>RS* &#x3D;不能说完全适当的值，随机搜索这些超参数。</p>
<p>严格地说我的观点是，上述模型将超越其他模型，我们不需要评估任何其他模型。</p>
<p>再次记住保存transformer：</p>
<p><img src="/images/ml-normal/26.png"></p>
<p>并将它们分别应用于验证集：</p>
<p><img src="/images/ml-normal/27.png"></p>
<p>上述规则和框架在我处理的大多数数据集中都表现得非常好。当然，对于非常复杂的任务也可能是失败的。没有什么是完美的，我们继续改进我们学到的东西，就像机器学习一样。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-09-29-ios-architecture-patterns/"><img class="fill" src="/images/iOSArchitecturePatterns/cover.jpeg" alt="浅谈iOS架构模式"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">1 小时读完 (大约7869个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-09-29-ios-architecture-patterns/">浅谈iOS架构模式</a></h1><div class="content"><p>每一个软件开发者在开始学习软件开发的时候，可能都不清楚软件的架构设计是什么样的，仅仅是依靠前人的方式进行代码开发的，至少本人是这样的。慢慢熟悉了软件开发后，对于软件代码如何更加合理的进行组织，以前的开发为什么是那样进行组织的便有了有些理解。其实这一切都是软件的架构模式。</p>
<p>对于iOS开发者来说，几乎每个人都熟悉应用程序的测试、代码的重构和通过视图控制器对业务进行支持等，但是如何合理的选用对当前产品业务更加合理的软件架构，往往会被忽略。这里针对当前业界常见的五种架构模式，进行详细的分析和试用，了解每种架构模式。</p>
<blockquote>
<p>架构模式并不是所有问题都适用的解决方案，它们仅仅描述了移动应用程序代码的组织方式和方法，具体的实现细节往往会跟随业务的变化而变化。</p>
</blockquote>
<p>在本文中，将介绍以下五种iOS端的通用架构模式：</p>
<ul>
<li>传统MVC</li>
<li>苹果的MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER</li>
</ul>
<h2 id="传统MVC"><a href="#传统MVC" class="headerlink" title="传统MVC"></a>传统MVC</h2><p>在70年代后期，Model、View、Controller的模式在编程语言Smalltalk-80中出现，随着时间的推移，人们对MVC有了许多不同的理解，尽管最初的想法逐渐被人们遗忘，但是MVC带给软件开发行业的巨大变化是有目共睹的，有必要好好了解一下最初的MVC以及相关的原理等。MVC最初要解决的问题是：<strong>将组件的职责明确划分为模型、视图、控制器。</strong></p>
<p><strong>模型：</strong> 一组封装特定主题领域数据及其验证算法的类。 在传统MVC中，模型还包含处理逻辑（“业务逻辑”）。 有两种类型的模型：主动模型和被动模型。 主动模型能够通知其状态的更改（通常是通过观察者模式）。 传统MVC实现被认为是主动模型，该模型对View和Controller一无所知，并且可以独立运行。 在测试中，此要求起着重要作用。</p>
<p><strong>视图：</strong> 负责（但不一定）显示数据的图形类。 在传统MVC中，仅在只读模式下，视图可以直接访问模型，视图不应直接更改模型的状态，状态的更改应该是控制器的职责。</p>
<p><strong>控制器：</strong> 直接和外部互动的组件，根据不同的外部行为，控制器会执行一些逻辑，包括但不限于改变模型的状态等，但是控制器不会直接对视图做出响应，也不会保持视图的状态，也就是说控制器并不是视图和模型的中间介质，也不负责将数据从模型输出到视图。</p>
<p><img src="/images/iOSArchitecturePatterns/classicMVC.png"></p>
<h3 id="传统MVC原理"><a href="#传统MVC原理" class="headerlink" title="传统MVC原理"></a>传统MVC原理</h3><p>在70年代，MVC模式基本上都是在具有实体按键的设备上应用的。一些外部按键事件，该事件和控制器进行交互，控制器决定如何处理该事件。例如，控制器可以更改模型的状态（一般是调用模型的方法），但是绝不能更改视图的状态，仅仅只有模型会直接影响视图。</p>
<p>如果模型的状态发生了更改，模型将通知视图进行相应的更改，并且视图应该读取新的模型数据，然后在必要时更新并重新绘制视图（视图观察者模型）。虽然MVC在控制台模式下成功完成了任务，但图形界面和鼠标或触摸变得越来越流行，用户现在可以直接与视图进行交互，并且视图会生成事件，从理论上讲，该事件应由Controller处理。 实际上传统的MVC已经发生了变化。</p>
<p>在图像界面时代，界面上将要显示各种样式的图形组件，开发人员的大部分任务演变成了建立各个小组件的层级结构并将事件从组件上重定向到所需的类，因此在现代开发中，可以认为视图是由小部件的不同层级结构构成的。</p>
<p>图形组件通常相对比较复杂。例如，UIKit库中的常用按钮（UIButton）可以为按钮的每种状态包含不同的文本（例如，“highlighted” –“处于突出显示状态”，以及“selected” –“处于选定状态”）。 您还可以设置每种状态的文本颜色，可以直接在可视编辑器中进行配置，也可以通过写代码的方式配置。</p>
<p>因此，按钮本身具有设置功能，并且本身也响应外部事件。 实际上，它包含自己的模型（所谓的View Model）和自己的Controller。 因此，当前程序更像是View，Controllers和Model的复杂层次结构。</p>
<h3 id="传统MVC的缺点"><a href="#传统MVC的缺点" class="headerlink" title="传统MVC的缺点"></a>传统MVC的缺点</h3><p>传统MVC的缺点之一是组件之间的强互连性，这使单元测试变得复杂。 在现代程序中，控制器，视图和视图模型的层次结构愈发复杂，它们被认为是基于MVC的应用程序，因此实际上无法进行单元测试。</p>
<p>另一个问题是业务模型的“增厚”。 为什么会这样呢？ 视图可以具有复杂的状态。 例如，文本输入框的输入字段验证的逻辑及其取决于验证结果的文本颜色的设置，此时视图的状态不能直接保存在视图模型的字段中，也不能在IDE中进行设置。</p>
<p>那么，在哪里“转移”这种状态呢？模型和控制器中可以吗？</p>
<p>在传统的MVC中，控制器不应保存视图的状态，因此这些复杂的状态需要在Model中实现。 因此，除了域模型之外，该模型还包括部分文本输入ViewModel。</p>
<h2 id="苹果MVC"><a href="#苹果MVC" class="headerlink" title="苹果MVC"></a>苹果MVC</h2><p>为了适应传统MVC并解决其缺点，苹果重新构建了MVC架构，实际上是在传统的MVC的基础上构建了<code>Cocoa</code>和<code>CocoaTouch</code>框架。 在苹果的MVC下，模型与传统MVC中的模型相同，并且是主动模型（即在观察者的帮助下通知其状态的变化）。</p>
<p>为此，在Cocoa和CocoaTouch框架中，可以方便地使用<code>NSNotificationCenter</code>和<code>KVO</code>，而不必了解其他组件。 视图也类似于来自MVC的视图（可以是组件的层次结构）。 为了减少类的互连性，View无法直接访问Model。</p>
<p><img src="/images/iOSArchitecturePatterns/appleMVC.png"></p>
<p>用户在视图上进行也写操作，视图既能自行处理一部分视图逻辑，也能够将一部分事件转发到控制器，由控制器决定处理事务并在必要时更改模型的状态。如果模型的状态发生了更改，将通知控制器，并由控制器决定如何处理这些更改。控制器的职责还有从模型中读取数据，必要的时候会对数据进行一些转换（以便于视图使用），并对视图进行新值设定等。</p>
<h3 id="优于传统MVC的优势"><a href="#优于传统MVC的优势" class="headerlink" title="优于传统MVC的优势"></a>优于传统MVC的优势</h3><p>在Apple的MVC模式下，视图和模型之间不再存在直接的连接，视图的状态和数据表示的处理逻辑也在控制器中，在当前情况下，这种职责分工更为合适。</p>
<p>这种模式的缺点是Controller包含View状态的一部分和几乎所有View逻辑，而且由于Controller还充当View和Model之间的中介者，因此它成为应用程序逻辑适应的一个非常着重的地方。 实际上，UIViweController类变得过于庞大。 通常，由于Controller和视图之间的紧密关系，它们被视为<code>表示层</code>的组成部分。</p>
<p><img src="/images/iOSArchitecturePatterns/betterClassicMVC.png"></p>
<blockquote>
<p><strong>查看逻辑</strong> : 一种与小部件层次管理，从一个场景到另一个场景的动画过渡，显示对话等相关的逻辑。</p>
<p><strong>表示逻辑</strong> : 与将域模型转换为可在View上显示的模型以及处理View中需要操纵域模型的事件相关的逻辑。 </p>
<p><strong>域逻辑</strong> : 在具有模型对象的模型级别上运行的基本逻辑。 域逻辑因此可以在另一个应用程序中重用。</p>
<p><strong>应用程序逻辑</strong> :特定应用程序中固有的逻辑。 这与域逻辑不同，它不能重复使用，因为它是特定于特定应用程序的并且是唯一的。</p>
</blockquote>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model、View、Presenter）是MVC模式的进一步发展。 Controller由Presenter代替。 Presenter，与经典MVC中的Controller不同：</p>
<ul>
<li>保存视图的状态；</li>
<li>更改视图的状态；</li>
<li>处理视图的事件；</li>
<li>将域模型转换为ViewModel。</li>
</ul>
<p>Presenter与经典MVC中的Controller也有类似之处：</p>
<ul>
<li>拥有模型；</li>
<li>响应外部事件（通过调用适当的方法）更改模型的状态；</li>
<li>可能包含应用逻辑。</li>
</ul>
<p>MVP诞生于上世纪90年代初期的IBM。 与MVC一样，由于对其模式的不同解释，因此出现了多个版本。 马丁·福勒（Martin Fowler）定义了MVP的以下变化：</p>
<ul>
<li>演示模型</li>
<li>监督控制器</li>
<li>被动视图</li>
</ul>
<p>它们都是相似的，但主要取决于View和Presenter之间的连接以及View的更新顺序。 小部件的层次结构通常扮演视图的角色。 MVP中的模型与MVC中的模型没有什么不同。</p>
<h3 id="监督控制器"><a href="#监督控制器" class="headerlink" title="监督控制器"></a>监督控制器</h3><p>与MVC最接近的模式。 组件之间的相互作用如下图所示。</p>
<p><img src="/images/iOSArchitecturePatterns/mvp.png"></p>
<p>监督控制器视图：</p>
<ul>
<li>实现视图逻辑；</li>
<li>将事件转发给演示者；</li>
<li>与经典MVC中一样，观察模型（在数据绑定的帮助下或实现观察者模式）；</li>
<li>不会直接更改模型的状态；</li>
<li>可能需要从Presenter请求数据或读取模型。</li>
</ul>
<p>Presenter处理View的事件并更改Model的状态（通过调用适当的方法）。 与经典MVC中的Controller不同，如果无法借助数据绑定或Observer在Model与View之间建立连接的话，Presenter会保持并更改View的状态。</p>
<p>监督控制器的好处在于，视图状态现在位于Presenter中（而不是在Model中）。 Presenter处理演示逻辑，因此View和Model变得“更薄”。 缺点是View严重依赖Model和Presenter，这极大地使单元测试复杂化。</p>
<h3 id="展示模型"><a href="#展示模型" class="headerlink" title="展示模型"></a>展示模型</h3><p>移除了监督控制器缺点的MVP，该结构进一步开发了视图与模型之间的连接。 组件之间的交互方案是：</p>
<p><img src="/images/iOSArchitecturePatterns/mvp2.png"></p>
<p><strong>View：</strong></p>
<ul>
<li>负责视图逻辑；</li>
<li>将所有事件重定向到Presenter；</li>
</ul>
<p>与经典的MVC和Supervision Controller不同，View无法直接访问模型。 </p>
<p><strong>Presenter：</strong></p>
<ul>
<li>将视图的状态移动到单独的Presentation Model中，作为Presenter的一部分；</li>
<li>交互并提供与域模型的接口（即，视图的外观）；</li>
<li>观察模型状态的变化；</li>
<li>提供一个公共接口，View可以使用该接口与Presenter进行交互。</li>
</ul>
<h3 id="该方案的工作原理如下："><a href="#该方案的工作原理如下：" class="headerlink" title="该方案的工作原理如下："></a>该方案的工作原理如下：</h3><p>视图中有一个事件，View可以尝试自行处理它，并向Presenter请求数据。 如果View无法处理该事件，它将把该事件委托给Presenter，Presenter决定如何处理该事件。 如有必要，Presenter可以更改模型的状态。 该模型将其状态更改反向通知给Presenter，Presenter读取模型的新值，如有必要，对它们执行附加逻辑并更新视图。</p>
<p>该模型相对于Supervision Controller的优势在于，视图与模型没有任何关系，这有利于单元测试。 缺点包括需要创建其他接口（至少对于View和Presenter而言）以及在View中进行更新的逻辑，这并不能大大简化测试。</p>
<h3 id="Humble-View"><a href="#Humble-View" class="headerlink" title="Humble View"></a>Humble View</h3><p>Humble View和Presentation模型之间的区别在于视图及其状态如何更新。 视图变为被动，MVP的先前版本没有对View施加限制，它可能会向Presenter询​​问一些数据。 在这种情况下，被动视图受到限制，它不再向Presenter询问任何数据。</p>
<p>视图状态的任何更改均由Presenter执行。 视图不知道Presenter或Model的存在。 View的无源性最多可以简化单元测试。 与每种架构模式一样，组件之间的关系也有很多问题。 最常见的：</p>
<ul>
<li>谁拥有MVP中的View和Presenter？</li>
</ul>
<p>视图通常具有对Presenter的强烈引用。 反过来，Presenter对模型有很强的引用，而对View则无能为力。 与经典MVC中一样，该模型对View和Presenter一无所知。</p>
<ul>
<li>谁创建View和Presenter？</li>
</ul>
<p>可以认为，视图是由Presenter创建的。 但是，Presenter需要一个模型，即创建Presenter的视图必须通过模型进行配置，并且在此之后，她知道模型的存在。 此顺序不适合我们，因为我们正在尝试使组件之间的连接性达到最小（以实现更轻松的测试和更大的灵活性）。</p>
<p>因此，如果下一个View Presenter是由另一个Presenter创建的，或者是在单独的Router类中创建的，则更好（后者也可能参与下一个View的配置和创建）。 但是，没有明确的规则。</p>
<h2 id="iOS-MVP"><a href="#iOS-MVP" class="headerlink" title="iOS MVP"></a>iOS MVP</h2><p>经过一些理论，我们可以进行实际的发展。 一个典型的iOS应用程序是围绕一个中央UIViewController类构建的，该类承担着许多责任，因此放置UI逻辑和应用程序逻辑的一部分是最有吸引力的地方。 但是，我们在上面提到，由于View和Controller之间的紧密结合（在iOS UIViewController和UIView的上下文中），将它们视为View很方便。</p>
<p><img src="/images/iOSArchitecturePatterns/iosmvp.png"></p>
<p>例如，让我们考虑一个包含两个场景的简单应用程序。 它允许您使用REST服务 <a target="_blank" rel="noopener" href="http://random.cat/meow">http://random.cat/meow</a> 从Internet上加载猫的随机照片（“加载猫场景”） ，在猫的图片上应用内置照片滤镜，然后保存编辑后的照片（“编辑猫”现场）。</p>
<p>您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVP_Sample</p>
<p>加载照片时，“加载猫场景视图”会显示活动指示器，实际加载的照片和图片的URL。 演示者将借助“最小”界面LoadCatViewProtocol与“加载猫场景视图”进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateLoadingState</span>(<span class="keyword">_</span> <span class="params">loadingState</span>: <span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateTitle</span>(<span class="keyword">_</span> <span class="params">imageTitle</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">LoadCatViewProtocol</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> image: <span class="type">Data</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageTitle: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">installView</span>(<span class="keyword">_</span> <span class="params">view</span>: <span class="type">View</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view <span class="operator">=</span> view <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>() &#123;</span><br><span class="line">        view.updateLoadingState(isLoading)</span><br><span class="line">        view.updateTitle(imageTitle)</span><br><span class="line">        view.updateImage(image)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isLoading <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        image <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        imageTitle <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">        updateUI()</span><br><span class="line">        loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载猫场景允许您开始加载和取消它，还可以转到下一个场景进行图像编辑。 这些事件由用户启动，并且View只是将它们重定向到Presenter，调用其方法。 视图通过协议LoadCatPresenterProtocol与Presenter进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatPresenterProtocol</span>: <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">load</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> catProvider: <span class="type">CatProvider</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actCancel</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">setPresenter</span>(<span class="keyword">_</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter <span class="operator">=</span> presenter <span class="keyword">as!</span> <span class="type">LoadCatPresenterProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的测试项目中，无需Router类即可过渡到下一个场景。</p>
<ul>
<li>要将负载猫场景切换到编辑猫场景，您需要按编辑。</li>
<li>LoadCatViewController将此事件重定向到LoadCatPresenter。</li>
<li>LoadCatViewController不知道此事件会启动转换。</li>
<li>LoadCatPresenter创建EditCatPresenter并使用必要的模型对其进行配置。</li>
<li>要显示下一个场景，LoadCatPresenter调用LoadCatViewController showEditScene的方法并在此处传递EditCatPresenter。</li>
<li>LoadCatViewController创建下一个视图，将其与接收的Presenter连接并显示。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actEdit</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        loadButton.isEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        editCat()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextViewController <span class="operator">=</span> storyboard<span class="operator">!</span>.instantiateViewController(withIdentifier: <span class="type">Constants</span>.editCatViewControllerStoryboardId) <span class="keyword">as!</span> <span class="type">View</span></span><br><span class="line">        presenter.installView(nextViewController)</span><br><span class="line">        nextViewController.setPresenter(presenter)</span><br><span class="line">        present(nextViewController <span class="keyword">as!</span> <span class="type">UIViewController</span>, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一个场景，则可以按照Apple的所有原则在UIApplicationDelegate中执行此配置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> window<span class="operator">?</span>.rootViewController <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">        <span class="keyword">let</span> presenter <span class="operator">=</span> <span class="type">LoadCatPresenter</span>()</span><br><span class="line">        presenter.catProvider <span class="operator">=</span> catProvider</span><br><span class="line">        presenter.installView(view)</span><br><span class="line">        view.setPresenter(presenter)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>尽管MVP具有很多优点，但由于IDE开发和框架，它不适合自动化应用程序开发，需要“手动”工作。 下一个模式应该可以解决这些问题。 MVVM（Model、View、ViewModel）由Microsoft Ken Cooper和Ted Peters的工程师开发，并由John Gossman在2005年的博客中宣布。</p>
<p>该模式的目的是将用户界面与开发以及业务逻辑开发分开，并使用WPF和Silverlight平台的主要功能来促进应用程序测试。 尽管专业化模式是针对Microsoft技术构想的，但可以在Cocoa &#x2F; CocoaTouch框架中使用。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvm.png"></p>
<p>MVVM源自MVC模式，由以下3个组件组成：模型，视图，视图模型。 模型与MVP和MVC中的模型不同：</p>
<ul>
<li>它是一个领域模型；</li>
<li>包括数据，业务逻辑和验证逻辑；</li>
<li>不依赖于其他组件（ View 和 ViewModel ）。</li>
</ul>
<p><strong>View：</strong></p>
<ul>
<li>确定用户界面（如MVP，Apple MVC）的结构，位置和外观；</li>
<li>具有View的逻辑：动画、View与子View的操作之间的过渡等；</li>
<li>保持对ViewModel的强烈引用，但对Model一无所知；</li>
<li>监视ViewModel并使用数据绑定或直接引用它进行通信。</li>
</ul>
<p>为了避免View与ViewModel之间的牢固关系，需要创建一个接口，View将通过该接口与ViewModel进行通信。 ViewModel是视图和模型之间的中介者，并负责表示逻辑的处理。</p>
<p><strong>ViewModel：</strong></p>
<ul>
<li>保持View的状态；</li>
<li>了解模型并可以更改其状态（适当类的调用方法）；</li>
<li>将模型中的数据转换为对视图更方便的格式；</li>
<li>验证来自视图的数据；</li>
<li>不了解View，只能通过数据绑定机制与View交互。</li>
</ul>
<p>在Cocoa中有其自己的数据绑定机制，但在CocoaTouch中则没有。 我们只能用KVO来做，但是这个东西不方便使用，只允许您实现单边绑定。 反过来，数据绑定使实现MVVM固有的全部潜力成为可能，并总体上促进了开发。 因此，应该使用一些提供与CocoaTouch的数据绑定或响应式编程的第三方库。</p>
<p>MVVM和MVP中的UIViewController被视为View的一部分。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvmcocoa.png"></p>
<p>从苹果的MVC到MVVM的过渡过程中出现了一个重要的问题：如何实现导航？ 如上所述，视图直接执行到其他视图的过渡。 因此，有两种方法可以进行过渡：</p>
<ul>
<li>最简单的一种是从View启动过渡时。 在这种情况下，当前场景的ViewModel会创建下一个场景的ViewModel（如果需要，可以通过模型对其进行配置）。 然后，View创建下一个场景的View，将新的ViewModel传递给它，然后执行过渡。 </li>
<li>过渡从ViewModel启动。 由于ViewModel对View一无所知，因此无法进行过渡。 在这种情况下，需要一个特殊的组件-路由器-它知道视图的层次结构以及如何进行转换。 ViewModel可以将下一场景的ViewModel或模型传递给路由器。 路由器处理其他所有事务。</li>
</ul>
<p>因此，MVVM和MVP（低视角）在Presentation层（在MVP中由Presenter呈现，在MVVM中由ViewModel呈现）差异很大。 MVVM优于MVP（Humble View）的优点是Presentation层完全独立于View（意味着更容易测试）和DataBinding的使用。 总之，它成为在现代IDE中使用的更具吸引力的候选者，并减少了将View与ViewModel同步的代码量。</p>
<p>MVVM的缺点主要在于数据绑定机制，因为在某些情况下，它可能需要大量的内存资源，并且也是内存泄漏出现的薄弱环节。 接下来，我们将考虑上一节中描述的应用程序示例，但使用MVVM模式。 您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVVM_Sample</p>
<p>应用程序和模型（Cat，CatProvider）的用户界面相同。 它们仅在表示逻辑上有所不同，这将是主要重点。 View组件由LoadCatViewController和EditCatViewController呈现。 LoadCatViewController通过以下接口与LoadCatViewModel进行交互：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">CatViewModelProtocol</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> isLoading: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isEditable: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">Observable</span>&lt;<span class="type">String</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> imageData: <span class="type">Observable</span>&lt;<span class="type">Data</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> editCatViewModel: <span class="type">EditCatViewModelProtocol</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadNextCat</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelCurrentDownloading</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCatViewModel包含一组用于定义LoadCatViewController的状态的功能，以及一组与用户可以执行的操作相对应的方法。 对于数据绑定机制，我们使用 Bond 。 由于Load Cat是初始场景，因此很明显，它的配置是在AppDelegate中执行的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> catProvider <span class="operator">=</span> <span class="type">CatProvider</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> catViewModel <span class="operator">=</span> <span class="type">CatViewModel</span>(catProvider: catProvider)</span><br><span class="line">        (window<span class="operator">?</span>.rootViewController <span class="keyword">as?</span> <span class="type">CatViewController</span>)<span class="operator">?</span>.viewModel <span class="operator">=</span> catViewModel</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与MVP一样，配置Edit Cat场景分别在View和ViewModel中进行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">prepare</span>(<span class="params">for</span> <span class="params">segue</span>: <span class="type">UIStoryboardSegue</span>, <span class="params">sender</span>: <span class="keyword">Any</span><span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> editCatViewController <span class="operator">=</span> segue.destination <span class="keyword">as?</span> <span class="type">EditCatViewController</span> &#123;</span><br><span class="line">            editCatViewController.viewModel <span class="operator">=</span> viewModel.editCatViewModel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用Segue机制的LoadCatViewController创建EditCatViewController。</li>
<li>然后，在prepareForSegue方法中，LoadCatViewController询问LoadCatViewModel下一个场景的已配置ViewModel，即包含当前Cat模型的EditCatViewModel。</li>
<li>此外，我们将此EditCatViewModel传递给EditCatViewController。</li>
<li>单元测试是ViewModel和Model中的应用程序测试。 在测试项目中，您将找到单元测试的示例。</li>
</ul>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>在上面描述的架构中，如果尝试将体系结构划分为多个层，则使用Presenter或View Model可能会遇到困难。 它们属于哪一层？ 这个问题没有明确的答案：您可以为Presenter引入一个单独的Presentation层，或者它可以属于Application Logic。 MVVM也一样。 这种歧义造成了另一个问题。</p>
<p>将应用逻辑与域模型逻辑分开是非常困难的。 因此，通常没有分隔并且位于同一层。 此外，Presenter中存在应用程序逻辑有时会使很难测试不同的用例。 以前的体系结构中的另一个问题是组装和导航。 在数十个场景的大型项目中，很明显，这是由单独的模块路由器负责的。</p>
<p>2012年 发表 了一篇非凡的文章 。 清洁建筑以及有关该主题的几篇演讲。 后来，在Mutual Mobile中，我们为iOS做了一些修改，并进入了VIPER的新模式。 它 是View，Interactor，Presenter，Entity，Router的缩写，它们是构成应用程序的基本组件。 在下面查看他们如何互动。</p>
<p><img src="/images/iOSArchitecturePatterns/VIPER.png"></p>
<p><strong>View：</strong></p>
<p>与MVP（被动视图）一样，它是来自Presenter的数据的可视化。 View通过高于UI类级别的协议与Presenter通信。 演示者不知道构成视图层次结构的特定类。 要在View和Presenter之间共享数据，可以使用单独的结构（即，没有方法可以更改其状态的类）。 只有View和Presenter知道这些类。</p>
<p><strong>Presenter：</strong> 与MVP中的功能相同，不同之处在于它不应包含应用程序逻辑。 我们主要让Presenter参与数据转换。</p>
<p><strong>Interactor：</strong> 这些对象封装了应用程序的单独用例（我们将其称为应用逻辑）。 交互器与演示者和模型一起使用。 Interactor永远不会将属于模型层的对象类传递给Presenter。 因此，演示者不依赖于模型。 而且，他不知道该模型的存在。</p>
<p><strong>Model：</strong> 与以前的模式相同。 对于方向模型，只有交互器起作用。 该模型不知道其他组件的存在。 模型层可能包含各种管理器（用于创建或保留实体）和封装数据处理算法的对象。</p>
<p><strong>Entity：</strong> 实体是仅包含数据且不包含其处理方法的PONSO（普通的NSObject）对象（例如，其所有属性均为只读，并且NSManagerObject类的对象不能脱离模型层的边界）。</p>
<p><strong>Routing：</strong> 线框和演示者负责VIPER中的导航。</p>
<p>演示者接收视图的事件并知道如何响应它们。 但是Presenter对View的层次结构一无所知，并且包含View Logic（场景之间的动画切换– View Logic示例），并且无法在场景之间切换。</p>
<p>在这里，它将需要Wireframe（一个包含对UIWindow的引用的对象），可以创建View &#x2F; UIViewController并知道如何将它们放入View层次结构中。 同样，线框是诸如场景之间的自定义过渡之类的事务处理的理想位置。 例如，让我们考虑一个测试项目的VIPER版本，上面已针对MVP进行了描述。</p>
<p>您可以在此处下载示例代码： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_VIPER_Sample</p>
<p>在项目的MVP和VIPER版本中比较LoadCatView的协议。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> imageTitle: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">Data</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> showEditScene(withPresenter presenter: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishedEdit()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> title: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">UIImage</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishEditing()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>



<p>它们仅在方法上有所不同</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) </span><br></pre></td></tr></table></figure>

<p>因为就VIPER而言，新场景或对话显示是线框的职责。 因此，两个项目的LoadCatViewProtocol实现几乎相同。 比较MVP和VIPER项目的LoadCatPresenter。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">ar</span><span style="font-weight: 400;"> catProvider: </span><span style="font-weight: 400;">CatProvider</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">var</span><span style="font-weight: 400;"> loadCatInteractor: </span><span style="font-weight: 400;">LocadCatInteractor</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>

<p>它们之间的区别不是很大。 该项目的MVP版本包含一个变量catProvider，该变量引用了Model层。 在项目的VIPER版本中，Presenter不必依赖于Model层。</p>
<p>由于通过按下按钮加载图片是一个用例（或应用程序逻辑），因此要实现功能，需要一个Interactor（可变loadCatInteractor）。 通常，交互器具有输入（演示者可以通过其与之交互的接口）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorInput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadCat</span>() </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelLoad</span>() </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>和与演示者交互的输出</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorOutput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>因此，通过按下按钮加载猫图片处理如下所示</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIButton</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">LoadCatInteractorOutput</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> loadCatInteractor: <span class="type">LocadCatInteractor</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Some code to prepare UI</span></span><br><span class="line">        loadCatInteractor.loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: LoadCatInteractorOutput</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the URL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the image</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交互器和模型层之间的交互。 模型层由CatProvider和Cat类表示。 由于它很原始，因此对于交互器和模型之间的数据交换，我们没有创建实体类。</p>
<p>让我们考虑在场景之间切换。 正如我们上面提到的，在VIPER项目中，这是线框的责任。 如果下一个场景需要上一个场景的某些数据，则可以将它们传递到线框中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">EditCatPresenterDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: <span class="keyword">self</span>.image<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">let</span> editCatPresenter <span class="operator">=</span> <span class="type">EditCatPresenter</span>()</span><br><span class="line">        editCatPresenter.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        editCatPresenter.image <span class="operator">=</span> image<span class="operator">!</span></span><br><span class="line">        </span><br><span class="line">        view.showEditScene(withPresenter: editCatPresenter)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，不再将Seguey机制用于场景之间的过渡是不方便的，但是也不是拒绝使用UIStoryboard这样的便捷机制处理场景的理由。 这里的场景将没有Seguey。</p>
<p>一个普通的VIPER项目包含许多您需要配置的模块。 对于我们的简单示例，在应用程序启动时使用单独的Dependencies类就足够了。 但是，在复杂的项目中，更容易使用其他解决方案或库。</p>
<p><strong>测试:</strong> VIPER项目的测试与MVP相似，不同之处在于将应用逻辑交付到单独的类–交互器中。 一方面，您必须编写更多用于单元测试的代码，另一方面，还需要针对单个功能测试（用户案例）使用更简单的算法。 在我们的测试项目中，您将找到所有VIPER项目的单元测试示例。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们研究了可用于开发iOS应用程序的体系结构模式的演变。 进化链中的每个模式都改进了前一个模式。 明确了组件之间的界限及其职责（如有必要，引入了新的层或组件），这有助于开发和支持。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://thinkmobiles.com/blog/ios-architecture-patterns/">iOS architecture patterns: A guide for developers</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/ios-architecture-patterns">iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/61a656431685">iOS的MVP设计模式</a></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/"><img class="fill" src="/images/lightweight-api/cover.jpg" alt="Swift语言中的轻量级API设计"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">22 分钟读完 (大约3270个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/">Swift语言中的轻量级API设计</a></h1><div class="content"><p>Swift语言自诞生以来，总是或多或少受到人们的非议，新生的编程语言难免有些不够尽善尽美，但是哪种编程语言是尽善尽美的呢？OC语言算得上是一种古老的面向对象语言了，发展至今，其版本仍处于2.0，但是Apple为了让其看起来强大一点，增加了很多特性，例如Block、instancetype等等，但是其核心的语法变化并不大。</p>
<p>截止目前，Swift的版本已经迭代到5.*，整个ABI也已经稳定，每一次迭代更新，总是会带来一些漂亮的设计模式实践，例如在如何设计API方面，给开发者带来了舒适而强大的枚举、扩展和协议等，不仅让开发者对于函数的定义有了更清晰的认识，而且对于构建API而言，第一印象往往是轻量的，同时，仍会根据需要逐步显现出更多的功能，以及底层的复杂性。</p>
<p>在本篇文章里，将尝试创建一些轻量级的API，以及如何使用API组合的力量使得功能或者系统更加强大等。</p>
<h2 id="功能和易用性之间的较量"><a href="#功能和易用性之间的较量" class="headerlink" title="功能和易用性之间的较量"></a>功能和易用性之间的较量</h2><p>通常，当我们设计API时，会在数据结构和函数功能的相互交互上，寻找一个相对平衡的方式，最终构建出在功能上满足需求，数据结构尽量简单的API。但是，让API过于简单，可能它们又不够灵活，无法使功能有不断发展的潜力，然而，太过复杂的设计又难免导致开发工作复杂而无章法，容易造成开发者挫败，逻辑混乱而且API也难以使用，最终可能会导致延期甚至失败。</p>
<p>例如，一款应用程序的主要功能是对用户选择的图像应用不同的滤镜效果。每一种滤镜的核心其实都是一组图像变换的组合，不同的变换组合形成不同的滤镜效果。假设使用<code>ImageFilter</code> 结构体作为图像滤镜的定义，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">Icon</span></span><br><span class="line">    <span class="keyword">var</span> transforms: [<span class="type">ImageTransform</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageTransform</code>是图像变换的统一入口，因为可能会由多种不同的变换，因此可以将其定义为一个<code>protocol</code>，然后由实现单独变换操作的各种变换类型所遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortraitImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zoomMultiplier: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayScaleImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brightnessLevel: <span class="type">BrightnessLevel</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述设计方式的优势在于，由于每种转换都是按照自己的类型实现的，因此在使用时可以自由地让每种变换类型定义自己所需的属性和参数。例如<code>GrayScaleImageTransform</code> 接受 <code>BrightnessLevel</code>参数，以将图像转换为灰度图像。</p>
<p>然后，可以根据需要组合任意数量的图像变换类型，以形成不同类型的滤镜效果。例如，通过一系列的转换使得图像具有某种“戏剧性”外观的滤镜：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>, icon: .drama, transforms: [</span><br><span class="line">        <span class="type">PortraitImageTransform</span>(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        <span class="type">ContrastBoostImageTransform</span>(),</span><br><span class="line">        <span class="type">GrayScaleImageTransform</span>(brightnessLevel: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So far so Good.  但是回头重新审视上述API的实现，可以肯定的说，上述实现仅仅是为了功能的实现，在API的易用性方面并没有优势，那么该如何进行优化，来保证功能的同时，提高API的灵活性和易用性呢？在上述实现中，每个图像的变换都是作为单独的类型实现的，因此没有一个可以对所有变换类型一目了然的地方，使用者难以清楚该代码库都包含哪些图像变换的类型。</p>
<p>为了解决外部使用者无法得知软件库所支持的变换类型，假设使用<strong>枚举</strong>的方式代替上述方式，来观察哪种方式更能够体现API的简洁明了以及使用上的清晰易用？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> protrait(<span class="keyword">_</span> zoomMultiplier: <span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> grayScale(<span class="keyword">_</span> brightnessLevel: <span class="type">BrightnessLevel</span>)</span><br><span class="line">    <span class="keyword">case</span> contrastBoost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举的好处既能够提高代码的整洁程度和可读性，也使得API更加的灵活易用，因为在枚举的使用上，开发者可以直接使用点语法构造任意数量的转换，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .protrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>截止目前，枚举都是很漂亮的一个工具，在很多情况下Swift的枚举类型都能够提供良好的解决方式，但是枚举也有其明显的弊端。</p>
<p>就上述例子来说，由于每个转换都需要执行截然不同的图像操作，因此在这种情况下使用枚举将迫使我们编写一个庞大的<em>switch</em>语句来处理这些操作中的每一项, 这可能会造成代码的冗长繁琐等。</p>
<h2 id="枚举虽轻，结构体更优"><a href="#枚举虽轻，结构体更优" class="headerlink" title="枚举虽轻，结构体更优"></a>枚举虽轻，结构体更优</h2><p>幸运的事，针对上述问题，我们还有第三种选择 — 一种目前算是两全其美的方案。相较于协议或者枚举，结构体是一个既能够定义操作类型，还能够封装给定各种操作的闭包的数据结构。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> closure: (<span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>apply(to:)</code> 方法在这里并不应该被外部调用，这里写出来是为了代码的美观性以及代码的向前兼容。在实际项目开发中，这里可以使用宏定义区分。</p>
</blockquote>
<p>完成上述操作后，我们现在可以使用<strong>静态工厂方法</strong>和属性来创建我们的转换 — 每个转换仍可以单独定义并具有自己的一组参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> contrastBoost: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">portrait</span>(<span class="keyword">_</span> <span class="params">multiplier</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">grayScale</span>(<span class="keyword">_</span> <span class="params">brightness</span>: <span class="type">BrightnessLevel</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在 Swift 5.1 中，可以将<strong>Self</strong>用作静态工厂方法的返回类型。</p>
</blockquote>
<p>上面方法的优点在于，我们回到了将ImageTransform定义为协议时所具有的灵活性和功能性，同时仍保持了与定义为枚举时的调用方式 — 点语法一致，保证了易用性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>点语法本身与枚举无关，但是其可以与任何静态API一起使用，这点对于开发者而言非常友好。使用点语法可以将上述的几个滤镜的创建和建模构造成静态属性，使得我们能够进一步的封装特性等。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> dramatic: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageFilter</span>(</span><br><span class="line">            name:<span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">            icon: .drama,</span><br><span class="line">            transforms: [</span><br><span class="line">                .portrait(<span class="number">2.1</span>),</span><br><span class="line">                .contrastBoost,</span><br><span class="line">                .grayScale(.dark)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述改造，一系列复杂的任务 — 包括图像滤镜和图像转换 – 封装到一个API中，在使用上，可以像传值给函数一样轻松。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> image.withFilter(.dramatic)</span><br></pre></td></tr></table></figure>

<p>上述一系列的改造可以成为为类型构造<strong>语法糖</strong>。不仅改善了API读取的方式，还改善了API的组织方式，由于所有的转换和滤镜现在只需要进行传单一的值即可，因此在可扩展性方面来说，能够组织多种方式，不仅使得API轻巧灵活，对于使用者来说也简洁明了。</p>
<h2 id="可变参数与API设计"><a href="#可变参数与API设计" class="headerlink" title="可变参数与API设计"></a>可变参数与API设计</h2><p>接下来我们一起看看Swift语言的另一个特性 — 可变参数，以及可变参数如何影响API设计中的代码构建的。</p>
<p>假设正在开发一个使用基于形状的绘图来创建其用户界面的应用程序，并且我们已经使用了与上述类似的基于结构的方法来对每种形状进行建模，并最终将结果绘制到了<code>DrawingContext</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> drawing: (<span class="keyword">inout</span> <span class="type">DrawingContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面使用<strong>inout</strong>关键字来启用值类型（DrawingContext）的传递。</p>
</blockquote>
<p>类似我们在上面例子中使用静态工厂方法轻松创建<code>ImageTransform</code>一样，在这里也能够将每个形状的绘图代码封装在一个完全独立的方法中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">at</span> <span class="params">point</span>: <span class="type">Point</span>, <span class="params">sideLength</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> origin <span class="operator">=</span> point.movedBy(</span><br><span class="line">                x: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span>,</span><br><span class="line">                y: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            context.move(to: origin)</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength, y: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(y: sideLength))</span><br><span class="line">            context.drawLine(to: origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于将每个形状简单地建模为一个属性值，因此绘制它们的数组变得非常容易-我们要做的就是创建一个<strong>DrawingContext</strong>实例，然后将其传递到每个形状的闭包中以构建最终图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context <span class="operator">=</span> <span class="type">DrawingContext</span>()</span><br><span class="line">    </span><br><span class="line">    shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">        context.move(to: .zero)</span><br><span class="line">        shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> context.makeImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的函数看起来也很优雅，因为我们再次可以使用点语法来大大减少执行工作所需的语法量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw([</span><br><span class="line">    .circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">    .square(at: point, sideLength: <span class="number">5</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>但是，让我们看看是否可以使用可变参数来使事情更进一步。虽然不是Swift独有的功能，但结合Swift真正灵活的参数命名功能后，使用可变参数可以产生一些非常有趣的结果。</p>
<p>当参数被标记为可变参数时（通过在其类型中添加<code>...</code>后缀），我们基本上可以将任意数量的值传递给该参数 — 编译器会自动为我们将这些值组织到一个数组中，例如这个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: <span class="type">Shape</span>...) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="comment">// Within our function, &#x27;shapes&#x27; is still an array:</span></span><br><span class="line">    shapes.forEach &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述更改后，我们现在可以从对draw函数的调用中删除所有数组文字，而使它们看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">                 .square(at: point, sideLength: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>这看起来似乎不是很大的变化，但是尤其是在设计旨在用于创建更多更高级别值（例如我们的draw函数）的更低级别的API时，使用可变参数可以使这类API感觉更轻巧和方便。</p>
<p>但是，使用可变参数的一个缺点是，预先计算的值数组不能再作为单个参数传递。值得庆幸的是，在这种情况下，可以通过创建一个特殊的组形状（就像draw函数本身一样），在一组基础形状上进行迭代并绘制它们来轻松解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">group</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">                context.move(to: .zero)</span><br><span class="line">                shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述操作后，我们现在可以再次轻松地将一组预先计算的Shape值传递给我们的draw函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shapes: [<span class="type">Shape</span>] <span class="operator">=</span> loadShapes()</span><br><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.group(shapes))</span><br></pre></td></tr></table></figure>

<p>不过，真正酷的是，上述组API不仅使我们能够构造形状数组，而且还使我们能够更轻松地将多个形状组合到更高级的组件中。例如，这是我们如何使用一组组合形状来表示整个图形（例如徽标）的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">logo</span>(<span class="params">withSize</span> <span class="params">size</span>: <span class="type">Size</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        .group([</span><br><span class="line">            .rectangle(at: size.centerPoint, size: size),</span><br><span class="line">            .text(<span class="string">&quot;The Drawing Company&quot;</span>, fittingInto: size),</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述徽标与其他徽标一样都是Shape，因此只需调用一次draw方法就可以轻松绘制它，并使用与之前相同的优雅点语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo <span class="operator">=</span> draw(.logo(withSize: size))</span><br></pre></td></tr></table></figure>

<p>有趣的是，尽管我们最初的目标可能是使我们的API更轻量级，但这样做也使它的可组合性和灵活性也得到了提高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们向“ API设计者的工具箱”添加的工具越多，我们越有可能能够设计出在功能，灵活性和易用性之间达到适当平衡的API。 使API尽可能轻巧可能不是我们的最终目标，但是通过尽可能减少API的数量，我们也经常发现如何使它们变得更强大-通过使我们创建类型的方式更灵活，以及使他们组成。所有这些都可以帮助我们在简单性与功能之间实现完美的平衡。</p>
<blockquote>
<p>原文： Lightweight API design in Swift<br>链接：<a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</a></p>
</blockquote>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.804Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2018-08-28-coreml-vs-mlkit/">Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.803Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2020-07-13-iOS-memory-manager/">Runtime剖析05 --- 再议iOS内存管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.802Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-09-07-machine-learning-feature/">机器学习与移动应用开发的未来</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.801Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-08-31-mind-flower/">思维的火花 --- 大数据与数据思维</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.800Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/">\#1\ 为什么要学习数据结构与算法</a></p><p class="categories"><a href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">48</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">Swift中的数据结构与算法</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"><span class="tag">开发知识 iOS</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">开发知识 技术人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">技术人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F-%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"><span class="tag">技术人生 读书计划</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-Python/"><span class="tag">数据科学 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"><span class="tag">机器学习 Keras MNIST</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-MFCC/"><span class="tag">机器学习 MFCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python/"><span class="tag">机器学习 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97-CoreML/"><span class="tag">端测计算 CoreML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>