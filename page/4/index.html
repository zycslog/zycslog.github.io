<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.099Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.099Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item">27 分钟读完 (大约4117个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-06-24-iOS-runtime-message-forward/">Runtime剖析02 --- 消息与消息发送机制</a></h1><div class="content"><p>在Objective-C中，消息发送指Runtime会根据<strong>SEL</strong>查找对应的<strong>IMP</strong>，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。</p>
<h2 id="消息相关数据结构"><a href="#消息相关数据结构" class="headerlink" title="消息相关数据结构"></a>消息相关数据结构</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><strong>SEL</strong>称之为消息选择器，相当于一个<strong>key</strong>，在类的消息列表中，可以根据这个<strong>key</strong>查找对应的消息实现<strong>IMP</strong>。</p>
<p>在Runtime中，SEL的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<strong>SEL</strong>其实是一个<strong>objc_selector *<strong>结构体指针，但是在苹果开源的runtime中并没有其定义，目前</strong>SEL</strong>仅是一个字符串。</p>
<p>虽然<strong>SEL</strong>可以作为key对消息进行查找，但是当不同的类有着相同的<strong>SEL</strong>的时候，再进行消息实现查找时，可能无法确定消息实现真实的归属，因此在进行消息实现查找时，会结合消息发送的目标Class，才能找到具体的最终的<strong>IMP</strong>。</p>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>开篇已说，runtime会根据<strong>SEL</strong>查找对应的实现<strong>IMP</strong>。具体地说，runtime会在Class的方法列表中查找方法的实现，在方法列表中方法的实现是以<strong>method_t</strong>结构体的形式存储的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></span><br><span class="line">        public <span class="built_in">std</span>::binary_function&lt;<span class="type">const</span> <span class="type">method_t</span>&amp;,</span><br><span class="line">                                    <span class="type">const</span> <span class="type">method_t</span>&amp;, <span class="type">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">method_t</span>&amp; lhs,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">method_t</span>&amp; rhs)</span></span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>method_t</strong>结构体重包含了<strong>SEL</strong>的名称，以及指向对应试下的<strong>imp</strong>指针，另外<strong>types</strong>指的是方法的返回值和参数类型，其格式一般为<strong>v24@0:8@16</strong>，此种格式被称为<strong>Type Encodings</strong>，对应的解释说明详见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><strong>IMP</strong>本质上是一个函数指针，用于指向方法的具体实现，在runtime中，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> )</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IMP</strong>是由编译器生成的，如果知道了<strong>IMP</strong>的地址，就可以绕过runtime的消息发送过程，直接调用函数实现。</p>
</blockquote>
<p>在消息发送过程中，runtime会根据<strong>id</strong>和<strong>SEL</strong>来唯一确定<strong>IMP</strong>并进行调用。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>在Objective-C中，函数的调用被称为<strong>消息发送</strong>。在进行代码编译时，代码会被修改为<strong>objc_msgSend</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>**objc_msgSend()**形式即为Objective-C中的消息发送的入口，该函数的具体实现是由汇编语言实现的，其目的一是为了提高执行效率，二是因为该函数的返回值类型是可变的，汇编正好具有返回值类型多样性的特性。</p>
<p>除了**objc_msgSend()**之外，编译器还会根据具体的情况，将消息转发改写为如下形式之一：</p>
<ul>
<li>objc_msgSend</li>
<li>objc_msgSend_stret</li>
<li>objc_msgSendSuper</li>
<li>objc_msgSendSuper_stret</li>
</ul>
<p>当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSendSuper</span><span class="params">(<span class="keyword">struct</span> objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在<strong>objc_msgSendSuper</strong>函数的参数中，第一个参数不再是当前类的指针，而变为<strong>objc_super *<strong>结构体指针，</strong>objc_super</strong>结构体包含两个数据，<strong>receiver</strong>指调用super方法的对象，即消息接收者，而<strong>super_class</strong>表示当前子类的父类对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有**_stret**的函数，表示方法返回的是结构体类型。</p>
</blockquote>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">ENTRY</span> _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">p0</span>, <span class="number">#0</span>			<span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="comment">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	b.le	LNilOrTagged		<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="keyword">ldr</span>	<span class="built_in">p13</span>, [x0]		<span class="comment">// p13 = isa</span></span><br><span class="line">	GetClassFromIsa_p16 <span class="built_in">p13</span>		<span class="comment">// p16 = class</span></span><br><span class="line"><span class="symbol">LGetIsaDone:</span></span><br><span class="line">	<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend</span><br><span class="line"></span><br><span class="line"><span class="comment">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class="line"><span class="symbol">LNilOrTagged:</span></span><br><span class="line">	b.eq	LReturnZero		<span class="comment">// nil check</span></span><br><span class="line"><span class="comment">// 省略其他</span></span><br></pre></td></tr></table></figure>

<ol>
<li>进入<strong>objc_msgSend</strong>后，首先通过<strong>cmp	p0, #0</strong>检查函数参数<strong>receiver</strong>是否为<strong>nil</strong>，如果为<strong>nil</strong>，则进入<strong>LReturnZero</strong>，返回0；</li>
<li>如果不为<strong>nil</strong>，则将<strong>receiver</strong>的<strong>isa</strong>存储在<strong>p13</strong>寄存器；</li>
<li>在寄存器<strong>p13</strong>中，取出<strong>isa</strong>对应的<strong>Class</strong>，存储到<strong>p16</strong>寄存器；</li>
<li><strong>Class</strong>获取完成后，调用<strong>CacheLookup NORMAL</strong>函数，查找<strong>Class</strong>的方法缓存列表，如果命中，则调用**_objc_msgSend<strong>，如果未命中，则调用</strong>objc_msgSend_uncached**。</li>
</ol>
<p><strong>objc_msgSend_uncached</strong>也是汇编语言实现，作用是为方法缓存列表中未查找到方法缓存时，在<strong>Class</strong>的方法列表中进行查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">	<span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line">	<span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line">	</span><br><span class="line">	MethodTableLookup</span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p><strong>objc_msgSend_uncached</strong>内部调用了<strong>MethodTableLookup</strong>，<strong>MethodTableLookup</strong>是一个汇编实现的宏定义，其内部调用了C语言函数<strong>lookUpImpOrForward</strong>。</p>
<h2 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> IMP <span class="title function_">lookUpImpOrForward</span><span class="params">(id obj, SEL, Class cls, <span class="type">int</span> behavior)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>lookUpImpOrForward</strong>函数的目的是根据<strong>Class</strong>和<strong>SEL</strong>，在当前类或者当前类的父类中找到方法对应的<strong>IMP</strong>，同时，缓存找到的对应<strong>IMP</strong>到当前类的方法缓存列表中。如果没有找到对应的<strong>IMP</strong>，则会进入到消息转发流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">IMP <span class="title function_">lookUpImpOrForward</span><span class="params">(id inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="comment">// 首先在根据class和sel在方法缓存中查找imp</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="comment">// 如果查找到，则直接进入到done_nolock</span></span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t want people to be able to craft a binary blob that looks like</span></span><br><span class="line">    <span class="comment">// a class but really isn&#x27;t one and do a CFI attack.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To make these harder we want to make sure this is a class that was</span></span><br><span class="line">    <span class="comment">// either built into the binary or legitimately registered through</span></span><br><span class="line">    <span class="comment">// objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this check is quite costly during process startup.</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果class还未realize，先进行realize</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果class还未initialize，先进行initialize</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If sel == initialize, class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won&#x27;t happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code used to lookpu the class&#x27;s cache again right after</span></span><br><span class="line">    <span class="comment">// we take the lock but for the vast majority of the cases</span></span><br><span class="line">    <span class="comment">// evidence shows this is a miss most of the time, hence a time loss.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The only codepath calling into this without having performed some</span></span><br><span class="line">    <span class="comment">// kind of cache lookup is class_getInstanceMethod().</span></span><br><span class="line">    <span class="comment">// 在当前class中没有找到imp，则依次向上查找super class的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        <span class="comment">// 首先获取当前类的方法体</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过继承链，向上查找IMP</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</span><br><span class="line">            <span class="comment">// No implementation found, and method resolver didn&#x27;t help.</span></span><br><span class="line">            <span class="comment">// Use forwarding.</span></span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        <span class="comment">// 父类缓存</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">            <span class="comment">// Stop searching, but don&#x27;t cache yet; call method</span></span><br><span class="line">            <span class="comment">// resolver for this class first.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到父类的IMP，并缓存</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="comment">// 没有查找到IMP，进入动态方法解析流程</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line"> 	<span class="comment">// 记录并缓存IMP</span></span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line"> 	<span class="comment">// 未找到对应的IMP，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lookUpImpOrForward</strong>工作流程：</p>
<ol>
<li>尝试在当前receiver对应class的cache中查找imp，如果查找到，则调用；</li>
<li>如果在cache中为查找到imp，则在class的方法列表中查找imp；</li>
<li>尝试在class的所有super class中查找imp。（首先在super class的cache中查找，如果为找到，则在super class的方法列表中查找）；</li>
<li>如果还未找到imp，则尝试进行动态方法解析SEL；</li>
<li>动态解析失败，则尝试进入消息转发流程，让其他class处理SEL。</li>
</ol>
<p>在查找class的方法列表中是否有SEL对应的IMP时，调用的是**getMethodNoSuper_nolock()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">method_t</span> *</span><br><span class="line"><span class="title function_">getMethodNoSuper_nolock</span><span class="params">(Class cls, SEL sel)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> methods = cls-&gt;data()-&gt;methods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = methods.beginLists(),</span><br><span class="line">              end = methods.endLists();</span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/46904873&gt; getMethodNoSuper_nolock is the hottest</span></span><br><span class="line">        <span class="comment">// caller of search_method_list, inlining it turns</span></span><br><span class="line">        <span class="comment">// getMethodNoSuper_nolock into a frame-less function and eliminates</span></span><br><span class="line">        <span class="comment">// any store from this codepath.</span></span><br><span class="line">        <span class="type">method_t</span> *m = search_method_list_inline(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出class的方法列表<strong>method_array_t</strong>，然后调用<strong>search_method_list_inline()<strong>，根据SEL查找对应的</strong>method_t</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="type">static</span> <span class="type">method_t</span> *</span><br><span class="line"><span class="title function_">search_method_list_inline</span><span class="params">(<span class="type">const</span> <span class="type">method_list_t</span> *mlist, SEL sel)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="type">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(<span class="type">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法查找的时候，会分为两种方式：</p>
<ol>
<li>如果方法列表是有序的，则使用<strong>findMethodInSortedMethodList</strong>进行前向查找，使用<strong>二分查找</strong>方式</li>
<li>否则直接进行遍历</li>
</ol>
<h2 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h2><p>上文已经提到，当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSendSuper</span><span class="params">(<span class="keyword">struct</span> objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，当使用<strong>super</strong>关键字调用方法时，编译器则会将代码编译为<strong>objc_msgSendSuper</strong>的格式。</p>
<p><strong>super关键字本质上类似一个“语法糖”，在代码编译时，编译器会将其替换为objc_super指针类型，来传入到objc_msgSendSuper方法中，而并不是父类的意思。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    <span class="comment">// 消息的接收者，一般为当前类的实例对象。</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line">    <span class="comment">// 告知查找方法IMP的去向，当前类实例的父类对象。</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>当使用super关键字调用方法时，runtime会到当前类的父类中查找对应IMP，然后将消息发送到当前类的实例上。</strong></p>
<p>这也解释了为什么**[self class] 和 [super class]**会输出同样结果的原因。</p>
<p>同样<strong>objc_msgSendSuper</strong>也是由汇编语言实现的，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line"></span><br><span class="line">ldr	r9, [r0, #CLASS]	<span class="comment">// r9 = struct super-&gt;class</span></span><br><span class="line">CacheLookup NORMAL, _objc_msgSendSuper</span><br><span class="line"><span class="comment">// cache hit, IMP in r12, eq already set for nonstret forwarding</span></span><br><span class="line">ldr	r0, [r0, #RECEIVER]	<span class="comment">// load real receiver</span></span><br><span class="line">bx	r12			<span class="comment">// call imp</span></span><br><span class="line"></span><br><span class="line">CacheLookup2 NORMAL, _objc_msgSendSuper</span><br><span class="line"><span class="comment">// cache miss</span></span><br><span class="line">ldr	r9, [r0, #CLASS]	<span class="comment">// r9 = struct super-&gt;class</span></span><br><span class="line">ldr	r0, [r0, #RECEIVER]	<span class="comment">// load real receiver</span></span><br><span class="line">b	__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure>

<p>寄存器<strong>r9</strong>中保存的是当前实例的父类对象，获取到对应的父类后，调用<strong>CacheLookup</strong>在方法缓存中查找对应imp，缓存命中后，取出<strong>receiver</strong>，调用imp。如果未在缓存中命中IMP，则调用**__objc_msgSend_uncached<strong>，传入</strong>super class**进行方法查找。</p>
<h2 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h2><p>如果在类的继承链中没有找到对应的IMP，runtime则会进入消息的动态解析流程，即进入到<strong>lookUpImpOrForward</strong>中的<strong>resolveMethod_locked</strong>函数调用中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">       behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">       <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态解析，就是将方法实现在运行时动态的添加到当前类中。</strong>之后runtime会重新尝试消息查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> NEVER_INLINE IMP</span><br><span class="line"><span class="title function_">resolveMethod_locked</span><span class="params">(id inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chances are that calling the resolver have populated the cache</span></span><br><span class="line">    <span class="comment">// so attempt using it</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>resolveMethod_locked</strong>中，runtime会根据调用的是实例方法还是类方法，进入到不同的处理逻辑中。</p>
<ul>
<li>动态解析实例方法： **resolveInstanceMethod()**用来动态解析实例方法，在运行时可以动态的将对应的方法实现添加到类实例所对应的类的消息列表中。</li>
<li>动态解析类方法： **resolveClassMethod()**用来动态解析类方法，同样可以在运行时动态的将对应的类方法添加到类的消息列表中。</li>
</ul>
<p><strong>举例：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(testInstanceMethod)), <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testInstanceMethod&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(testClassMehotd)), <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)testClassMehotd&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<strong>test()<strong>方法仅仅声明，没有实现。在运行时，runtime则会进入到消息的动态解析。需要注意的是，动态解析类方法时，方法</strong>class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)<strong>中的第一个参数，需要使用</strong>object_getClass()<strong>进行获取后传参。因为在动态解析类方法时，需要将方法的实现添加到当前类的isa指向类中，而类的指向类为</strong>元类</strong>。</p>
<ul>
<li>当<strong>self</strong>是实例对象时，**[self class]** 和 **object_getClass(self)**等价，因为前者会直接调用后者，都是返回对象实例所对应的类。</li>
<li>当<strong>self</strong>是类对象时，**[self class]<strong>返回类对象本身，而</strong>object_getClass(self)**返回类对应的元类。</li>
</ul>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当动态解析依然失败，runtime则进入到消息转发流程。<strong>消息转发，是将当前消息转发到其他对象进行处理。</strong> 在NSObject中，针对消息转发提供了专门的API来处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发类方法，id返回的是类对象</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel;</span><br><span class="line"><span class="comment">// 转发实例方法，id返回的是实例对象</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure>

<p><strong>消息转发示例</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="keyword">return</span> testForward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>testForward</strong>为实现了<strong>test</strong>方法的实例对象。如果没有实现<strong>forwardingTargetForSelector</strong>，或者该方法返回<strong>nil</strong>或者<strong>self</strong>，则runtime会进入到另一个转发流程。此时runtime会依次调用**- (NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector<strong>，获取方法签名，然后根据方法签名，包装成了一个</strong>NSInvocation*<em>对象，并调用</em></em>- (void)forwardInvocation:(NSInvocation *)anInvocation**，此时无论转发的消息是否实现，系统都会默认消息已经得到了解析，从而避免崩溃。</p>
<p><img src="/images/runtime/2/message-forward.jpg"></p>
<p>消息转发实际上是将消息转发给另一个对象进行处理，而消息动态解析是在当前类的范围内进行处理。</p>
<h2 id="消息转发与多继承"><a href="#消息转发与多继承" class="headerlink" title="消息转发与多继承"></a>消息转发与多继承</h2><p>通过消息转发流程，可以模拟实现Objective-C语言的多继承机制，具体可查看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Runtime官方文档</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Objective-C语言中，方法调用实现的底层机制为<strong>消息发送机制</strong>。在开发中，类的实例对象不能调用类方法，原因是类的实例对象在查找消息IMP的流程仅仅是查找类的方法列表，而对于类方法而言，其实现存放在元类的方法列表中，因此实例对象通过objc_msgSend方法是找不到对应类消息的IMP的。</p>
<p>类大多数情况下是不能调用实例方法的，除非实例方法定义在根类中，即NSObject中。因为当调用类方法是，会在元类的继承链的方法列表中查找对应的IMP，而跟元类对应的父类是NSObject，因此在NSObject中定义的实例方法，其实是可以通过类方法形式来调用的。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/7/cover.jpeg" alt="\#7\ Stack &amp; Stack Simple Challenges"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1820个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/">\#7\ Stack &amp; Stack Simple Challenges</a></h1><div class="content"><p><strong>栈（Stack）</strong>是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属于一种受限的线性表结构。栈的操作特性通常被称为**后进先出(LIFO-last in first out)<strong>的方式，另一种数据结构队列的操作特性与栈有着不同，通常称为</strong>先进先出(FIFO-first in first out)**。</p>
<h2 id="栈的一般操作"><a href="#栈的一般操作" class="headerlink" title="栈的一般操作"></a>栈的一般操作</h2><p>栈是一种很有用，但是相对简单的数据结构。构建栈类型数据结构的主要目标是数据的访问权限和方式问题。相比于链表而言，栈并没有链表那个复杂和琐碎。</p>
<p>对于栈来说，主要的操作有两个，即上述所说的<strong>压栈</strong>和<strong>出栈</strong>的操作：</p>
<ul>
<li><strong>push：</strong>添加一个元素到栈顶；</li>
<li><strong>pop：</strong>从栈顶删除一个元素</li>
</ul>
<p>也就是说，对于栈而言，只能从栈的一边添加或者移除元素，也就是上述所说的**后进先出(LIFO-last in first out)**的方式。在计算机编程中，栈的身影无处不在，例如下面几个场景中，都是栈的理念和其应用的结果：</p>
<ul>
<li>在iOS中,导航控制器的作用是将视图控制器的视图弹出或者弹入，并且最新弹出的总是最后弹入的视图控制器视图；</li>
<li>内存分配在体系结构级别使用堆栈。局部变量的内存也使用堆栈进行管理；</li>
<li>Search和conquer算法，例如从迷宫中寻找路径，均使用堆栈来方便回溯。</li>
</ul>
<h2 id="栈数据结构实现"><a href="#栈数据结构实现" class="headerlink" title="栈数据结构实现"></a>栈数据结构实现</h2><p>首先定义栈的基础结构，对于栈而言，其核心就是一个列表，只是再具体的操作时有LIFO的限制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> topDivider <span class="operator">=</span> <span class="string">&quot;---- top ----<span class="subst">\n</span>&quot;</span></span><br><span class="line">        <span class="keyword">let</span> bottomDivider <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span> -----------&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> stackElements <span class="operator">=</span> storage</span><br><span class="line">            .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span> &#125;</span><br><span class="line">            .reversed()</span><br><span class="line">            .joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> topDivider <span class="operator">+</span> stackElements <span class="operator">+</span> bottomDivider</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在栈的数据结构中使用列表的方式进行数据存储，是因为对于列表来说，在其一端进行操作 — <strong>append</strong> 和<strong>popLast</strong>，都属于恒定时间的复杂度O(1)。也更是促进了栈的进栈和出栈特性的性能表现。</p>
<h2 id="push-amp-pop-操作"><a href="#push-amp-pop-操作" class="headerlink" title="push &amp; pop 操作"></a>push &amp; pop 操作</h2><p>在栈的数据结构定义中，增加基本的压栈和出栈操作，压栈操作直接使用列表的<strong>append</strong>，出栈使用<strong>popLast</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">    storage.append(element)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.popLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个基本操作来说，实现也非常直截了当。接下来对其进行实际测试，在主Playground中，进行测试代码编写。</p>
<blockquote>
<p>在进行测试前，可以将<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/03/Data-Structures-&-Algorithms-in-Swift-04.html">\#4\ Linked List 的Swift实现
</a>中的<strong>Helper.swift</strong>拷贝到当前工程中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;using a stack&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">4</span> <span class="operator">==</span> poppedElement)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">---Example of using a stack---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展性操作"><a href="#扩展性操作" class="headerlink" title="扩展性操作"></a>扩展性操作</h2><p>对于栈来说，除了常用的push和pop操作之外，还有一些额外的操作，能够提高对栈的使用等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.last</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// isEmpty</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> peek() <span class="operator">==</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>peek()：</strong>获取栈顶元素</li>
<li><strong>isEmpty：</strong>判断栈是否为空</li>
</ul>
<h2 id="Less-is-more"><a href="#Less-is-more" class="headerlink" title="Less is more"></a>Less is more</h2><p>在链表的实现中，我们使用了Swift标准库中的Collection协议，那么在栈的实现中是否也能够使用Collection协议呢？栈的目的是有限制的访问数据，通过迭代或者下标的方式即可实现该目标，但是对于Collection协议来说，并不止于此，因此在栈上使用Collection协议和栈的最初目标是相互制约的。在这种情况下，少即是多！</p>
<p>您可能希望采用现有数组并将其转换为栈，以便保证访问顺序，也可以循环遍历数组元素以及添加元素。对于栈来说，为了能够对栈的操作有一个统一的初始化存储方式，可以定义其初始化方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">elements</span>: [<span class="type">Element</span>]) &#123;</span><br><span class="line">    storage <span class="operator">=</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from a array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>(array)</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from a array---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述实现中，将一个数组转化为了栈，并且栈中元素的数据类型是String，也就意味着栈中可以放置多种类型的数据元素。</p>
<p>既然可以使用数组直接转化为栈，那么是否可以直接使用数组的方式初始化栈呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">ExpressibleByArrayLiteral</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">arrayLiteral</span> <span class="params">elements</span>: <span class="type">Element</span>...) &#123;</span><br><span class="line">        storage <span class="operator">=</span> elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from an array literal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack: <span class="type">Stack</span> <span class="operator">=</span> [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>]</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from an array literal---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4.0</span></span><br><span class="line"><span class="comment">3.0</span></span><br><span class="line"><span class="comment">2.0</span></span><br><span class="line"><span class="comment">1.0</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在搜索树和图的问题求解中，栈至关重要。例如在查找迷宫的路径方法中，每次叨叨左、右、前或后的决策点时，都可以将所有可能的决策点压入栈中，当栈顶的路径是一个死胡同时，只需要从栈中弹出并继续下一个判断，直到走出迷宫即可。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>栈的数据结构虽然非常简单，但栈是解决很多问题的关键性数据结构；</li>
<li>对于栈爱说，只有两个基本操作，分别是压栈<strong>push</strong>和出栈<strong>pop</strong>。</li>
</ul>
<h2 id="栈的挑战"><a href="#栈的挑战" class="headerlink" title="栈的挑战"></a>栈的挑战</h2><h2 id="Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。"><a href="#Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。" class="headerlink" title="Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。"></a>Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。</h2><blockquote>
<p>在<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/05/Data-Structures-&-Algorithms-in-Swift-06.html">\#6\ Linked List 挑战</a>中我们使用了递归的方式，反向打印了一个链表的节点。在这里将使用栈的结构进行，避免递归调用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverseNoRecursion</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> current &#123;</span><br><span class="line">        stack.push(node.value)</span><br><span class="line">        current <span class="operator">=</span> node.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> value <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Print Linkedlist reverse without recursion&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverseNoRecursion(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Print Linkedlist reverse without recursion---</span></span><br><span class="line"><span class="comment">Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">Printing in reverse: </span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如："><a href="#Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如：" class="headerlink" title="Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 （ 和 ） 字符，如果字符串中的括号是平衡的，则返回 true。例如："></a>Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 <code>（</code> 和 <code>）</code> 字符，如果字符串中的括号是平衡的，则返回 <code>true</code>。例如：</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1 h((e))llo(world)() // balanced parentheses</span><br><span class="line"></span><br><span class="line">// 2 (hello world // unbalanced parentheses</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkParentheses</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> string &#123;</span><br><span class="line">        <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;(&quot;</span> &#123;</span><br><span class="line">            stack.push(character)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;)&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> stack.isEmpty &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;check parentheses&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> <span class="string">&quot;h((e))llo(world)())&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> checkParentheses(string)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of check parentheses---</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-14-cart/"><img class="fill" src="/images/cart/cover.jpg" alt="什么是决策树"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">17 分钟读完 (大约2597个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-14-cart/">什么是决策树</a></h1><div class="content"><p>决策树(Decision Tree）是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。Entropy &#x3D; 系统的凌乱程度，使用算法ID3, C4.5和C5.0生成树算法使用熵。这一度量是基于信息学理论中熵的概念。<br>决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。<br>分类树（决策树）是一种十分常用的分类方法。他是一种监管学习，所谓监管学习就是给定一堆样本，每个样本都有一组属性和一个类别，这些类别是事先确定的，那么通过学习得到一个分类器，这个分类器能够对新出现的对象给出正确的分类。这样的机器学习就被称之为监督学习。</p>
<h2 id="什么是决策树？"><a href="#什么是决策树？" class="headerlink" title="什么是决策树？"></a>什么是决策树？</h2><p>有的人可能听过一个词：<strong>CART</strong>，这个代表的意思是<strong>Classification And Regression Tree</strong>。它是一个分类和回归的决策树。它被分为两类，一类是<strong>分类决策树</strong>(Classification Trees)，另一个类是<strong>回归决策树</strong>(Regression Trees)。也就是我们要用这个决策树解决两类问题，一个分类问题一个回归问题。</p>
<p><img src="/images/cart/cart.png"></p>
<p>对于分类决策树，一般来说用于一些分类离散的数据，比如说人的性别是男或者女，水果的种类有苹果梨子等等都是离散的。反之回归决策树，那么对应的场景就是连续的数据，比如人的年龄或者室外的温度。当我们进行分类问题时，分类的组之间是无序的。这里首先介绍下什么是有序，可以举个例子比如年龄，又年龄大或者年龄小。那么对于性别问题，男或女，它是没有顺序的。本文要讲的是分类问题在决策树上的应用。</p>
<p>来看个例子，在一个二维平面上有两个颜色分组的数据，我们要用决策树算法来构建分类器。这里的决策树算法要做的事情就是不断用水平和竖直的线不断对平面进行分隔，直到某一个区域类只有红类或者绿类。如图所示，我们画出几条线对平面进行分隔。</p>
<p><img src="/images/cart/cart-split.png"></p>
<p>这样图中的红组和蓝组的数据点就被这些数据分隔开来了，但这组数据是为了方便展示而特地画成这个样子的，实际情况并不一定会出现这种比较清晰的分割线。那我们先看看第一条分割线，将其分割成了上下两块区域，虽然两边都是既有红色又有蓝色，但我们可以说分类的结果还是比较纯的。用复杂点的数学语言来说就是，我们正在寻找一条分隔线，可以是水平的也可以是竖直的，我们想要做一个优化的问题，需要最小化分隔后的基尼不纯度。什么叫纯，指的是分隔后的一边如果只有红点或者绿点，那么可以说这个分隔的结果是非常纯的，那么如果两边既有红也有蓝，那么就是不纯的。我们希望当我们添加一条分割线后，想要将两边的纯度和最小化。那么每一条的分割线的寻找实际上就是在做一个优化的问题，那么优化的对象可以是基尼不纯度，也可以是信息学中的熵。这里不做过多解释，只是展示下决策树是如果运作的。</p>
<p>画出第一条分隔线后如图可以得到两组分类结果，一个是x2小于或者不小于60，再然后我们画出第二条分割线，看出x1&lt;50是绿组，否则就是红组，接着再画出第三条分割线，x1&lt;70都是红组，再对x1&gt;70分隔，得出红组和绿组数据。</p>
<p><img src="/images/cart/cart-tree.png"></p>
<p>如图其实就是上述所说的工作流程，我们得到的每一片叶子都是比较纯的结果，如果在实际实际生活中，数据可能非常复杂，那么我们的树可能就非常非常大，枝节非常非常多。那么有的时候，有的枝节不一定非要到最后知道yes or no，也许可能在前面某个枝节就停止了。比如对于x2&lt;20这里不再继续分割，假设有个新的数据点落在了这个区域，它落在绿色的区域的概率比落在红色的概率要大，那么我们就可以把这一部分都划分到绿色组中，也就是说可以剪掉多余的枝节，也许它对于训练集是有意义的，但对于更多其他的数据来说，它可能就是个噪音，我们不需要知道这么详细的信息。那最终就没有这两片叶子，到前面一步就结束了。</p>
<p>决策树算法是个很经典的机器学习算法，很多年以前是比较流行的。但到了20世纪初已经逐渐被其他算法所取代。直到最近又发现这个算法中一些新的精妙的东西，比如说随机森林，就是以决策树为根本来展开的。还有提升梯度(Gradient Boosting)等等都是在决策树算法之上我们加上了一些新的元素。</p>
<p>代码实现<br>由于这次决策树算法，我们没有使用欧式距离，也就是说可以不用进行特征缩放。但最终画图像时之前模版中定义的步距可能就过大或者过小，所以这里就妥协一下保留特征缩放的代码。分类器改成决策树算法的DecisionTreeClassifier。这个方法的参数criterion指的就是标准，默认gini，即基尼指数或者说基尼不纯度。它和熵都是表示分类时划分质量的好坏。这里我们使用熵。其他的参数暂时用不到,random_state依然只是用来大家如果想得到相同的结果时就设置为相同的值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">classifier = DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,random_state=)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>

<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>在开始讲随机森林之前我们先讲一个更为广义的概念: Ensemble Learning，集成学习。它的意思是我们使用多个分类器对我们的结果进行预测，最后再对分类结果进行一个组合，以达到最终的结果。这个组合的方式有很多种，比如平均，加权平均或者投票等等。这个集成学习的作用就是，我们觉得任何一个单独的分类器去分类结果回感觉有误差，这时可以用成百上千个分类器都进行预测，然后再对结果进行一个组合，可以减少预测结果的浮动率。下面来看看随机森林算法的步骤。</p>
<p>首先，随机采用训练集合中的数据，相当于装袋的过程，构建自己新的训练集；然后用这些数据训练决策树分类器；再然后实际上就是重复第一第二步，但每一次得到的结果是不同的，因为在第一步中我们取得的数据都是随机的。对于一个新的数据点，我们用已经训练好的多个训练器分别对这个新数据的分类进行预测，最后进行一个投票，拥有最大投票数量的分类结果胜出就使用这个分类结果。</p>
<p><img src="/images/cart/random-forest.png"></p>
<p>前文讲述了如何构建一棵决策树，现在拥有成百上千棵决策树来帮助我们解决分类问题。这个分类算法还有不少数学上的一些细节问题，比如Boosting(提升)，还有当我们有高维度的情况时，我们每次选取数据时可能只选取部分维度，这样可以避免个别维度比其他维度大的多情况。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里依然开始先套用分类的模版，然后换成随机森林分类器，这里的参数n_estimators指的是决策树的数量,这里暂时设置成10 criterion依然设置为entropy。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">classifier = RandomForestClassifier(n_estimators=<span class="number">10</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>, random_state=<span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>

<p>通过结果观察，这里使用随机森林分类器是会出现过拟合的情况。对比这几篇文章中的分类器，实际上最适合的是核svm和朴素贝叶斯，线性分类器准确度不够，随机森林分类器会出现过拟合，而这两者它们保证了拟合的准确率，并且也不会出现过拟合的问题。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-08-31-technical-debt/"><img class="fill" src="/images/technical-debt/cover.jpeg" alt="技术债务，到底应该怎么还？"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">24 分钟读完 (大约3665个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-08-31-technical-debt/">技术债务，到底应该怎么还？</a></h1><div class="content"><p>几乎所有的技术团队，都会经历或多或少的技术债务，技术债务虽然是实现快速收益的一种捷径，但是为了修复哪些为了快速收益而不得不为之的技术问题，企业往往需要花费大量的金钱、人力等。那么如何有效地避免技术债务，使得开发人员更多的精力投入在有效的工作，从而产生额外价值，提高企业的产品竞争力呢？</p>
<p>技术债务的产生有着很多的原因，但是其中更多的是由于匆忙的工作使得原来耗时较长的工作，在短时间内完成，导致部分业务逻辑没有完整的设计等，使得产品在短时间内有效，但是长远来看，却是一颗不稳定的炸弹，一旦触发，对产品、对企业都有可能造成无法挽回的损失。总而言之，技术债务会带来很多麻烦，有些甚至是“致命”的。</p>
<blockquote>
<p>本文以发布至：<a target="_blank" rel="noopener" href="https://weibo.com/ttarticle/p/show?id=2309404395386419675203">技术专栏丨技术债务，到底应该怎么还？</a></p>
</blockquote>
<h2 id="什么是技术债务？"><a href="#什么是技术债务？" class="headerlink" title="什么是技术债务？"></a>什么是技术债务？</h2><p><img src="/images/technical-debt/what-is-technical-debt.png"></p>
<blockquote>
<p>技术负债（英语：Technical debt），又译技术债，也称为设计负债（design debt）、代码负债（code debt），是编程及软件工程中的一个比喻。指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。 </p>
<p>摘自 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA">维基百科</a></p>
</blockquote>
<p>很多人将技术债务类比于金融债务，但是和金融债务不同的是，技术债务可能不会承担利息。例如当需要快速验证产品的某个特点的时候，带有一定技术债务的产品可能是个好的选择，当验证之后，无需该特点的时候，可以直接移除等，此时可能不会承担债务利息。但是大多数情况下，此类情况较少，就算仅仅是为了验证产品，也不建议使用技术债务的方式去实施。类似这样方式的技术债务可称为有意的技术债务，另一种更加危险的技术债务称为无意的技术债务，无意的技术债务就像是前文说到的隐藏在代码中的炸弹。</p>
<p>无论是那种技术债务，在未来的产品迭代过程中，都需要开发人员去界定债务边界，不能任由技术债务滋生，否则在迭代过程中，面临的困难越来越多，甚至需要被迫承担更多的技术债务。基本上，你承担的债务越多，项目的进度就越慢，项目的后续阶段就会更加困难。</p>
<p>但是需要清楚的是，技术债务是无法消除的，你必须随时做好承担技术债务的准备。因为在一些项目场景中，一些具体问题的解决方案本身是可以解决问题的，但是该方案可能不是全局有效或最佳的，在系统的其他方面，就形成了一个不可避免而必须承担的技术债务问题。一个好的工程师团队应该是最小化技术债务影响，并对技术债务进行合理管理的团队。</p>
<p><img src="/images/technical-debt/techdebttype.png"></p>
<p>上文提到，技术债务分为<strong>有意的技术债务</strong>和<strong>无意的技术债务</strong>，两种形式的技术债务形成的原因和带来的结果也是不同的。在某些情况下，有意的技术债务相比无意的技术债务更好，有意的技术债务会让团队意识到问题，从而有意的去进行优化改进等，而无意的技术债务可能在项目中潜伏很长一段时间，可能导致严重的问题，然而，无意的技术债务在项目中是无法避免的，在工程师团队中可以强化编码规范、业务理解等来进行管理或者减弱技术债务出现的可能。</p>
<p>另外还可以将技术债务分类为<strong>鲁莽型技术债务</strong>和<strong>谨慎型技术债务</strong> 。一些谨慎型的技术债务在项目的进度中是可取的，但是不论是那种技术债务，都需要每个人用于去承担，两者是共同工作的。理想的情况下，承担的债务应当是哪些有意的和谨慎的技术债务，而哪些无意的和鲁莽的技术债务应当不惜一切代价避免。</p>
<h2 id="为什么要关心技术债务？"><a href="#为什么要关心技术债务？" class="headerlink" title="为什么要关心技术债务？"></a>为什么要关心技术债务？</h2><p><img src="/images/technical-debt/why-care-about-technical-debt.png"></p>
<h3 id="技术债务如何影响开发"><a href="#技术债务如何影响开发" class="headerlink" title="技术债务如何影响开发"></a>技术债务如何影响开发</h3><p>在开发阶段，开发人员不可避免会遇到技术债务，开发人员应当直面技术债务，并处理技术债务问题。虽然处理技术债务可能会使得开发周期变长，但从长远来看，开发人员及时处理技术债务是有益的，一方面处理技术债务是一个技术经验积累的过程，另一方面及时的处理在之后的迭代中也减少了技术债务产生的可能等。每一个开发员都应当有意的或者尽力地避免那些无意的技术债务和鲁莽的技术债务等。</p>
<h3 id="技术债务如何影响客户"><a href="#技术债务如何影响客户" class="headerlink" title="技术债务如何影响客户"></a>技术债务如何影响客户</h3><p>虽然乍看起来，技术债务和客户并无联系，客户也不太关心产品的代码质量等，客户只需要在成本没有增加的情况下，产品按时交付使用。然而，一个携带无意或者鲁莽的技术债务的产品在开发过程中，往往需要花费更多的时间、精力和资源，导致成本增加，但是收益却减少的情况等。</p>
<p><img src="/images/technical-debt/techdebtcost.png"></p>
<h3 id="技术债务如何影响用户"><a href="#技术债务如何影响用户" class="headerlink" title="技术债务如何影响用户"></a>技术债务如何影响用户</h3><p>即使是间接的，用户也会受到技术债务的影响。 他们可能不关心软件中的工作量或资金数量，但他们确实关心它的可靠运行，以及快速添加的新功能，这两者都可能受到大量技术债务的影响。 用户越快乐，客户越快乐，开发者越快乐。</p>
<h2 id="技术债务最佳实践"><a href="#技术债务最佳实践" class="headerlink" title="技术债务最佳实践"></a>技术债务最佳实践</h2><p><img src="/images/technical-debt/technical-debt-best-practices.png"></p>
<p>解决科技债务的最大问题是，它无法真正量化。这使得开发团队很难跟踪并让管理层向客户展示为什么要投入更多的资源和时间。</p>
<p>但是这里有一些你可以做的事情：</p>
<h3 id="保持最新状态"><a href="#保持最新状态" class="headerlink" title="保持最新状态"></a>保持最新状态</h3><p>不言而喻，工具，框架和库应该始终保持最新状态，可能你还未意识到这个问题所带来的影响，那只是你还没意识到而已。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>记录需要修复或更新的所有内容是确保实际修复和更新的最重要步骤。</p>
<p>如果存在技术债务，最好了解它并确保团队或未来的开发人员也知道。 文档减少了定位和修复任何问题所需的工作量，如果债务记录良好，甚至可能在业务层面上可见，将可能导致客户承认并提供额外资源。</p>
<h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><p>另一个强大的工具是在sprint期间定期审查代码。 代码审查可以捕捉到可能导致问题的隐患，并找到解决方案。 代码评审确实需要一些时间，但在整个项目的背景下肯定是值得的。</p>
<p>但是，代码审查也有其缺点。 开发人员往往太忙，无法深入挖掘他人的代码，因此他们只会发现明显的错误，而挑剔可能会导致团队内部紧张。 因此，它可以成为减少技术债务的有力工具，但应该谨慎应用。</p>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>自动化测试是一种非常强大的工具，但是经常被忽视。 自动化测试被忽略后，代码中的隐藏问题可能会无法察觉出，往往导致产品发布后需要投入不成比例的人力和时间来应对，是的成本变高甚至不可控。在开发阶段，有必要实施测试驱动开发，编写完善的测试用例，以清除代码中的许多不易察觉的问题等。</p>
<h3 id="敏捷架构"><a href="#敏捷架构" class="headerlink" title="敏捷架构"></a>敏捷架构</h3><p>敏捷架构具有很多优点，在构建软件的过程中对更改更加开放，基本上保证在任何项目上都会发生。 但是，它确实要求代码具有灵活性和可维护性，因此敏捷方法自然会使开发人员保持良好的代码，这有助于防止大量技术债务的积累。</p>
<h3 id="有效地复盘"><a href="#有效地复盘" class="headerlink" title="有效地复盘"></a>有效地复盘</h3><p>如果出现问题，应该用于面对，当问题解决后，需要进行有效地复盘。 但是要注意的是复盘是为了提高工作效率，绝不应该是找人责备。 复盘的重点应放在了解问题及其产生的原因上，以便团队可以采取必要措施防止同样的问题再次发生。 </p>
<h2 id="管理技术债务的最佳做法"><a href="#管理技术债务的最佳做法" class="headerlink" title="管理技术债务的最佳做法"></a>管理技术债务的最佳做法</h2><p><img src="/images/technical-debt/manage-technical-debt.png"></p>
<p>即使你做了以上所有事情，并尽可能避免堆积技术债务，你仍然需要处理一些问题。 这是无法避免的，因此您应该实施实践和流程以防止技术债务陷入困境。</p>
<h3 id="高息技术债务优先"><a href="#高息技术债务优先" class="headerlink" title="高息技术债务优先"></a>高息技术债务优先</h3><p>并非所有技术债务都是平等的，因此您应该优先考虑在特定时间解决的问题以及不解决的问题。 对于经常使用和更改的代码而言，比在几乎没有使用或更改过的部分的重要性要重要得多。</p>
<p>高息债务往往是那些在项目中起重要做的核心部分，通常围绕它进行了很多工作并以此为基础。 如果此部分的技术债务保持不变，就会妨碍所有的工作，并可能迫使更多的技术债务被添加到代码的其他部分。 因此，如果有可能，首先应优先考虑这些问题，从长远来看，使一切变得更加顺畅。</p>
<h3 id="童子军规则"><a href="#童子军规则" class="headerlink" title="童子军规则"></a>童子军规则</h3><p>“要始终保持营地比你发现它的时候更清洁”也是适用于软件开发的：“提交的代码比检出的要更好”。鼓励团队成员，以积极减少技术债务 ; 例如，当他们发现了一块为了功能增加或错误修复的代码时激励他们重构。</p>
<p>当然，它不能没有边界，否则它可能是一直消耗。 但是，如果你在每个sprint中留出一定比例的时间专门用于修复开发人员可能发现的任何技术债务，那么它可以在很大程度上保持产品尽可能无债务。</p>
<p><img src="/images/technical-debt/techdebtcruft.png"></p>
<h3 id="在履行有价值的客户工作时偿还债务"><a href="#在履行有价值的客户工作时偿还债务" class="headerlink" title="在履行有价值的客户工作时偿还债务"></a>在履行有价值的客户工作时偿还债务</h3><p>在项目的整个冲刺阶段，用于修复技术债务不是一个好主意。 一方面，客户往往不喜欢延期，对他们来说，看起来你似乎花了他们的时间和金钱来解决你做错的事情。另一方面，它也表明你已经做了大量的技术债务工作，所以你可能已经支付了更高的债务利息。</p>
<p>你最好指定在每个冲刺中偿还技术债务所花费的时间，并用它来解决高优先级或发生过的问题。 让客户满意，并使技术债务处于可控水平。</p>
<h3 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h3><p>同样重要的是要注意技术债务不应该总是得到偿还。 当产品接近其使用寿命时，如果它是短期制造的，或者它是一次性原型，技术债务不是主要问题。 这些实例很少见，但是当它们出现时你可以节省一些时间和精力。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>技术债务是伴随着项目的，无法避免，但是如何保持其在可控范围之内，是我们应该思考的问题。技术债务的避免和消除都需要好的优秀的开发人员，人始终是软件开发中最重要的因素。作为一名普通的码农，不断地提升自己是非常必要的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://codingsans.com/blog/technical-debt">TECHNICAL DEBT: EVERYTHING YOU NEED TO KNOW, AND HOW TO MANAGE IT</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA">技术负债</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/managing-technical-debt/">技术债治理的四条原则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2009/10/dissecting-technical-debt/">解析技术债务</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.096Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item">18 分钟读完 (大约2675个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-06-23-iOS-runtime-basic-structure/">Runtime剖析01 --- 基本数据结构：objc_object &amp; objc_class</a></h1><div class="content"><p>众所周知，Objective-C语言是一门动态性很强的语言，与C、C++等语言有着很大的不同。Objective-C语言的动态性基本上都是由Runtime机制进行支撑和实现的，Runtime的实现，融合了C、C++，以及汇编语言。</p>
<h2 id="什么是Runtime？"><a href="#什么是Runtime？" class="headerlink" title="什么是Runtime？"></a>什么是Runtime？</h2><p>C、C++等静态语言中的各种数据结构都是在编译期已经决定了，不能被修改，而Objective-C作为动态性语言，在程序的运行期，可以动态修改一个类的结构，例如修改方法的实现，变量的绑定等等。</p>
<p>Objective-C语言作为动态语言，将原本编译期决定的事情推迟到运行期，仅仅采用编译器是无法完成的，因此就需要运行期有一套自己的运行时系统，而这个系统就是Runtime，也是Runtime存在的意义，以及Objective-C语言运行框架的基石。</p>
<p>在实际的开发中，与Runtime交互的情况大致有三种：</p>
<ol>
<li><strong>Objective-C源码：</strong>大多数情况下，开发者采用的都是直接使用Objective-C语言进行编码，而在Objective-C语言源码的背后，都是由Runtime进行底层支撑，Objective-C语言中所使用的数据类型，在Runtime中都有对应的C语言结构体，甚至汇编语言的实现等。</li>
<li><strong>通过NSObject：</strong>在Cocoa中，大部分的类都继承自NSObject，而NSObject的定义是Runtime决定的。以及NSObject中的大多数方法，都是运行时动态决定的，背后其实是Runtime对应数据结构的支持。例如常用的<code>isKindOfClass</code>和<code>isMemberOfClass</code>检查类是否属于指定的Class的继承体系中；<code>responderToSelector</code> 检查对象是否能响应指定的消息；<code>conformsToProtocol</code> 检查对象是否遵循某个协议；<code>methodForSelector</code>返回指定方法实现的地址等。</li>
<li><strong>直接调用Runtime API：</strong>Runtime是一个由一系列函数和数据机构组成，具有公共接口的动态共享库。很多函数的功能和Objective-C语言中的含有具有同等的功能。一般情况下不会直接访问Runtime的API，但是当有一些底层的需求需要实现时，例如为现有类动态添加属性等。<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective_c_runtime?language=objc">Objective-C Runtime Reference</a></li>
</ol>
<p><strong>Objective-C语言中的各种黑魔法，其实都是在Runtime的基础上，对底层数据机构的各类应用。</strong></p>
<h2 id="NSObject解析"><a href="#NSObject解析" class="headerlink" title="NSObject解析"></a>NSObject解析</h2><p>在Objective-C中，几乎所有的类的基类，都是<strong>NSObject</strong>。因此要深入了解Objective-C类的相关结构，先从<strong>NSObject</strong>类开始。</p>
<p>在iOS SDK中，对于NSObject类的定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Wobjc-interface-ivars&quot;</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NSObject</strong>类仅有一个实例变量<strong>isa</strong>，并且遵循<strong>NSObject</strong>协议。先说说<strong>NSObject</strong>协议，在该协议中，定义了NSObject类的一些通用方法，例如<code>performSelector：</code>、<code>isMemberOfClass</code>、<code>superclass</code>等等，使用协议去定义通用的一些方法，也让类的扩展更加的容易。</p>
<p><strong>NSObject</strong>类的变量仅有<strong>Class isa</strong>，变量的类型<strong>Class</strong>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>Class</strong>本质是指向<strong>objc_class结构体</strong>的指针，而<strong>objc_class结构体</strong>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h2><p>可以看到<strong>objc_class</strong>继承自<strong>objc_object</strong>，即在Runtime中，class本质也是一个对象。在<strong>objc_class</strong>结构体的定义中，有三个成员变量：</p>
<ul>
<li><strong>Class superclass：</strong> 表示当前类的父类对象，类型同样是<strong>Class</strong>；</li>
<li><strong>cache_t cache：</strong> Objective-C方法调用的优化结构体。对应的数据结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="type">bucket_t</span> *<span class="title function_">buckets</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">mask_t</span> <span class="title function_">mask</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">mask_t</span> <span class="title function_">occupied</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">incrementOccupied</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setBucketsAndMask</span><span class="params">(<span class="keyword">struct</span> <span class="type">bucket_t</span> *newBuckets, <span class="type">mask_t</span> newMask)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">initializeToEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">capacity</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isConstantEmptyCache</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">canBeFreed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">	explicit_atomic&lt;<span class="type">uintptr_t</span>&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">public:</span><br><span class="line">	<span class="keyword">inline</span> SEL <span class="title function_">sel</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> _sel.load(memory_order::memory_order_relaxed); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> IMP <span class="title function_">imp</span><span class="params">(Class cls)</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="type">uintptr_t</span> imp = _imp.load(memory_order::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (!imp) <span class="keyword">return</span> nil;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_PTRAUTH</span></span><br><span class="line">        SEL sel = _sel.load(memory_order::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">return</span> (IMP)</span><br><span class="line">            ptrauth_auth_and_resign((<span class="type">const</span> <span class="type">void</span> *)imp,</span><br><span class="line">                                    ptrauth_key_process_dependent_code,</span><br><span class="line">                                    modifierForSEL(sel, cls),</span><br><span class="line">                                    ptrauth_key_function_pointer, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_ISA_XOR</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)(imp ^ (<span class="type">uintptr_t</span>)cls);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> CACHE_IMP_ENCODING == CACHE_IMP_ENCODING_NONE</span></span><br><span class="line">        <span class="keyword">return</span> (IMP)imp;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Unknown method cache IMP encoding.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;Atomicity, IMPEncoding&gt;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">set</span><span class="params">(SEL newSel, IMP newImp, Class cls)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cache</strong>结构体的核心是类型为<strong>bucket_t</strong>的指针，指向以**_imp<strong>和</strong>_sel**对应的缓存点。</p>
<blockquote>
<p><strong>uintptr_t</strong>数据类型定义为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UINTPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UINTPTR_T</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>           uintptr_t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _UINTPTR_T */</span></span></span><br></pre></td></tr></table></figure>

<p>本质类型为无符号长整型数据类型，在runtime中，大多数基本数据类型均为无符号长整型，例如**void ***。</p>
</blockquote>
<p>上文已经提到，<strong>cache</strong>的存在是为了优化方法的调用，在Runtime中方法的调用流程：</p>
<ol>
<li>当要调用一个方法时，首先去当前类的<strong>cache</strong>方法缓存中寻找，如果存在，则直接执行；</li>
<li>如果<strong>cache</strong>中不存在，则会去当前类的方法列表中寻找，找到后执行并将该方法按照实现**_imp<strong>和方法签名</strong>_sel<strong>存放在</strong>cache**中，以便下次快速调用。</li>
</ol>
<ul>
<li><strong>class_data_bits_t bits：</strong>该变量可以说是<strong>Class</strong>的核心成员变量，本质是一个可以被Mask的指针类型。根据不同的Mask，取出不同的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    friend objc_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">class_rw_t</span>* <span class="title function_">data</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setData</span><span class="params">(<span class="type">class_rw_t</span> *newData)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="comment">// Set during realization or construction only. No locking needed.</span></span><br><span class="line">        <span class="comment">// Use a store-release fence because there may be concurrent</span></span><br><span class="line">        <span class="comment">// readers of data and data&#x27;s contents.</span></span><br><span class="line">        <span class="type">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="type">uintptr_t</span>)newData;</span><br><span class="line">        atomic_thread_fence(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>class_data_bits_t bits</strong>仅仅包含一个成员变量<strong>bits</strong>，该变量不仅包含指针，同时包含<strong>Class</strong>的各种异或flag，当需要取出信息时，需要用对应的<strong>FAST_<strong>前缀开头的flag掩码对</strong>bits</strong>进行按位与操作。</p>
<p>例如，在获取信息的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">class_rw_t</span>* <span class="title function_">data</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中，通过对<strong>bits</strong>进行<strong>FAST_DATA_MASK</strong>的与操作，返回<strong>class_rw_t *<strong>。</strong>class_rw_t</strong>以及<strong>class_ro_t</strong>可以说是<strong>Class</strong>中的核心结构，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint16_t</span> witness;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">method_array_t</span> <span class="title function_">methods</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">property_array_t</span> <span class="title function_">properties</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="type">const</span> <span class="type">protocol_array_t</span> <span class="title function_">protocols</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>class_rw_t</strong>结构体中，方法列表<strong>method_array_t</strong>、属性列表<strong>property_array_t</strong>、协议列表<strong>protocol_array_t</strong>是可以被Runtime修改和扩展的。</p>
<p>而在<strong>class_ro_t</strong>结构体中包含了类的名称<strong>name</strong>、方法列表<strong>method_list_t</strong>、属性列表<strong>property_list_t</strong>、协议列表<strong>protocol_list_t</strong>等类的基本信息，<strong>class_ro_t</strong>中的信息时不允许修改，并且不可扩展的。</p>
<p><strong>objc_class  &lt;-   class_data_bits_t  -&gt;  FAST_DATA_MASK  &lt;-  class_rw_t   &lt;-  class_ro_t</strong></p>
<h2 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Class <span class="title function_">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="type">const</span> <span class="type">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="type">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>realizeClass</strong>是Runtime构造一个完整的类的入口，在没有调用<strong>realizeClass</strong>之前，类是不完整的。上述函数中，最开始返回的仅仅是<strong>class_ro_t</strong>类的基本信息，在进行<strong>realizeClass</strong>时，将类的Category中定义的各种扩展附加到类上，同时改写<strong>data()<strong>的返回值为</strong>class_rw_t</strong>类型。</p>
<p>因此一个类的完整信息保存在结构<strong>class_rw_t</strong>中，<strong>class_ro_t</strong>结构仅仅保存类的基本信息。</p>
<h2 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h2><p>上述<strong>objc_class</strong>继承自<strong>objc_object</strong>，也就是说在Objective-C中，类也是一个对象，而对象在runtime中被定义为<strong>objc_object结构体</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    Class <span class="title function_">ISA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span></span><br><span class="line">    Class <span class="title function_">rawISA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    Class <span class="title function_">getIsa</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>objc_object结构体</strong>的定义相对较为简单，其中仅包含一个<strong>isa_t</strong>的联合体类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="type">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="type">isa_t</span>(<span class="type">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>isa_t</strong>是一个联合体，可以表示<strong>Class</strong>或者<strong>uintptr_t</strong>类型，在Objective-C 2.0 中大多数使用的是<strong>uintptr_t</strong>类型。其中<strong>bits</strong>是一个64位的数据，每一位或者几位都表示了关于当前对象的信息。</p>
<h2 id="再探objc-object和objc-class"><a href="#再探objc-object和objc-class" class="headerlink" title="再探objc_object和objc_class"></a>再探objc_object和objc_class</h2><p><strong>objc_class</strong>继承自<strong>objc_object</strong>，说明在<strong>objc_class</strong>中也有一个<strong>isa</strong>属性，此时这个属性表示当前类属于哪个类，而这种说明类是属于哪个类的类，称之为<strong>元类（meta-class）</strong>。</p>
<p>元类并不是类的父类，元类在Objective-C的消息转发机制中会由详解，此时，只需要直到，每一个类都有一个与之对应的元类。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>在Objective-C 中，<strong>id</strong>类型经常会被使用到，它表示任意类型的类实例变量，在Runtime中，id的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>

<p>其实id类型就是一个<strong>objc_object *<strong>，因为</strong>objc_object</strong>的<strong>isa</strong>的存在，所有Runtime是可以知道id类型对应的真实类型的。</p>
<blockquote>
<p>**Void ***表示任意类型的指针。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中，从开发者常用的<strong>NSObject</strong>出发，了解了Objective-C语言中类和对象所对应的数据结构<strong>objc_class</strong>和<strong>objc_object</strong>。可以使用一张图了解这三者之间的关系。</p>
<p><img src="/images/runtime/1/nsobject-objc_class-objc_object-relationship.jpg"></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-02-Data-Structures-&amp;-Algorithms-in-Swift-03/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/3/cover.jpg" alt="\#3\ 关于时间复杂度和大O符号"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">23 分钟读完 (大约3431个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-02-Data-Structures-&amp;-Algorithms-in-Swift-03/">\#3\ 关于时间复杂度和大O符号</a></h1><div class="content"><p>算法复杂度的衡量问题在软件开发的诞生早起就已经被提出来，并且有多个方面具体的问题。例如，从系统的架构来看，可伸缩性的架构设计和算法实现，应用程序是如何在数据特征增加的情况下被合理有效地激活的；从数据库的角度来看，数据库的处理能力是否能够应对越来越多的数据和用户行为等。</p>
<p>对于算法而言，可伸缩性指的是算法是否能够随着输入体量的变化，算法在执行时间和内存使用上的变现。</p>
<p>当你面对的是小体量的数据输入时，算法可能运行良好，执行快速，内存使用良好。但是随着数据输入体量的增加，算法的表现可能越来越糟糕，但是具体有多糟糕呢？掌握如何衡量一个算法的优劣是程序开发者的一项重要的技能。</p>
<p>在本篇内容中，我们将从两个角度 — 时间维度和内存使用维度 观察算法的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>问题。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>对于小体量的数据来说，大多数的既定算法能够即快速且高效地在目标设备环境中执行，但是随着数据量的增大、业务逻辑的变化，算法的表现可能会越来越差。<strong>时间复杂度（Time complexity）</strong>是衡量一个算法随着输入大小的改变，其运行耗时的衡量标准，时间复杂度本质上是一个函数，一个关于输入大小和耗时之间的相关性模型。</p>
<h3 id="恒定时间复杂度"><a href="#恒定时间复杂度" class="headerlink" title="恒定时间复杂度"></a>恒定时间复杂度</h3><p><strong>恒定时间</strong>复杂度指的是，算法的执行耗时并不会随着输入体量的改变而改变。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkFirst</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> first <span class="operator">=</span> names.first &#123;</span><br><span class="line">        <span class="built_in">print</span>(first)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no names&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述函数来说，输入<code>names</code>的大小并不会影响该函数的执行时间，无论<code>names</code>中有10个元素还是10万个元素，该函数仅仅检查数组中的第一个元素。对于恒定时间复杂度的算法来说，其时间复杂度可视化后如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/contant-time.png"></p>
<p>在程序员的时间，通常使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>来表示一个算法的时间复杂度，对于恒定时间复杂度的算法，表示为**O(1)**。</p>
<h3 id="线性时间复杂度"><a href="#线性时间复杂度" class="headerlink" title="线性时间复杂度"></a>线性时间复杂度</h3><p>假设有如下的一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printNames</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数打印字符串数组中的每一个元素。随着输入体量的增加，<code>for</code>循环的次数也随之增加，并且两者之间呈现线性的关系。线性时间复杂度的图像可表示为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/linear-time.png"></p>
<p>线性时间复杂度相对较为简单且易于理解。当输入的数据体量增大时，算法的执行耗时会同时增加，这也是其图像是一条直线的原因。对于线性时间复杂度的算法，大O符号表示为**O(n)**。</p>
<h3 id="二次时间复杂度"><a href="#二次时间复杂度" class="headerlink" title="二次时间复杂度"></a>二次时间复杂度</h3><p><strong>二次时间复杂度</strong>通常也被称为<strong>n平方时间复杂度</strong>，是指算法的执行耗时随着输入体量的增加而呈现二次方。例如下方示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printNames</span>(<span class="params">names</span>: [<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">            <span class="built_in">print</span>(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例代码的耗时是数组遍历中再次对数组进行全量遍历的时间总和。如果原始数组中有10个元素，则会打印10个元素10次，总共100次打印操作。</p>
<p>如果输入增加一个单位，则上述打印操作需要执行 11 * 11 次，即总共121次。可视化后的图像如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/quadratic-time.png"></p>
<p>使用大O符号表示为**O(n^2)**。</p>
<h3 id="对数时间复杂度"><a href="#对数时间复杂度" class="headerlink" title="对数时间复杂度"></a>对数时间复杂度</h3><p>到目前为止，已经了解了线性和二次时间复杂性，其中输入的每个元素至少检查一次。但是，在某些情况下，只需要检查输入的子集，从而加快运行速度。</p>
<p>属于此类别的时间复杂性的算法是可以通过对输入数据进行一些假设来利用一些快捷方式的算法。例如，如果您有一个已排序的整数数组，那么查找是否存在特定值的最快方法是什么？</p>
<p>一个普遍的解决方案是从头到尾检查数组，在得出结论之前检查每个元素，由于您检查每个元素一次，这将是一个 <strong>O（n）</strong> 算法，线性时间相当不错，但你可以做得更好，由于输入数组已排序，因此可以进行优化。例如以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">56</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">80</span>, <span class="number">99</span>, <span class="number">105</span>, <span class="number">450</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">naiveContains</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Int</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> element <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你检查458是否在上述数组中的时候，算法将会遍历数组中的每一个元素。假设数组是已经排序好的，你可以尝试使用二分查找的方式，提高算法的执行效率，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">naiveContains</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Int</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">Int</span>]) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> middleIndex <span class="operator">=</span> array.count <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> value <span class="operator">&lt;=</span> array[middleIndex] &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> middleIndex &#123;</span><br><span class="line">            <span class="keyword">if</span> array[index] <span class="operator">==</span> value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> middleIndex <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">            <span class="keyword">if</span> array[index] <span class="operator">==</span> value &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述算法仅仅是进行了一个小的优化，即可将耗时减小一半，说明该优化是有意义的。</p>
<p>该算法首先检查数组的中间值，如果中间值大于目标值，曾说明目标值在数组的前半部分，否则在后半部分。每次只需要检查原有数组的一半的位置即可，这样即节省了内存空间，而且从算法的执行效率或者算法的响应能力上来说，算是一个成功的算法优化。</p>
<p>该算法可以重复有效地丢弃一半的数据，从而提高算法执行效率。对数时间复杂度可视化可表示为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/logarithmic-time.png"></p>
<p>随着输入的增加，耗时的增加相对比较缓慢。如果仔细观察该图像，可以发现耗时呈现不温不火的现象，因为在算法的具体执行中，输入的一半已经被丢弃，算法并不关心他们。</p>
<p>如果你有100个元素，那么算法最终会压缩到50个元素进行检索，如果有100000个元素，最终执行时，算法只关心50000个元素而已。数据越多，丢弃的元素也就越多，最终的执行耗时和数据的输入大小之间便呈现了如上图所示的关系。对数时间复杂度使用大O符号表示为**O(log n)**。</p>
<h3 id="准线性时间复杂度"><a href="#准线性时间复杂度" class="headerlink" title="准线性时间复杂度"></a>准线性时间复杂度</h3><p>另一个常见时间复杂度是<strong>准线性时间复杂度</strong>。准线性时间算法的性能比线性时间差，但明显优于二次时间复杂度。在Swift中典型的算法是数组的<strong>sort</strong>算法。</p>
<p>准线性时间复杂度的大O表示是<strong>O（n log n）</strong>，它是线性和对数时间的乘积。因此，准线性拟合与对数时间与线性时间不相契合；它比线性时间差一个量级，但仍比接下来您将看到的许多其他复杂性要好。下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/3/quasilinear-time.png"></p>
<p>准线性时间复杂性与二次时间有着类似的曲线，但对大型数据集的弹性更大。</p>
<h3 id="其他时间复杂度"><a href="#其他时间复杂度" class="headerlink" title="其他时间复杂度"></a>其他时间复杂度</h3><p>上述五种时间复杂度是程序开发中经常遇到的，还有其他的一些时间复杂度，例如多项式时间、指数时间、因子时间等。但是需要说明的是，时间复杂度并不能判断算法的执行速度，两种算法可能具有相同的时间复杂度，但是其中一种可能仍比其他算法快得多，对于小型数据集，时间复杂度可能不是实际算法执行时间的准确衡量。</p>
<p>例如，如果数据集较小，则插入排序等二次算法可能比准线性算法（如合并排序）更快。这是因为插入排序不需要分配额外的内存来执行算法，而合并排序需要分配多个数组。对于小型数据集，相对于算法需要接触的元素数，内存分配可能会非更加昂贵。</p>
<h2 id="时间复杂度的比较"><a href="#时间复杂度的比较" class="headerlink" title="时间复杂度的比较"></a>时间复杂度的比较</h2><p>假设你编写了一个求从 1 到 n 和的算法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> <span class="operator">...</span> n &#123;</span><br><span class="line">        result <span class="operator">+=</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码中的循环将执行10000次，最终得到结果50005000。该算法是O(n)时间复杂度。但是如何改进一下该算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne2</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> <span class="operator">...</span> n).reduce(<span class="number">0</span>, <span class="operator">+</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne2(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>解决同样的问题，但是该实现的执行上会比上面循环的代码快很多，但是这里的时间复杂度依然是O(n)。使用<code>reduce</code>时，系统内部会执行 <code>n</code>次加法，但是调用的是Swift标准库中已经编译的代码，因此省去了很大一部分代码的编译时间。</p>
<p>继续优化上述代码，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sumFromOne3</span>(<span class="params">upto</span> <span class="params">n</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n <span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> n <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumFromOne3(upto: <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>整个版本的算法使用了弗雷德里克·高斯算法，可以使用简单的算术计算总和。该算法的最时间复杂度是<strong>O（1）</strong>，属于恒定时间算法。也是该特定问题在时间复杂度上的的最优算法。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的时间复杂度有助于预测算法的可伸缩性，但它并不是唯一的指标。<strong>空间复杂性是算法运行所需的资源的度量。</strong> 对于计算机而言，内存一直是昂贵而紧俏的资源。假设有以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printSorted</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> sorted <span class="operator">=</span> array.sorted()</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> sorted &#123;</span><br><span class="line">        <span class="built_in">print</span>(element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个排序后的数组拷贝并遍历该数据，打印其中元素。为了计算其空闲复杂度，需要分析该函数的内存开辟情况。</p>
<p>**array.sorted()**方法的调用系统会新建一个和原数组同样大小和类型的新数组，因此<code>printSorted</code>函数的空间复杂度是 **O(n)**。当然对于在内存中开辟尽量小的空间而言，该函数是简单而轻量的。可以将上述函数修改为如下方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printSorted2</span>(<span class="keyword">_</span> <span class="params">array</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>array.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">var</span> currentCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> minValue <span class="operator">=</span> <span class="type">Int</span>.min</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> minValue &#123;</span><br><span class="line">            <span class="built_in">print</span>(value)</span><br><span class="line">            currentCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> currentCount <span class="operator">&lt;</span> array.count &#123;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">var</span> currentValue <span class="operator">=</span> array.max()<span class="operator">!</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">            <span class="keyword">if</span> value <span class="operator">&lt;</span> currentValue <span class="operator">&amp;&amp;</span> value <span class="operator">&gt;</span> minValue &#123;</span><br><span class="line">                currentValue <span class="operator">=</span> value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> array &#123;</span><br><span class="line">            <span class="keyword">if</span> value <span class="operator">==</span> currentValue &#123;</span><br><span class="line">                <span class="built_in">print</span>(value)</span><br><span class="line">                currentCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6</span></span><br><span class="line">        minValue <span class="operator">=</span> currentValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此实现尊重空间限制。总体目标是多次遍历迭代数组，为每个迭代打印下一个最小值。</p>
<ol>
<li><p>检查是否数组为空的情况。如果是，则不打印内容。</p>
</li>
<li><p><code>currentCount</code>跟踪打印语句的数量。<code>minValue</code> 存储最后一个打印值。</p>
</li>
<li><p>算法首先打印出与 <code>minValue</code>  匹配的所有值，并根据打印语句的数量更新当前计数。</p>
</li>
<li><p>使用 <code>while</code> 循环，算法查找大于 <code>minValue</code>  的最小值并将其存储在当前值中。</p>
</li>
<li><p>然后，该算法在更新<code>currentCount</code>的同时打印数组内所有<code>currentValue</code>的值。</p>
</li>
<li><p><code>minValue</code> 设置为<code>currentValue</code>，因此下一次迭代将尝试查找下一个最小值。</p>
</li>
</ol>
<p>上述算法仅分配内存以跟踪几个变量，因此空间复杂性为 **O(1)**。这与前面的函数不同，后者分配整个数组以创建源数组的排序表示形式。</p>
<blockquote>
<p>PS: 在实际开发中并不会为了追求类似的空间，而将代码写成上述样子，上述代码仅仅是为了说明代码的不同写法，会导致算法的空间复杂度有质的飞跃。</p>
</blockquote>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><strong>时间复杂度</strong>是对输入大小增加时，算法运行时间的衡量；</li>
<li><strong>空间复杂度</strong>是对算法运行时，对资源使用情况的衡量；</li>
<li><strong>大O符号表示法</strong>是用于表示时间和空间复杂性的一般形式；</li>
<li>时间和空间复杂性是可伸缩性的高级度量，它们不测量算法本身的实际速度；</li>
<li>对于小型数据集，时间复杂性通常无关紧要。准线性算法可能比线性算法慢。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-15-Data-Structures-&amp;-Algorithms-in-Swift-17/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/17/cover.jpg" alt="\#17\ 排序算法O(n^2)"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.095Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.096Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">17 分钟读完 (大约2492个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-15-Data-Structures-&amp;-Algorithms-in-Swift-17/">\#17\ 排序算法O(n^2)</a></h1><div class="content"><p>**O(n^2)**的时间复杂度并不是一个最佳的性能表现，但是在某些情况下，该类别的排序算法非常有用，此类算法的空间复杂度表现良好，仅仅需要O(1)的恒定的额外内存空间，对于小型数据集来说，此类排序算法比更为复杂的排序算法更为有利。</p>
<p>在本文中，将学习饿三种不同的、O(n^2)时间复杂度的排序算法：</p>
<ul>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
</ul>
<p>这些算法均是<strong>基于比较</strong>的方法，他们依赖比较的运算，比如小于或等于运算符等，对数据进行排序。比较操作的调用次数是衡量此类算法技术总体性能的一般方法。</p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是相对简单的一种排序方法，在排序的过程中，重复比较两个数据的大小，并进行数据交换。其中较大的数值会类似气泡上升一样上升到集合的尾部。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>例如上图所示的四张扑克，其顺序为*[9， 4， 10， 3]*，现在需要对其从小到大进行排序，需要如下几个步骤：</p>
<ul>
<li>从集合最前端开始，比较扑克牌9和扑克牌4，由于9比4大，因此需要进行位置交换，交换后，顺序变为*[4， 9， 10， 3]*；</li>
<li>完成了第一步后，比较的锚点移动到集合的下一个索引处，即此时的扑克牌9，比较9和10，符合小的在前，大的在后，顺序不变；</li>
<li>继续移动到下一个索引，扑克牌10，比较10和3，不符合从小到大的原则，进行位置交换，交换后，集合变为*[4， 9， 3， 10]*。</li>
</ul>
<p>集合遍历第一遍后，往往很难使得集合达到预期的目标，但是对于上述集合来说，最大的扑克牌10，已经冒泡移动到了集合的最末端。</p>
<p>接下来进行第二遍遍历，此时比较扑克牌4和9:</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example_step.png"></p>
<p>只有当集合不用进行再进行交换的时候，整个集合才算所排序完成。最差的情况下，堆集合的遍历需要<em>n - 1</em>次，其中 <em>n</em> 为集合元素的个数。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">bubbleSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> (<span class="number">1</span> <span class="operator">..&lt;</span> array.count).reversed() &#123;</span><br><span class="line">        <span class="keyword">var</span> swapped <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> end &#123;</span><br><span class="line">            <span class="keyword">if</span> array[current] <span class="operator">&gt;</span> array[current <span class="operator">+</span> <span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(current, current <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">                swapped <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>swapped &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对集合进行元素个数检查，如果元素的个数小于2，则不需要进行排序；</li>
<li>进行外层循环，首次循环之后，最大的元素将会移至集合的末尾，下次循环的时候，总是会比上一次少一个元素，因此，每次循环基本上都会少一次比较；</li>
<li>进行元素间的比较和交换。比较当前元素和下一个元素的大小，如果当前元素大于下一个元素，则进行位置的交换；</li>
<li>如果再无元素需要交换，则说明集合已经排序完成，排序退出。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;bubble sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    bubbleSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bubble sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of bubble sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Bubble sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>冒泡排序最好的时间复杂度为O(n)，最差时间复杂度为O(n^2)。</p>
<h2 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h2><p>选择排序遵循冒泡排序的基本思想，但是优化了元素位置交换的数量，选择排序仅在每次传递结束之后才进行元素的交换。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设有如下数量的扑克牌：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>每轮传递之后，选择排序将找到最小的未排序的元素，并对其进行位置交换：</p>
<ol>
<li>首先，发现扑克3是最小的，因此和扑克9交换位置；</li>
<li>下一个最小的扑克是4，其已经在正确地位置；</li>
<li>最后，最小的未扑克9，和扑克10交换。</li>
</ol>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/selection-sort-02.png"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">selectionSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> (array.count <span class="operator">-</span> <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> lowest <span class="operator">=</span> current</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> other <span class="keyword">in</span> (current <span class="operator">+</span> <span class="number">1</span>) <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">            <span class="keyword">if</span> array[lowest] <span class="operator">&gt;</span> array[other] &#123;</span><br><span class="line">                lowest <span class="operator">=</span> other</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lowest <span class="operator">!=</span> current &#123;</span><br><span class="line">            array.swapAt(lowest, current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历除了集合最后一个元素之外的其他元素，因为如果其他的元素都在正确地位置了，那么最后一个元素也是正确位置了；</li>
<li>再次遍历除当前索引之前的其他所有元素，寻找子集合中最小值的元素；</li>
<li>如果当前元素的索引并不是最小元素对应的索引，则进行元素位置的交换。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;selection sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    selectionSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Selection sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of selection sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Selection sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>类似冒泡排序，选择排序的最好、最坏和平均时间复杂度为O(n^2)，虽然有点让人沮丧，但是相比冒泡排序而言，选择排序的确表现的更好一些。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是更加有用的排序算法。像冒泡排序和选择排序，插入排序的平均时间复杂度依然为O(n^2)，但是插入排序的性能不同。越多的数据需要进行排序，选择排序会带来事半功倍的效果。在集合已经排序好的情况下，插入排序能达到最好时间复杂度O(n)。在Swift标准库中的排序算法使用的是混合排序的方式，当未排序的区间元素个数小于20个元素的时候，会采用插入排序的方式。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>同上，加入有如下的扑克牌：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/example.png"></p>
<p>插入排序将会从左至右遍历扑克一次，每张扑克均向左移动，直到其所在位置正确位置：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/17/insertion-sort-02.png"></p>
<ol>
<li>在遍历时，最左边的扑克可以忽略，因为在其前面再无其他扑克牌；</li>
<li>接下来，比较扑克9和扑克4，因为扑克4较小，因此和扑克9进行位置交换；</li>
<li>扑克10此时不需要移动，因为再其前面的扑克为9，说明扑克10在正确地位置上；</li>
<li>最后，扑克3前面的所有扑克均比扑克3大，因此一次交换扑克3到最首位置。</li>
</ol>
<p>插入排序最佳的时间复杂度为O(n)，其发生在进行排序的集合元素预先是排序好的，这样在进行插入排序的时候无序进行任何左移操作。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insertionSort</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">_</span> <span class="params">array</span>: <span class="keyword">inout</span> [<span class="type">Element</span>]) <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> array.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> <span class="number">1</span> <span class="operator">..&lt;</span> array.count &#123;</span><br><span class="line">        <span class="keyword">for</span> shifting <span class="keyword">in</span> (<span class="number">1</span> <span class="operator">...</span> current).reversed() &#123;</span><br><span class="line">            <span class="keyword">if</span> array[shifting] <span class="operator">&lt;</span> array[shifting <span class="operator">-</span> <span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(shifting, shifting <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>插入排序需要遍历集合中的每一个元素，因此第一个for循环从左至右遍历集合，这里忽略了首个位置的元素；</li>
<li>从当前索引向前遍历元素，比较当前索引元素和前一个索引元素，如果位置不正确则进行位置交换；</li>
<li>一直交换，直到所有索引位置的元素均在正确地位置为止。如果位置正确，则跳出当前循环，进行下一个索引元素的检查。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insertion sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    insertionSort(<span class="operator">&amp;</span>array)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Insertion sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insertion sort---</span></span><br><span class="line"><span class="comment">Original: [9, 4, 10, 3]</span></span><br><span class="line"><span class="comment">Insertion sorted: [3, 4, 9, 10]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="算法泛化"><a href="#算法泛化" class="headerlink" title="算法泛化"></a>算法泛化</h2><p>在本内容中，将对现有的排序算法进行优化，因为现有的算法接受的集合仅仅为<em>Array</em>，对于其他的集合类型并不适用，因此将对算法进行升级，有增强算法的泛化能力，具体有如下三方面：</p>
<ol>
<li>对于插入排序而言，需要对集合进行前向遍历和元素交换，因此接受的参数集合应该是双向集合类型<em>BidirectionalCollection</em>；</li>
<li>冒泡排序和选择排序仅仅对集合进行从前向后的遍历，因此集合参数仅仅需要符合集合类型<em>Collection</em>；</li>
<li>无论哪一种情况下，集合必须是<em>MutableCollection</em>可变集合类型，因为需要在遍历过程中进行元素的交换；</li>
</ol>
<p><strong>优化后的冒泡排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">bubbleSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> collection.indices.reversed() &#123;</span><br><span class="line">        <span class="keyword">var</span> swapped <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> collection.startIndex</span><br><span class="line">        <span class="keyword">while</span> current <span class="operator">&gt;</span> end &#123;</span><br><span class="line">            <span class="keyword">let</span> next <span class="operator">=</span> collection.index(after: current)</span><br><span class="line">            <span class="keyword">if</span> collection[current] <span class="operator">&gt;</span> collection[next] &#123;</span><br><span class="line">                collection.swapAt(current, next)</span><br><span class="line">                swapped <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>swapped &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化后的选择排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">selectionSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> collection.indices &#123;</span><br><span class="line">        <span class="keyword">var</span> lowest <span class="operator">=</span> current</span><br><span class="line">        <span class="keyword">var</span> other <span class="operator">=</span> collection.index(after: current)</span><br><span class="line">        <span class="keyword">while</span> other <span class="operator">&lt;</span> collection.endIndex &#123;</span><br><span class="line">            <span class="keyword">if</span> collection[lowest] <span class="operator">&gt;</span> collection[other] &#123;</span><br><span class="line">                lowest <span class="operator">=</span> other</span><br><span class="line">            &#125;</span><br><span class="line">            other <span class="operator">=</span> collection.index(after: other)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lowest <span class="operator">!=</span> current &#123;</span><br><span class="line">            collection.swapAt(lowest, current)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化后的插入排序</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insertionSort</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">collection</span>: <span class="keyword">inout</span> <span class="type">T</span>) <span class="keyword">where</span> <span class="type">T</span>: <span class="type">BidirectionalCollection</span> &amp; <span class="type">MutableCollection</span>, <span class="type">T</span>.<span class="type">Element</span>: <span class="type">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> collection.count <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> collection.indices &#123;</span><br><span class="line">        <span class="keyword">var</span> shifting <span class="operator">=</span> current</span><br><span class="line">        <span class="keyword">while</span> shifting <span class="operator">&gt;</span> collection.startIndex &#123;</span><br><span class="line">            <span class="keyword">let</span> previous <span class="operator">=</span> collection.index(before: shifting)</span><br><span class="line">            <span class="keyword">if</span> collection[shifting] <span class="operator">&lt;</span> collection[previous] &#123;</span><br><span class="line">                collection.swapAt(shifting, previous)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            shifting <span class="operator">=</span> previous</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>n²算法通常名声不太那么好，在性能消耗方面总是会带来更大消耗，但是在合理的数据量下，此类算法也可解决一些排序问题；</li>
<li>插入排序是最好的排序算法之一，在进行排序之前，需要了解数据是否已经是排序的。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-04-17-data-mind/"><img class="fill" src="/images/data-mind/cover.jpg" alt="码农是怎么炼成的"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.094Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.094Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">22 分钟读完 (大约3353个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-04-17-data-mind/">码农是怎么炼成的</a></h1><div class="content"><p>有人说，每个看起来与正常人无异的工程师，其实都是在学习程序开发的途中熬过、压抑过、而且创伤过的反社会人士(sociopaths)。</p>
<p>在学习程序开发的过程中，常常看到网络上的「甘苦谈」，也听过身边前途一片光明的工程师朋友们分享过学习历程，总觉得不同的人、同样的故事却不断的重复，像是狼叫声般，从远处传来一声又一声的回响。</p>
<p>最近读到Erik Trautman在Viking Code School部落格中的文章《Why Learning to Code is So Damn Hard》，文章里将学习写程序(Learn to Code)的过程分成了四个阶段，并解释了两个影响各阶段形成的关键因素「资料密度」以及「知识广度」，最后集合成这张图：</p>
<p><img src="/images/data-mind/main.png"></p>
<p>这篇文章很有趣也十分符合我所听闻的那些「工程师辛酸史」，因此决定将这四个阶段介绍给大家，希望程序初学者们在进入这条不归路之前，眼睛要放亮、计划要周详，清楚明白在前方等你们的是什么，做好完全心理准备吧!</p>
<p>接下来我将介绍从刚开始写程序到成为一名工程师，Erik Trautman所归类必经的四个阶段：</p>
<h2 id="想成为工程师，请做好准备迎接这段必经之路"><a href="#想成为工程师，请做好准备迎接这段必经之路" class="headerlink" title="想成为工程师，请做好准备迎接这段必经之路"></a>想成为工程师，请做好准备迎接这段必经之路</h2><p>先假设你学写程序的终极目标是要靠这行吃饭––进入相关领域工作或是自行创业，你是否做好万全准备可以从你的信心(Confidence)跟能力(Capability)散佈图中看出：</p>
<p><img src="/images/data-mind/con_com.png"></p>
<p>随着你具备的知识跟技能越来越多，你的自信心也会随之而增减，最后达到能力够信心足的「Job Ready」点。在Job Ready前则可以分成四个阶段：</p>
<h3 id="第一阶段：手牵手心连心蜜月期"><a href="#第一阶段：手牵手心连心蜜月期" class="headerlink" title="第一阶段：手牵手心连心蜜月期"></a>第一阶段：手牵手心连心蜜月期</h3><p>刚开始进入程序开发界的朋友们总是怀抱着远大的梦想跟抱负，这不能怪他们，毕竟一方面，大家小时候听多了「写程序很难」、「电脑科学很硬」这种传闻，从一开始就把不少人吓去念社会科学(没有冒犯社会科学专业人士的意思);另一方面，「全民写程序」这项运动实在太成功，坊间许多工具跟学习平台让程序开发变得<br>超好理解、上手容易，像是Codecademy、Treehouse、跟Code School等线上平台，或是麻省理工的Scratch语言、Google的Blockly等程序语言工具，成功地营造了人人都能写程序而且靠这行吃饭的<br>假象形象。</p>
<p><strong>突然间我们的问题不再是「困难度」，而是「比天高的期望」跟「比地大的梦想」。</strong></p>
<p>最重要的是，以上提到的这些工具跟平台实在太有用，带领毫无程序开发经验的初学者们一步步认识变数、条件语句、程序语法。当你一路过关斩将把程序语言基本逻辑跟语法学会的同时，你就会超有成就感、自信心大增，开始有「原来我也行嘛」、「写程序也不过就这样」的感觉，基本上觉得自己已经跟「工程师」相差不远了。</p>
<p><img src="/images/data-mind/con_com2.png"></p>
<p>这个阶段将充满喜悦与成就感，在各种线上工具、网络教学的帮助下，你享受着用指尖下指令、电脑就能准确执行的主导感，你赞叹着程序语言的神奇与强大之处，从Hello World到简单回圈，每完成一道练习题你的成就感又增加几分，很多人会在这个时候认为自己已经爱上了电脑科学(而且觉得电脑科学也爱他们)，正处于能力提升，自信心也大增的「蜜月期」，这时你可能会觉得世界真美好、人生大概就会从此飞黄腾达，但我得残酷的告诉你：</p>
<p>这段旅程才刚开始而已。</p>
<h3 id="第二阶段：困惑之崖"><a href="#第二阶段：困惑之崖" class="headerlink" title="第二阶段：困惑之崖"></a>第二阶段：困惑之崖</h3><p><strong>就跟大部份的情侣&#x2F;新婚夫妻一样，蜜月期会结束，你会慢慢发现「相爱没这么简单」。</strong></p>
<p>作业难度一增加(重点是程序码长度也会跟着增加)，程序错误警告就频频出现，开始不停的除错(Debug)。而且通常最大的挑战是––当错误出现时，你根本不知道错在哪里、该问什么问题。你的学习进度在这个阶段开始停滞不前，像路走到一半突然遇到悬崖而无路可走般，开始对之前的认知感到困惑，跟着信心大失。</p>
<p><img src="/images/data-mind/con_com3.png"></p>
<p>通常这个阶段会在你完成线上的基础教学后发生。以制作个人网站(Portfolio Website)为例好了，W3<br>School平台提供了一系列HTML、CSS、JavaScript等网页制作相关的程序教学，让初学者一单元一单元的学习语法跟功能，每单元还有例子<br>示范用法，看似好简单!全部跟着学一遍之后，你准备好动手打造自己的网站，打开文字编辑器，……，然后写没两行就卡关了。</p>
<p>也许靠Google搜寻可以让你撑到完成网站基本架构，但当你想实现自己的创意、加上个人化的设计时，网络上的回答跟示范总是和你心里所想的不太一样，所以程序码不能全抄，然而左拼右凑出的程序码看似可行但实际上差得可远了!偏偏还不知从何debug起，可能投资了大半的时间程序码还「有减无增」，毫无进展可言。</p>
<p>这是一个尤其挫折的必经阶段，想成为Programmer就必须经历这个关卡，勇敢跳下悬崖、逼自己展翅高飞(当然在这个阶段摔死的小雏鸟数量十分可观)。</p>
<p>但即使你消灭了无数的bug，终于完成了几个小专桉后，你也别高兴得太早，未来的路还是非常长远而且挑战性更高!对于想进入这行吃饭的人来说，「困惑之崖」通常是你决定是否全心全意进入这一行的转捩点，而当你投资所有的时间心力在写程序上时，你将进入最让人心灰意冷的第三阶段。</p>
<p>你可能会很好奇，到底为什么紧紧相连的第一阶段(蜜月期)跟第二阶段(困惑之崖)会差这么多?如果你也正在经历以上两个阶段，你要知道，造成阶段转换的原因跟你一点关係都没有，并不完全是因为你比别人笨或比别人不努力，而是因为「资源密度」改变的缘故。</p>
<p><strong>因素1：资源密度Resource Density</strong></p>
<p><img src="/images/data-mind/rd.png"></p>
<p>在第一阶段中有提到，当零经验零基础的你开始学习写程序时，身边有着无数的资源跟工具等着你来运用。到Google搜寻打「Learn to<br>Code」你会查到超多程序学习平台、教学文、教学影片、甚至经验谈，让你感到万分的亲切及温暖，其「手牵手心连心蜜月期」的称谓当之无愧。</p>
<p><img src="/images/data-mind/search.png"></p>
<p>然而到了第二阶段时，这些教学资源的数量将大为骤减，任何一个刚脱离初学者的程序学习者都能够证实我此言不假。初学者一开始遇到的障碍都是「一般常见问题」，教学文、教科书里就会注明了;后期由于作业难度以及个人需求，问题才渐渐复杂起来，要从Stack<br>Overflow或是一些程序人的部落格中去找寻解题线索。一直到在你遇到的问题已经棘手到网络上根本找不太到线索的时候，你便进入了下一个阶段。</p>
<h3 id="第三阶段：绝望沙洲"><a href="#第三阶段：绝望沙洲" class="headerlink" title="第三阶段：绝望沙洲"></a>第三阶段：绝望沙洲</h3><p>要了解进入第三阶段的关键，就要了解另一项影响着各阶段变化的重要因素：知识广度。</p>
<p><strong>因素2：知识广度Scope of Knowledge</strong></p>
<p><img src="/images/data-mind/sfk.png"></p>
<p>「知识广度」也就是度过每个阶段你所必备的知识领域范围。刚开始时你需要吸收的知识很集中，不管用哪种程序语言、不管功能是什么，首先都要学会变数型态、宣告语法、回圈及条件判断式等等，这时随便请一个工程师教你都是一样的，因为「重要须知」就是这几点而已。</p>
<p>然而学完基本功后，你所需的知识领域会一下子扩展很多，像是开始学习物件导向或是着重演算法的效率，你会需要扎实的电脑科学背景来应付，而且每一个应用都可以牵扯出更多的变化…相信我，这不是几堂MOOC课程就能救得了你的。</p>
<p>在这个时期，万能的Google也只会丢给你更多你不懂的东西，根本查不到相关的线索!最糟的是你根本不知道你什么不知道。(You don’t know what you don’t know.)。于是<strong>「学也学不完、越学越不懂」的无力感排山倒海而来，进入最最难熬的第三阶段––「绝望沙洲」</strong>。</p>
<p>这个阶段顾名思义像是在横越沙漠般，是一段非常长且寂寞的旅程，让你有不知何年何月才能走出来的绝望感。在一望无际的沙漠里，根本搞不清楚东西南北，资料查了半天毫无斩获，还不时被海市蜃楼(错误资讯或看似可行的解决方桉)给误导，搞得灰头土脸、头昏眼花，在这个阶段晒死、渴死、绝望死的有为青年更是不计其数。</p>
<p><img src="/images/data-mind/con_com4.png"></p>
<p>但只要在绝望沙洲里熬下去，接下来就会自在许多了!累积足够的经验，程序的错误就会大量减少、达到一定知识水准，就能准确判断问题的方向切入核心，工作效率因而有所增进，知识广度也会慢慢聚焦。等你拖着一身的疲惫终于走出这荒漠时，就进入了最后的阶段。</p>
<h3 id="第四阶段：创伤后的恢复期"><a href="#第四阶段：创伤后的恢复期" class="headerlink" title="第四阶段：创伤后的恢复期"></a>第四阶段：创伤后的恢复期</h3><p>踩着千万人的尸体成功横越了沙漠，你的自信心开始回升，Google功力也可以说是神人的等级。到了这个时候，Hacker News的新闻以及超硬的MOOC课程都不成问题，你也选定了某个程序语言跟框架来专研，而且有能力制作出可以正常运作的应用程序了。</p>
<p>但你心里深处总有着隐隐的不安，觉得程序能「用」但其实代码凌乱无章，工程师的头衔下其实是误打误撞进这行的半调子，虽然你似乎具备了一切就职条件，却总害怕面试官发现你根基薄弱的电脑知识…你正在经历「创伤后的恢复期」。</p>
<p>在飞越困惑之崖、横越绝望沙洲之后，你应该已经学会该学的、做了该做的，成为一个名符其实的工程师，却总觉得自已资质平庸根基不稳，虽然有成功打造出一个个专案而信心回升，但老是感叹自己与心目中「专业工程师」仍有一大段差距…，这些都是「冒牌者症候群」(Impostor Syndrome)在作祟!</p>
<p><img src="/images/data-mind/con_com5.png"></p>
<p>在这创伤后的恢复期中，你可能会经常自我怀疑，但只要顺着这波效率提升信心也回升的潮流继续努力，在能力与自信达到一个程度时…恭喜你：</p>
<p><strong>You Are Job Ready!<br>or<br>I learned the value of hard work by working hard.</strong></p>
<p>原文：<a target="_blank" rel="noopener" href="http://www.ijiandao.com/2b/baijia/64041.html">http://www.ijiandao.com/2b/baijia/64041.html</a></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-18-how-to-read-books/"><img class="fill" src="/images/how-to-read/cover.jpg" alt="如何高效读懂一本书"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.093Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.093Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">11 分钟读完 (大约1713个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-18-how-to-read-books/">如何高效读懂一本书</a></h1><div class="content"><p>“书中自有黄金屋，书中自有颜如玉。” 读书这件事从历史上就已经是人们获取知识，扩展视界，完成人生大转身的一个道路。但是在如今的飞速发展的互联网时代，人们已经不能够专注地去读书了，以及如今的图书出版也没有那么的繁杂和耗时了，每日都会有非常多的图书出版，面对着琳琅满目的图书，人们选择图书的范围大了，但是如何选择适合自己并且精品图书也变的苦难了。</p>
<p>《如何高效读懂一本书》是一本帮助你建立系统化思考的框架，该工作时工作，该玩耍时玩耍，用碎片化的时间，每年可以读100本书的高效读书指南。在没有读次本书之前，大多数人总是觉得读书没时间，经常坚持不下来，没有一个有效的方法，不够专注，以及不懂得如何分享最终导致感受很糟，枯燥乏味等。而读完这本书之后，对于那些无法继续读书或者不能有效读书的事情其实都是借口。这本书从各个方面总结并且给出了能够有效并且高效读书的实践方案，让每个人都能够轻松读书且从读书中真正的汲取营养。</p>
<h1 id="ξ·读书的若干误区"><a href="#ξ·读书的若干误区" class="headerlink" title="ξ·读书的若干误区"></a>ξ·读书的若干误区</h1><p>在没有读这本书之前，总是感觉没有定力读完某一本很喜欢的书，或者读完了一本书但却没有深刻的体会，读了就读了，没有自己的东西。当读完这本书的时候，才明白，对于读书其实有很多的误区。</p>
<ul>
<li>没有时间</li>
</ul>
<p>在如今快节奏的生活方式中，每个人都视时间为声明，快速的使用着生活中的每时每刻，每天眼睛时刻盯着手机、电脑等等，却没有能够静下心来好好的读读书。而针对这样的问题，人们总是想着不是我不想读书，是实在没有时间呀。但是请仔细想想，你是真的没有时间吗？在每日的生活中，多少事情是可以不用做的，哪些事情是在浪费时间呢？加入利用这样的时间去读读书，会怎么样呢？</p>
<ul>
<li>逐行阅读</li>
</ul>
<p>好读书的人都知道，不是每本书都需要一字一句，逐行去阅读的。但是大多数读书的人，拿到一本数之后，就一头扎了进去，也并不是这种方式不好，但是会不会有另一种读书的方式，能够更加的高效呢？其实每本书、每类书都有其自己的逻辑，我们去阅读的时候也不是每本书都用同样的方式，找到阅读某类书的好方式。</p>
<ul>
<li>阅读不广</li>
</ul>
<p>大多数人喜欢的图书基本上都是自己所擅长的，虽然读自己所擅长或者喜欢的那类图书没有错，但是久而久之，对于读者来说，可能会造成阅读面变窄，导致其他类型的信息无法获得等。在不同的成长过程中，应该有所侧重的去选择阶段所适合的图书去阅读，这样才能够在阅读的过程中，增长自己的知识和技能，提升自己的阶段性提升等。</p>
<ul>
<li>逢书精读</li>
</ul>
<p>图书种类非常之多，很多人逢书就精读，其实也并不尽然，并不是每本书都需要精读的，对于好书，例如一些经典的图书或者对自己技术能力提升有很大帮助的数，一定要精读，而且可能还需要多遍精读，才能够消化其中的知识信息等，但是对于一些兴趣点图书，我们大可不必话长时间去精读，可以略读、速读等，了解其中的主要内容即可。</p>
<ul>
<li>开卷有益</li>
</ul>
<p>很多人在读完一本书之后，总觉得收益很少。例如某本书甲用一个月的时间读完，收益是80%，乙用三个月读完，收益同样是80%，虽然甲乙都读完了书，而且收益是相同的，但是明显甲所花费的时间远远少于乙，这就是用最少的时间成本获取知识。在飞速发展的现代社会，不管是技术的革新，还是观念的提升，都可能一朝一夕，因此用最少的成本获取知识更符合当下社会的现实。</p>
<ul>
<li>碎片阅读</li>
</ul>
<p>碎片化阅读是目前可能比较火的一个词，但是个人来说，不太认同碎片化阅读能够带来的收益。碎片化阅读更加符合新闻、消息、短信息等类型的阅读，但是对于读书这件事来说，碎片化虽然能够读完书，但是可以肯定的是，每次碎片化阅读的时候，总是难以回想起之前所读内容的理解或者含义等，导致碎片化阅读的间隔时间内总是独立的，难以形成系统性的知识框架体系等。</p>
<h1 id="ξ·读书的若干方法"><a href="#ξ·读书的若干方法" class="headerlink" title="ξ·读书的若干方法"></a>ξ·读书的若干方法</h1><p>上述读书的若干误区中，相信大多数人都有，包括本人，在很长一段时间内，都在被如何快速阅读一本书来获取收益所打扰，总是碎片化的时间里，读了那么几行几句，并没有多大的收益。在《如何高效读懂一本书》读完之后，多少看到了一些提高读书技巧的方法，希望能够在以后的读书过程中有所应用实战，提高读书效率，以最小的成本获得知识信息等。</p>
<ul>
<li>通读法</li>
</ul>
<p><img src="/images/how-to-read/tdf.png"></p>
<ul>
<li>树读法</li>
</ul>
<p><img src="/images/how-to-read/sdf.png"></p>
<ul>
<li>图读法</li>
</ul>
<p><img src="/images/how-to-read/idf.png"></p>
<ul>
<li>框读法</li>
</ul>
<p><img src="/images/how-to-read/kdf.png"></p>
<ul>
<li>炼读法</li>
</ul>
<p><img src="/images/how-to-read/ldf.png"></p>
<ul>
<li>逆读法</li>
</ul>
<p><img src="/images/how-to-read/ndf.png"></p>
<ul>
<li>抄读法</li>
</ul>
<p><img src="/images/how-to-read/cdf.png"></p>
<ul>
<li>仿读法</li>
</ul>
<p><img src="/images/how-to-read/fdf.png"></p>
<ul>
<li>诵读法</li>
</ul>
<p><img src="/images/how-to-read/ssdf.png"></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-04-simple-eda/"><img class="fill" src="/images/simple-eda/cover.png" alt="探索性数据分析入门"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.093Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.094Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></span><span class="level-item">24 分钟读完 (大约3537个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-04-simple-eda/">探索性数据分析入门</a></h1><div class="content"><p>在数据科学领域里，最具挑战的问题之一便是如何确定数据对特定问题带来价值。在使用机器学习或者深度学习之前，确定数据或者特征是否利于特定问题，是数据科学后续工作的重中之重。</p>
<p>因此，在进行数据科学问题之前，通常会对数据进行分析，洞察数据中所涵盖的深层特性是否利于特定问题，以及是否适用于所选用的机器学习算法等，而这一步被称为<strong>探索性数据分析（Exploratory Data Analysis， EDA）</strong>。</p>
<p><strong>探索性数据分析（Exploratory Data Analysis，EDA）</strong> 是指对已有数据在尽量少的先验假设下通过作图、制表、方程拟合、计算特征量等手段探索数据的结构和规律的一种数据分析方法，该方法在上世纪70年代由美国统计学家J.K.Tukey提出。传统的统计分析方法常常先假设数据符合一种统计模型，然后依据数据样本来估计模型的一些参数及统计量，以此了解数据的特征，但实际中往往有很多数据并不符合假设的统计模型分布，这导致数据分析结果不理想。EDA则是一种更加贴合实际情况的分析方法，它强调让数据自身“说话”，通过EDA我们可以最真实、直接的观察到数据的结构及特征。</p>
<blockquote>
<p><strong>探索性数据分析（EDA）是一种数据分析方法，它采用多种技术来最大化对数据集的洞察力。揭示底层结构；提取重要变量；检测异常值和异常；建立简约模型；并确定最佳因子设置。</strong></p>
</blockquote>
<p><img src="/images/simple-eda/banner.png"></p>
<h2 id="从实战中学习EDA"><a href="#从实战中学习EDA" class="headerlink" title="从实战中学习EDA"></a>从实战中学习EDA</h2><p><strong>实践是检验整理的唯一途径。</strong> 为了能够更好更快的理解EDA，这里将直接从**<a target="_blank" rel="noopener" href="https://archive.ics.uci.edu/ml/datasets/Iris">鸢尾花数据集(UCI Machine Learning Repository)</a>**的探索性分析中学习EDA的方法。</p>
<p><strong>目标：</strong> 从给定4个维度特征的鸢尾花数据集中学习，已确定新的鸢尾花属于3个鸢尾花类别中的哪一个类别。</p>
<blockquote>
<p><strong>在进行EDA的过程中，需要始终牢记最初确立的目标，否则EDA可能偏离目标！</strong></p>
</blockquote>
<h3 id="导入所需类库"><a href="#导入所需类库" class="headerlink" title="导入所需类库"></a>导入所需类库</h3><p>显而易见，进行Python语言相关的开发时，第一步基本上都是导入所需的类库（前提是类库已经被安装在当前坏境）。在进行EDA时，所需的类库可能并不是很多，满足需求即可，在这里，将导入像<em>Pandas、Matplotlib、numpy</em>等类库，对应类库的作用，可自行搜索学习。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<h3 id="下载数据并加载"><a href="#下载数据并加载" class="headerlink" title="下载数据并加载"></a>下载数据并加载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;downlaod iris.csv from https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#Load Iris.csv into a pandas dataFrame.</span></span><br><span class="line">iris = pd.read_csv(<span class="string">&quot;./iris.csv&quot;</span>)</span><br><span class="line">iris.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>*.head()<em>函数是Pandas中的标准函数，用于观察数据集的数据详情，默认情况下返回数据集的前5个样本点。同时，</em>.tail()*函数返回数据集的后5个样本点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Data-points and features</span></span><br><span class="line">iris.shape</span><br></pre></td></tr></table></figure>




<pre><code>(150, 5)
</code></pre>
<p><em>.shape</em>参数可以查看数据集的形状（行数、列数）。</p>
<ul>
<li>此处使用的鸢尾花数据集是一个150行和5列的数据集。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.info()</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 150 entries, 0 to 149
Data columns (total 5 columns):
sepal_length    150 non-null float64
sepal_width     150 non-null float64
petal_length    150 non-null float64
petal_width     150 non-null float64
species         150 non-null object
dtypes: float64(4), object(1)
memory usage: 6.0+ KB
</code></pre>
<p>*.info()*函数用于展示数据集列数据的数据类型情况。</p>
<ul>
<li>此处，数据只有float类型和object类型两种值类型数据；</li>
<li>无变量或列包含null值或者缺失值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.columns</span><br></pre></td></tr></table></figure>




<pre><code>Index([&#39;sepal_length&#39;, &#39;sepal_width&#39;, &#39;petal_length&#39;, &#39;petal_width&#39;,
       &#39;species&#39;],
      dtype=&#39;object&#39;)
</code></pre>
<ul>
<li><em>.columns</em> 用来查看数据集的列或特征的名称。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris[<span class="string">&#x27;species&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>versicolor    50
setosa        50
virginica     50
Name: species, dtype: int64
</code></pre>
<ul>
<li>*.value_counts()*是对数据集上特定列进行降序后，获取该列的每个值的计数值；</li>
<li>此处，每一个种类（Versicolor, Setosa, Virginica）各有50个观察对象，因此该数据集应该是<strong>均匀分布</strong>的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris.describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>150.000000</td>
      <td>150.000000</td>
      <td>150.000000</td>
      <td>150.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>5.843333</td>
      <td>3.054000</td>
      <td>3.758667</td>
      <td>1.198667</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.828066</td>
      <td>0.433594</td>
      <td>1.764420</td>
      <td>0.763161</td>
    </tr>
    <tr>
      <th>min</th>
      <td>4.300000</td>
      <td>2.000000</td>
      <td>1.000000</td>
      <td>0.100000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>5.100000</td>
      <td>2.800000</td>
      <td>1.600000</td>
      <td>0.300000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>5.800000</td>
      <td>3.000000</td>
      <td>4.350000</td>
      <td>1.300000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>6.400000</td>
      <td>3.300000</td>
      <td>5.100000</td>
      <td>1.800000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>7.900000</td>
      <td>4.400000</td>
      <td>6.900000</td>
      <td>2.500000</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>*.describe()*函数用于获取数据集的各种汇总统计信息。该函数返回计数值、均值、标准差、最小值和最大值、以及数据的分位数。</li>
</ul>
<p>至此，对数据集来说已经有了一个基础的了解，对于数据的探索性分析来说，这才刚刚开始，往往通过对数据的图形化描述能够更加详细的了解数据特征之间的关系等，包括单变量和多变量分析等。</p>
<h2 id="二维散点图"><a href="#二维散点图" class="headerlink" title="二维散点图"></a>二维散点图</h2><p>散点图是一种将数据显示为点集合的图。点的位置取决于其二维值，每个值都是水平或者垂直维度上的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2-D Scatter plot with color-coding for each flower type/class.</span></span><br><span class="line"><span class="comment"># Here &#x27;sns&#x27; corresponds to seaborn</span></span><br><span class="line">sns.set_style(<span class="string">&#x27;whitegrid&#x27;</span>)</span><br><span class="line">sns.FacetGrid(iris, hue=<span class="string">&#x27;species&#x27;</span>, height=<span class="number">8</span>) \</span><br><span class="line">    .<span class="built_in">map</span>(plt.scatter, <span class="string">&#x27;sepal_length&#x27;</span>, <span class="string">&#x27;sepal_width&#x27;</span>) \</span><br><span class="line">    .add_legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_21_0.png" alt="png"></p>
<p>Seaborn中的<em>FacetGrid</em>类有助于使用多个面板在数据集的子集中可视化一个变量的分布以及多个变量之间的关系。参数<em>hue</em>根据与每个参数相关的颜色将数据点分开。</p>
<p>三个类别的数据点根据<em>sepal_length</em>分散。</p>
<ul>
<li>使用<em>sepal_length</em>和<em>sepal_width</em>特征，可以区分Setosa同其他类别（线性可分）；</li>
<li>区分Versicolor和Virginica相对困难一点，因为它们之间有大量的重叠部分。</li>
</ul>
<h2 id="对图"><a href="#对图" class="headerlink" title="对图"></a>对图</h2><p>对图有助于查看数据中单个变量的分布以及多个变量之间的关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pairwise scatter plot: Pair-Plot</span></span><br><span class="line"><span class="comment"># Dis-advantages: Cannot visualize higher dimensional patterns in 3-D and 4-D.</span></span><br><span class="line"><span class="comment"># Only possible to view 2D patterns.</span></span><br><span class="line">plt.close()</span><br><span class="line">sns.pairplot(iris, hue=<span class="string">&#x27;species&#x27;</span>, size=<span class="number">3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_24_0.png" alt="png"></p>
<ul>
<li><em>petal_length</em>和<em>petal_width</em>是区分各种类型鸢尾花的重要特征；</li>
<li>Setosa类型的鸢尾花很容易被识别（线性可分），Virginica和Versicolor的特征有一些重叠（接近于线性可分）；</li>
<li>可以找到“分割线”或者“if-else”条件来建立一个简单的模型，对鸢尾花的类型进行分类。</li>
</ul>
<h2 id="直方图和PDF（概率密度函数）"><a href="#直方图和PDF（概率密度函数）" class="headerlink" title="直方图和PDF（概率密度函数）"></a>直方图和PDF（概率密度函数）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.FacetGrid(iris, hue=<span class="string">&#x27;species&#x27;</span>, height=<span class="number">8</span>) \</span><br><span class="line">    .<span class="built_in">map</span>(sns.distplot, <span class="string">&#x27;petal_length&#x27;</span>) \</span><br><span class="line">    .add_legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_27_0.png" alt="png"></p>
<p><em>distplot()</em> 函数绘制了各种鸢尾花类型的<em>petal_length</em>的分布。图中蓝色代表Setosa类型鸢尾花的<em>petal_length</em>的直方图，黄色、绿色类似。y轴代表x轴上一个小窗口或者一个间隔中存在的数据点的数量，意味着在x轴上给定一个点或者区域，该点或者区域上直方图的高度代表x轴上该点或者区域有多少数据点。在上图中小窗口定义为<em>petal_length</em>。</p>
<p>直方图的高度越高，即在给定的区域内密度越大，则找到的种类和花瓣的长度值之间的对应越多。因此上图也称为<strong>概率密度图</strong>，通过对直方图进行平滑处理（KDE）制成的图像曲线为PDF，即概率密度函数曲线。</p>
<p><strong>结论：</strong></p>
<ul>
<li>如果 <code>petal_length ≤ 2</code>，种类为 Setosa；</li>
<li>如果 <code>petal_length ＞ 2</code>，并且 <code>petal_length ≤ 4.7</code>，种类为 Versicolor；</li>
<li>如果 <code>petal_length ≥ 4.7</code>，种类为 Virginica；</li>
<li>另一个结论是，通过 <code>petal_length</code> 单变量的分析，对于区分不同的鸢尾花种类很有帮助，仅仅使用这一个特征，可以构建一个使用if-else条件判定的简单模型。</li>
</ul>
<blockquote>
<p>在区分Versicolor的时候，使用了4.7作为分界点，而不是5的原因是， <code>petal_length ≤ 4.7</code>条件下，分类结果更多的可能性是Versicolor，而不是Virginica，这也和数据可视化的结果更为接近。</p>
</blockquote>
<p>当然，也可以使用<em>petal_width</em>、<em>sepal_length</em>、<em>sepal_width</em>进行单变量的分析，但是最终的结果可能并没有使用<em>petal_length</em>的结果好。</p>
<p>PDF的局限性在于，无法查看其直观的图标或者统计性数据。例如，无法根据<em>petal_length</em>单变量分析，看到<code>petal_length ＜ 5</code>的情况下，属于Versicolor类型数据的百分比等。</p>
<p>鉴于此，还需要使用CDF（累积分布函数）。</p>
<h2 id="CDF（累积分布函数）"><a href="#CDF（累积分布函数）" class="headerlink" title="CDF（累积分布函数）"></a>CDF（累积分布函数）</h2><p>累积分布函数计算给定x值的累积概率。可以使用CDF来确定从总体中抽取的随机观察值小于或者等于某个值的可能性。</p>
<p>CDF的优势在于可以通过可视化的方式查看，例如查看Setosa类型的鸢尾花，<em>petal_length</em> 小于1.6的百分比。PDF和直方图无法提供相同的确切的百分比，PDF只是分布图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Need for Cumulative Distribution Function (CDF)</span></span><br><span class="line"><span class="comment"># We can visually see what percentage of setosa flowers have a</span></span><br><span class="line"><span class="comment"># petal_length of less than 1.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot CDF petal_length</span></span><br><span class="line">iris_setosa = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;setosa&#x27;</span>]</span><br><span class="line">iris_virginica = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;virginica&#x27;</span>]</span><br><span class="line">iris_versicolor = iris.loc[iris[<span class="string">&#x27;species&#x27;</span>] == <span class="string">&#x27;versicolor&#x27;</span>]</span><br><span class="line"></span><br><span class="line">counts, bin_edges = np.histogram(iris_setosa[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(pdf)</span><br><span class="line"><span class="built_in">print</span>(bin_edges)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute CDF</span></span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;PDF&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;CDF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>[0.02 0.02 0.04 0.14 0.24 0.28 0.14 0.08 0.   0.04]
[1.   1.09 1.18 1.27 1.36 1.45 1.54 1.63 1.72 1.81 1.9 ]
</code></pre>
<p><img src="/images/simple-eda/output_30_1.png" alt="png"></p>
<p>示例代码中构建了三个数据框对应三种不同的鸢尾花种类。图中x轴代表<em>petal_length</em>，y轴则是对应的累积分布概率。</p>
<p><code>cumsum()</code>函数是NumPy类库中通过PDF计算CDF的方法。</p>
<ul>
<li>假设<code>petal_length</code>的值我们关心的是1.6。对于1.6，数据中有接近82%的Setosa类型鸢尾花，<code>petal_length ≤ 1.6</code>。即意味着在总共50朵Setosa鸢尾花中，有41朵的<code>petal_length ≤ 1.6</code>；</li>
<li>根据CDF也可以得到所有Setosa鸢尾花的<code>petal_length ≤ 1.9</code>。</li>
</ul>
<h3 id="一张图中查看三种类型鸢尾花的单变量CDF"><a href="#一张图中查看三种类型鸢尾花的单变量CDF" class="headerlink" title="一张图中查看三种类型鸢尾花的单变量CDF"></a>一张图中查看三种类型鸢尾花的单变量CDF</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plots of CDF of petal_length for various types of flowers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Misclassification error if you use petal_length only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setosa</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_setosa[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setosa_pdf:&#x27;</span>, pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;setosa_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;setosa_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;setosa_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># virginica</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_virginica[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;virginica_pdf:&#x27;</span>,pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;virginica_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;virginica_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;virginica_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># versicolor</span></span><br><span class="line">counts, bin_edges = np.histogram(iris_versicolor[<span class="string">&#x27;petal_length&#x27;</span>], bins=<span class="number">10</span>, density=<span class="literal">True</span>)</span><br><span class="line">pdf = counts/(<span class="built_in">sum</span>(counts))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;versicolor_pdf:&#x27;</span>,pdf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;versicolor_bin_edges:&#x27;</span>,bin_edges)</span><br><span class="line">cdf = np.cumsum(pdf)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], pdf, label=<span class="string">&#x27;versicolor_pdf&#x27;</span>)</span><br><span class="line">plt.plot(bin_edges[<span class="number">1</span>:], cdf, label=<span class="string">&#x27;versicolor_cdf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>setosa_pdf: [0.02 0.02 0.04 0.14 0.24 0.28 0.14 0.08 0.   0.04]
setosa_bin_edges: [1.   1.09 1.18 1.27 1.36 1.45 1.54 1.63 1.72 1.81 1.9 ]
virginica_pdf: [0.02 0.1  0.24 0.08 0.18 0.16 0.1  0.04 0.02 0.06]
virginica_bin_edges: [4.5  4.74 4.98 5.22 5.46 5.7  5.94 6.18 6.42 6.66 6.9 ]
versicolor_pdf: [0.02 0.04 0.06 0.04 0.16 0.14 0.12 0.2  0.14 0.08]
versicolor_bin_edges: [3.   3.21 3.42 3.63 3.84 4.05 4.26 4.47 4.68 4.89 5.1 ]
</code></pre>
<p><img src="/images/simple-eda/output_32_1.png" alt="png"></p>
<p><strong>通过可视化，可以得到如下的结论：</strong></p>
<ul>
<li>如果 <code>petal_length ≤ 2</code>，则鸢尾花的类型为Setosa，并且正确率接近于100%；</li>
<li>如果 <code>petal_length ＞ 2</code>并且 <code>petal_length ≤ 5</code>：<ul>
<li><strong>鸢尾花种类为Virginica。</strong> 此结论的正确性可能只有10%，因为在<code>petal_length = 5</code>情况下，CDF的值为10，同理，再次区间判定结果有90%的错误可能；</li>
<li><strong>鸢尾花种类为Versicolor。</strong> 此结论的正确率为95%，因为在<code>petal_length = 5</code>时，Virginica的CDF值为95。</li>
</ul>
</li>
<li>当 <code>petal_length</code>位于5到7之间，并且如果在此处将一个鸢尾花的种类定为Virginica，则正确预测该种类的可能性为90%，10%的可能性为Versicolor。</li>
</ul>
<h2 id="箱须图（Box-and-Whisker-Plots）"><a href="#箱须图（Box-and-Whisker-Plots）" class="headerlink" title="箱须图（Box-and-Whisker Plots）"></a>箱须图（Box-and-Whisker Plots）</h2><p>箱形图（或箱须图）以有助于变量之间比较的方式显示定量数据的分布 Box显示数据集的四分位数，而Whisker显示其余分布。</p>
<p>箱须图是显示数据分布的一种标准化方法，该方法基于以下五个数据的摘要绘制：</p>
<ul>
<li>最小值</li>
<li>最大值</li>
<li>中位数</li>
<li>第一个四分位数</li>
<li>第三个四分位数</li>
</ul>
<p>在一个简单的箱形图中，中心矩形跨越第一个四分位数到第三个四分位数（四分位数间距或IQR）。</p>
<p><strong>Box Plot</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Box-plot with whiskers: another method of visualizing the 1-D scatter plot more untuitivey.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> In the plot below, a technique call inter-quartile range is used in plotting the whiskers.</span></span><br><span class="line"><span class="comment"># Whiskers in the plot below donot correposnd to the min and max values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Box-plot can be visualized as a PDF on the side-ways.</span></span><br><span class="line"></span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;petal_length&#x27;</span>, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_35_0.png" alt="png"></p>
<p><strong>Whisker Plot</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A violin Plot combines the benefits of the previous two plots and simplifies them</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Denser regions of the data are fatter, and sparser ones thinner in a violin plot</span></span><br><span class="line"></span><br><span class="line">sns.violinplot(x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;petal_length&#x27;</span>, data=iris, size=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/images/simple-eda/output_37_0.png" alt="png"></p>
<h2 id="仓促的结语"><a href="#仓促的结语" class="headerlink" title="仓促的结语"></a>仓促的结语</h2><p>在本文中，粗略的对数据科学问题的前期工作—探索性数据分析，进行了简单的介绍，从中可以了解到如何进行数据的EDA，并从EDA中了解到数据的深层特性，对后续的特征抽取和建模具有非常大的意义。</p>
<blockquote>
<p>在文中，部分内容并没有深入进行介绍，与其说本文是介绍EDA，倒不如是针对EDA阶段如何一步一步的深入到数据内部的简单了解，希望对您有帮助。</p>
</blockquote>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">59</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>