<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/"><img class="fill" src="/images/lightweight-api/cover.jpg" alt="Swift语言中的轻量级API设计"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">22 分钟读完 (大约3270个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/">Swift语言中的轻量级API设计</a></h1><div class="content"><p>Swift语言自诞生以来，总是或多或少受到人们的非议，新生的编程语言难免有些不够尽善尽美，但是哪种编程语言是尽善尽美的呢？OC语言算得上是一种古老的面向对象语言了，发展至今，其版本仍处于2.0，但是Apple为了让其看起来强大一点，增加了很多特性，例如Block、instancetype等等，但是其核心的语法变化并不大。</p>
<p>截止目前，Swift的版本已经迭代到5.*，整个ABI也已经稳定，每一次迭代更新，总是会带来一些漂亮的设计模式实践，例如在如何设计API方面，给开发者带来了舒适而强大的枚举、扩展和协议等，不仅让开发者对于函数的定义有了更清晰的认识，而且对于构建API而言，第一印象往往是轻量的，同时，仍会根据需要逐步显现出更多的功能，以及底层的复杂性。</p>
<p>在本篇文章里，将尝试创建一些轻量级的API，以及如何使用API组合的力量使得功能或者系统更加强大等。</p>
<h2 id="功能和易用性之间的较量"><a href="#功能和易用性之间的较量" class="headerlink" title="功能和易用性之间的较量"></a>功能和易用性之间的较量</h2><p>通常，当我们设计API时，会在数据结构和函数功能的相互交互上，寻找一个相对平衡的方式，最终构建出在功能上满足需求，数据结构尽量简单的API。但是，让API过于简单，可能它们又不够灵活，无法使功能有不断发展的潜力，然而，太过复杂的设计又难免导致开发工作复杂而无章法，容易造成开发者挫败，逻辑混乱而且API也难以使用，最终可能会导致延期甚至失败。</p>
<p>例如，一款应用程序的主要功能是对用户选择的图像应用不同的滤镜效果。每一种滤镜的核心其实都是一组图像变换的组合，不同的变换组合形成不同的滤镜效果。假设使用<code>ImageFilter</code> 结构体作为图像滤镜的定义，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">Icon</span></span><br><span class="line">    <span class="keyword">var</span> transforms: [<span class="type">ImageTransform</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageTransform</code>是图像变换的统一入口，因为可能会由多种不同的变换，因此可以将其定义为一个<code>protocol</code>，然后由实现单独变换操作的各种变换类型所遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortraitImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zoomMultiplier: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayScaleImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brightnessLevel: <span class="type">BrightnessLevel</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述设计方式的优势在于，由于每种转换都是按照自己的类型实现的，因此在使用时可以自由地让每种变换类型定义自己所需的属性和参数。例如<code>GrayScaleImageTransform</code> 接受 <code>BrightnessLevel</code>参数，以将图像转换为灰度图像。</p>
<p>然后，可以根据需要组合任意数量的图像变换类型，以形成不同类型的滤镜效果。例如，通过一系列的转换使得图像具有某种“戏剧性”外观的滤镜：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>, icon: .drama, transforms: [</span><br><span class="line">        <span class="type">PortraitImageTransform</span>(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        <span class="type">ContrastBoostImageTransform</span>(),</span><br><span class="line">        <span class="type">GrayScaleImageTransform</span>(brightnessLevel: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So far so Good.  但是回头重新审视上述API的实现，可以肯定的说，上述实现仅仅是为了功能的实现，在API的易用性方面并没有优势，那么该如何进行优化，来保证功能的同时，提高API的灵活性和易用性呢？在上述实现中，每个图像的变换都是作为单独的类型实现的，因此没有一个可以对所有变换类型一目了然的地方，使用者难以清楚该代码库都包含哪些图像变换的类型。</p>
<p>为了解决外部使用者无法得知软件库所支持的变换类型，假设使用<strong>枚举</strong>的方式代替上述方式，来观察哪种方式更能够体现API的简洁明了以及使用上的清晰易用？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> protrait(<span class="keyword">_</span> zoomMultiplier: <span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> grayScale(<span class="keyword">_</span> brightnessLevel: <span class="type">BrightnessLevel</span>)</span><br><span class="line">    <span class="keyword">case</span> contrastBoost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举的好处既能够提高代码的整洁程度和可读性，也使得API更加的灵活易用，因为在枚举的使用上，开发者可以直接使用点语法构造任意数量的转换，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .protrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>截止目前，枚举都是很漂亮的一个工具，在很多情况下Swift的枚举类型都能够提供良好的解决方式，但是枚举也有其明显的弊端。</p>
<p>就上述例子来说，由于每个转换都需要执行截然不同的图像操作，因此在这种情况下使用枚举将迫使我们编写一个庞大的<em>switch</em>语句来处理这些操作中的每一项, 这可能会造成代码的冗长繁琐等。</p>
<h2 id="枚举虽轻，结构体更优"><a href="#枚举虽轻，结构体更优" class="headerlink" title="枚举虽轻，结构体更优"></a>枚举虽轻，结构体更优</h2><p>幸运的事，针对上述问题，我们还有第三种选择 — 一种目前算是两全其美的方案。相较于协议或者枚举，结构体是一个既能够定义操作类型，还能够封装给定各种操作的闭包的数据结构。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> closure: (<span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>apply(to:)</code> 方法在这里并不应该被外部调用，这里写出来是为了代码的美观性以及代码的向前兼容。在实际项目开发中，这里可以使用宏定义区分。</p>
</blockquote>
<p>完成上述操作后，我们现在可以使用<strong>静态工厂方法</strong>和属性来创建我们的转换 — 每个转换仍可以单独定义并具有自己的一组参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> contrastBoost: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">portrait</span>(<span class="keyword">_</span> <span class="params">multiplier</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">grayScale</span>(<span class="keyword">_</span> <span class="params">brightness</span>: <span class="type">BrightnessLevel</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在 Swift 5.1 中，可以将<strong>Self</strong>用作静态工厂方法的返回类型。</p>
</blockquote>
<p>上面方法的优点在于，我们回到了将ImageTransform定义为协议时所具有的灵活性和功能性，同时仍保持了与定义为枚举时的调用方式 — 点语法一致，保证了易用性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>点语法本身与枚举无关，但是其可以与任何静态API一起使用，这点对于开发者而言非常友好。使用点语法可以将上述的几个滤镜的创建和建模构造成静态属性，使得我们能够进一步的封装特性等。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> dramatic: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageFilter</span>(</span><br><span class="line">            name:<span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">            icon: .drama,</span><br><span class="line">            transforms: [</span><br><span class="line">                .portrait(<span class="number">2.1</span>),</span><br><span class="line">                .contrastBoost,</span><br><span class="line">                .grayScale(.dark)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述改造，一系列复杂的任务 — 包括图像滤镜和图像转换 – 封装到一个API中，在使用上，可以像传值给函数一样轻松。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> image.withFilter(.dramatic)</span><br></pre></td></tr></table></figure>

<p>上述一系列的改造可以成为为类型构造<strong>语法糖</strong>。不仅改善了API读取的方式，还改善了API的组织方式，由于所有的转换和滤镜现在只需要进行传单一的值即可，因此在可扩展性方面来说，能够组织多种方式，不仅使得API轻巧灵活，对于使用者来说也简洁明了。</p>
<h2 id="可变参数与API设计"><a href="#可变参数与API设计" class="headerlink" title="可变参数与API设计"></a>可变参数与API设计</h2><p>接下来我们一起看看Swift语言的另一个特性 — 可变参数，以及可变参数如何影响API设计中的代码构建的。</p>
<p>假设正在开发一个使用基于形状的绘图来创建其用户界面的应用程序，并且我们已经使用了与上述类似的基于结构的方法来对每种形状进行建模，并最终将结果绘制到了<code>DrawingContext</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> drawing: (<span class="keyword">inout</span> <span class="type">DrawingContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面使用<strong>inout</strong>关键字来启用值类型（DrawingContext）的传递。</p>
</blockquote>
<p>类似我们在上面例子中使用静态工厂方法轻松创建<code>ImageTransform</code>一样，在这里也能够将每个形状的绘图代码封装在一个完全独立的方法中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">at</span> <span class="params">point</span>: <span class="type">Point</span>, <span class="params">sideLength</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> origin <span class="operator">=</span> point.movedBy(</span><br><span class="line">                x: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span>,</span><br><span class="line">                y: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            context.move(to: origin)</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength, y: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(y: sideLength))</span><br><span class="line">            context.drawLine(to: origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于将每个形状简单地建模为一个属性值，因此绘制它们的数组变得非常容易-我们要做的就是创建一个<strong>DrawingContext</strong>实例，然后将其传递到每个形状的闭包中以构建最终图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context <span class="operator">=</span> <span class="type">DrawingContext</span>()</span><br><span class="line">    </span><br><span class="line">    shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">        context.move(to: .zero)</span><br><span class="line">        shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> context.makeImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的函数看起来也很优雅，因为我们再次可以使用点语法来大大减少执行工作所需的语法量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw([</span><br><span class="line">    .circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">    .square(at: point, sideLength: <span class="number">5</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>但是，让我们看看是否可以使用可变参数来使事情更进一步。虽然不是Swift独有的功能，但结合Swift真正灵活的参数命名功能后，使用可变参数可以产生一些非常有趣的结果。</p>
<p>当参数被标记为可变参数时（通过在其类型中添加<code>...</code>后缀），我们基本上可以将任意数量的值传递给该参数 — 编译器会自动为我们将这些值组织到一个数组中，例如这个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: <span class="type">Shape</span>...) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="comment">// Within our function, &#x27;shapes&#x27; is still an array:</span></span><br><span class="line">    shapes.forEach &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述更改后，我们现在可以从对draw函数的调用中删除所有数组文字，而使它们看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">                 .square(at: point, sideLength: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>这看起来似乎不是很大的变化，但是尤其是在设计旨在用于创建更多更高级别值（例如我们的draw函数）的更低级别的API时，使用可变参数可以使这类API感觉更轻巧和方便。</p>
<p>但是，使用可变参数的一个缺点是，预先计算的值数组不能再作为单个参数传递。值得庆幸的是，在这种情况下，可以通过创建一个特殊的组形状（就像draw函数本身一样），在一组基础形状上进行迭代并绘制它们来轻松解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">group</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">                context.move(to: .zero)</span><br><span class="line">                shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述操作后，我们现在可以再次轻松地将一组预先计算的Shape值传递给我们的draw函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shapes: [<span class="type">Shape</span>] <span class="operator">=</span> loadShapes()</span><br><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.group(shapes))</span><br></pre></td></tr></table></figure>

<p>不过，真正酷的是，上述组API不仅使我们能够构造形状数组，而且还使我们能够更轻松地将多个形状组合到更高级的组件中。例如，这是我们如何使用一组组合形状来表示整个图形（例如徽标）的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">logo</span>(<span class="params">withSize</span> <span class="params">size</span>: <span class="type">Size</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        .group([</span><br><span class="line">            .rectangle(at: size.centerPoint, size: size),</span><br><span class="line">            .text(<span class="string">&quot;The Drawing Company&quot;</span>, fittingInto: size),</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述徽标与其他徽标一样都是Shape，因此只需调用一次draw方法就可以轻松绘制它，并使用与之前相同的优雅点语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo <span class="operator">=</span> draw(.logo(withSize: size))</span><br></pre></td></tr></table></figure>

<p>有趣的是，尽管我们最初的目标可能是使我们的API更轻量级，但这样做也使它的可组合性和灵活性也得到了提高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们向“ API设计者的工具箱”添加的工具越多，我们越有可能能够设计出在功能，灵活性和易用性之间达到适当平衡的API。 使API尽可能轻巧可能不是我们的最终目标，但是通过尽可能减少API的数量，我们也经常发现如何使它们变得更强大-通过使我们创建类型的方式更灵活，以及使他们组成。所有这些都可以帮助我们在简单性与功能之间实现完美的平衡。</p>
<blockquote>
<p>原文： Lightweight API design in Swift<br>链接：<a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</a></p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/16/cover.png" alt="\#16\ 优先级队列"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1146个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/">\#16\ 优先级队列</a></h1><div class="content"><p>队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是：</p>
<ol>
<li><strong>最大优先级队列：</strong>队列中最前面的元素具有最高优先级；</li>
<li><strong>最小优先级队列：</strong>队列中最前面的元素具有最低优先级。</li>
</ol>
<p>当需要在给定的元素列表中取标定最大元素和最小元素时，优先级队列将是非常合适的一种数据结构。</p>
<h2 id="优先级队列的典型应用"><a href="#优先级队列的典型应用" class="headerlink" title="优先级队列的典型应用"></a>优先级队列的典型应用</h2><ul>
<li><strong>迪克斯特拉的算法（Dijkstra’s algorithm）</strong>，使用优先级队列计算最小代价。</li>
<li><strong>A*路径寻找算法</strong>，使用优先级队列跟踪对位置路径进行探索的最短路径。</li>
<li><strong>堆排序</strong>，可以使用优先级队列实现。</li>
<li><strong>哈夫曼编码</strong>会构建一个压缩树。最小优先级队列用于重复查找两个频率最小的节点，这些节点未具有父节点。</li>
</ul>
<p>优先级队列的应用范围很广，远不止上述列举的部分。</p>
<h2 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h2><p>在 <a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-08/">#8\ 队列的Swift实现与操作定义</a>中我们为队列定义了如下的一个协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span>  <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级队列和普通队列同样有着相同的操作，只是具体的实现会有所不同。</p>
<p>对于优先级队列而言，同样对遵循协议<strong>Queue</strong>，并实现一些一般性的操作如下：</p>
<ul>
<li><strong>enqueue：</strong>插入一个元素到队列，如果操作成功，则返回<em>true</em>；</li>
<li><strong>dequeue：</strong>移除具有最高优先级的元素，并返回它，如果队列为空，则返回<em>nil</em>；</li>
<li><strong>isEmpty：</strong>检查队列是否为空；</li>
<li><strong>peek：</strong>返回具有最高优先级的队列，但并不进行删除，如果队列为空，则返回<em>nil</em>。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>构建优先级队列的方式有以下几种：</p>
<ol>
<li><strong>已排序数组</strong>：在获取最大值或最小值的时间复杂度均为O(1)，使用此数据构建优先级队列非常有效，但是其插入算法却比较慢，会达到O(n)的时间复杂度。</li>
<li><strong>平衡二叉搜索树</strong>：在创建双端优先级队列时，使用平衡二叉搜索树最为有利，此时获取最小值和最大值的时间复杂度均在_O(log n)，插入算法比排序的数组会更好，在O(log n)。</li>
<li><strong>堆</strong>：优先级队列最佳的选择，堆结构比排序的数组更为有效，因为堆只需要部分排序，除了从最小堆中获取最小值和从最大堆中获取最大值为O(1)的快速外，其他的操作均为O(log n)的时间复杂度。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Equatable</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> heap: <span class="type">Heap</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>, <span class="params">elements</span>: [<span class="type">Element</span>] <span class="operator">=</span> []) &#123;</span><br><span class="line">        heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><em>PriorityQueue</em> 遵循队列协议<em>Queue</em>。泛型参数元素必须遵循<em>Equatable</em>，因为在元素的操作中需要能够进行元素间的比较。</li>
<li>使用堆数据结构实现优先级队列；</li>
<li>传递合适的参数到初始化构造函数，<em>PriorityQueue</em>可根据参数构建最小和最大优先级队列。</li>
</ol>
<p>为了遵循<em>Queue</em>协议，需要增加如下的协议方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    heap.insert(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中优先级队列上，堆是最为完美的选择，只需要调用堆的各种方法即可实现优先级队列的各种操作。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;priorityQueue&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> priorityQueue <span class="operator">=</span> <span class="type">PriorityQueue</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>priorityQueue.isEmpty &#123;</span><br><span class="line">        <span class="built_in">print</span>(priorityQueue.dequeue()<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of priorityQueue---</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>一个优先级队列通常使用<strong>优先级顺序</strong>进行元素的查找；</li>
<li>能够通过关注队列的关键操作而排除堆数据结构提供的其他功能，从而创建抽象层。</li>
<li>使得优先级队列的意图清晰而简洁。唯一的工作是排队和取消排队元素。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/20/cover.jpg" alt="\#20\ 堆排序（Heap Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1206个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/">\#20\ 堆排序（Heap Sort）</a></h1><div class="content"><p>**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看<a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-15/">\#15\ 堆数据结构（The Heap Data Structure）</a>中的介绍。</p>
<p>堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质：</p>
<ol>
<li>在最大堆中，所有的父节点均大于其孩子节点；</li>
<li>在最小堆中，所有的父节点均小于其孩子节点。</li>
</ol>
<p>最大堆和最小堆的图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/max-min-heap.png"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对于给定的未排序的数组，从小到大进行排序，堆排序都必须首先将该数组转换为最大堆结构。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-1.png"></p>
<p>对上述数组通过筛选所有父节点进行转换，此时使用sift-down方式，最终转换后的结果如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-2.png"></p>
<p>对应的数组为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-3.png"></p>
<p>由于单次sift-down操作的时间复杂度为O(log n)，因此构建一个堆的整体时间复杂度为O(n log n)。</p>
<p>堆排序是将数组元素进行升序排序。因为在最大堆中，最大的元素通常位于根节点，因此可以<strong>使用索引0的元素和索引n-1的元素进行直接交换</strong>。这样交换后，数组最后的元素便位于正确地位置，但是此时堆已经不符合堆的规则了。下一步对新的根节点元素进行sift-down操作，使得堆成立。（此时进行sift-down的时候，需要将排除部分已排序好的元素）</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-4.png"></p>
<p>对元素5进行sift-down之后，新的根节点为原始堆中第二大的元素21，此时同样和末尾元素6进行交换，交换后继续对新的根节点6进行sift-down操作，再次使得堆成立。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-5.png"></p>
<p>上述过程其实形成了一种模式，堆排序简单直接，每次交换首末两个元素，较大的元素依次被交换到数组的后面，多次交换完成后，数组变成了从小到大的顺序，也完成了堆排序。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-6.png"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>堆排序的实现是基于堆的数据结构基础上的，是对堆结构的一种功能扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftSown</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>, <span class="params">upTo</span> <span class="params">size</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> parent <span class="operator">=</span> index</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">               <span class="keyword">let</span> left <span class="operator">=</span> leftChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">let</span> right <span class="operator">=</span> rightChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">var</span> candidate <span class="operator">=</span> parent</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> left <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[left], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> left</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> right <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[right], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> right</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> candidate <span class="operator">==</span> parent &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               elements.swapAt(parent, candidate)</span><br><span class="line">               parent <span class="operator">=</span> candidate</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sorted</span>() -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> heap.elements.indices.reversed() &#123;</span><br><span class="line">            heap.elements.swapAt(<span class="number">0</span>, index)</span><br><span class="line">            heap.siftSown(from: <span class="number">0</span>, upTo: index)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要对原来Heap结构的sift-down方法进行改造，增加参数size以标记当前集合的大小。</p>
</blockquote>
<p>堆排序算法工作流程如下：</p>
<ol>
<li>首先对原有堆进行一个拷贝。因为在堆排序堆元素集合进行排序后，原有的堆结构将不再成立，为了保持堆结构成立，这里使用其拷贝进行排序；</li>
<li>从集合末尾元素开始，对集合进行遍历；</li>
<li>交换首末位置的元素，此次交换后，最大的元素将位于集合的末尾；</li>
<li>交换元素位置后，堆结构已经不成立了，因此需要使用sift-down方法对集合重新调整，已重生合法的堆结构，完成后，新的根节点将是原集合中第二大的元素。重复第三步即可。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;heap sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">6</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(heap.sorted())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of heap sort---</span></span><br><span class="line"><span class="comment">[2, 5, 6, 8, 9, 12, 18, 21, 26]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>堆排序的最佳、最差和平均性能都是O(n log n)。因为必须遍历整个列表一次，并且每次交换元素时，都必须执行向下筛选sift-down操作，这是一个O(log n)操作。</p>
<p>堆排序也不是一种稳定的排序，因为它取决于元素如何布局和放入堆中。例如，如果您正在根据一副纸牌的等级对其进行堆排序，您可能会看到它们的套件相对于原始纸牌的顺序发生了变化。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>堆排序利用最大堆数据结构对数组中的元素进行排序。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2018-07-24-speech-recognation-mfcc/"><img class="fill" src="/images/speech-recognition/audio_draw.png" alt="基于MFCC的语音数据特征提取概述"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.101Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">39 分钟读完 (大约5786个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-07-24-speech-recognation-mfcc/">基于MFCC的语音数据特征提取概述</a></h1><div class="content"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>语音是人类之间沟通交流的最直接也是最快捷方便的一种手段，而实现人类与计算机之间畅通无阻的语音交流，一直是人类追求的一个梦想。</p>
<p>伴随着移动智能设备的普及，各家移动设备的厂家也开始在自家的设备上集成了语音识别系统，像Apple Siri、Microsoft Cortana、Google Now等语音助手的出现，使得人们在使用移动设备的同时，也能够进行语音交流，极大的方便了人们的生活。但是此类助手也存在一些尴尬的瞬间，例如在一些工作场合或者聚会的场合，某人的一句“Hey Siri”就可能唤醒多台苹果设备，使用者难免尴尬困惑。</p>
<p>而此类予语音助手背后，均是一种被称作“闻声识人”的计算机技术，称为<strong>语音识别</strong>。语音识别技术属于生物认证技术，而其中的说话人识别（speaker recognize，SR）是其中的一种，该技术通常也被称为<strong>声纹识别</strong>技术，该技术是一项通过语音波形中反映说话人生理特征和行为特征的一组语音参数，自动识别说话人身份的技术。其核心是通过预先录入说话人的声音样本，提取出说话人独一无二的语音特征并存入数据库，应用的时候将待验证的语音进行特征提取并与数据库中的特征进行匹配，以确定说话人的身份。</p>
<h2 id="1-1-什么是声纹？"><a href="#1-1-什么是声纹？" class="headerlink" title="1.1 什么是声纹？"></a>1.1 什么是声纹？</h2><p>声纹（voiceprint）是用电声学仪器显示的携带者言语信息的声波频谱，是由波长、频率以及强度等百余种特征维度组成的生物特征，具有稳定性、可测量性以及唯一性等特点。</p>
<ul>
<li>人类语言的产生是由人体语言中枢与发生器官之间进行的一个复杂的生物物理反应过程。发声器官如舌头、牙齿、喉咙、肺、鼻子在尺寸和形态上因人而异，所有任何两个人的声波图谱都有一定的差异性。</li>
<li>每个人的语音声学特征既有相对稳定性，又有个体差异性。这种差异可能来自生理、病理、心理、模拟、伪装等，也可能会周围环境的干扰相关。</li>
<li>由于每个人的发生器官都有其独特性，因此在一般情况下，人们仍然能区别不同的人的声音或者判断是否是同一个人的声音。</li>
</ul>
<p>声纹不像图像那样的直观，在实际的分析中，可以通过波形图和语谱图进行绘制展现，例如下图是一段从1到10的读数语音文件对应的波形图和语谱图（上部分为声音波形图，下部分为声音语谱图）：</p>
<p><img src="/images/speech-recognition/audio_draw.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fw = wave.<span class="built_in">open</span>(<span class="string">&#x27;test.wav&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">soundInfo = fw.readframes(-<span class="number">1</span>)</span><br><span class="line">soundInfo = np.fromstring(soundInfo,np.int16)</span><br><span class="line">f = fw.getframerate()</span><br><span class="line">fw.close()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(soundInfo)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Wave from and spectrogram of test.wav&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.specgram(soundInfo,Fs = f, scale_by_freq = <span class="literal">True</span>, sides = <span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time(seconds)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>语谱图更简单的绘制方法，可参考 <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.signal.spectrogram.html">scipy.signal.spectrogram</a>。</li>
<li>语谱图绘制的原理，可参考 <a target="_blank" rel="noopener" href="http://www.frank-zalkow.de/en/code-snippets/create-audio-spectrograms-with-python.html?i=1">Create audio spectrograms with Python</a>。</li>
</ul>
<p>与其他的生物认证技术如指纹识别、人脸识别、虹膜识别等相同，声纹识别具有不会遗忘、无需记忆和使用方便等优点。在生物认证技术领域，说话人识别技术以其独特的方便性、经济性和准确性收到人们的广泛关注，并日益成为人们日常生活和工作中重要且普及的安全认证方式。</p>
<p>但是，说话人识别有着其他生物认证技术所不具有的优势：</p>
<ul>
<li>用户接受度高：以声音作为识别特征，因其非接触性和自然醒，用户易接受。用户不用刻意的用手指触摸相应的传感器上，也不用将眼睛凑向摄像头，只需要简单的说一两句话即可完成识别认证。</li>
<li>设备成本低：对输入设备如麦克风，摄像头等没有特别的要求，特征提取，模型训练和匹配只需要普通的计算机即可完成。</li>
<li>其他生物认证特征技术各有其劣势：指纹识别需要特殊的传感器芯片，虹膜识别精确度较高，但是设备较为昂贵。</li>
<li>在远程应用和移动互联网环境下优势明显：通过电话、移动设备进行身份认证，声音是最具优势的生物特征，语音控制也逐渐成为流行的交互形式，以声音为特征的身份鉴别技术也越发重要。</li>
</ul>
<h2 id="1-2-声纹识别技术的历史"><a href="#1-2-声纹识别技术的历史" class="headerlink" title="1.2 声纹识别技术的历史"></a>1.2 声纹识别技术的历史</h2><p>声纹识别技术的研究始于20世纪30年代，早期的工作主要集中于人耳听辨实验和探讨听音识别的可能性方面。随着研究手段和计算机技术的发展，研究工作逐渐脱离了单纯的人耳听辨，使得通过机器自动识别人的声音称为可能。在这个过程中也出现了很多不同的计算机技术，从早期的模板匹配到最新的深度学习技术，均在不断的刷新着语音识别技术手段。整体来看，声纹识别技术的发展经历了七个技术演进之路，详见下图（下图来自speakin）：</p>
<p><img src="/images/speech-recognition/voiceprint_history.jpg"></p>
<h2 id="1-3-声纹识别的种类"><a href="#1-3-声纹识别的种类" class="headerlink" title="1.3 声纹识别的种类"></a>1.3 声纹识别的种类</h2><p>声纹识别根据实际应用的范畴可以分为 1:1识别 和 1:N识别两种：</p>
<ul>
<li><p>1:1识别：指确定待识别的一段语音是否来自其所声明的目标说话人，即确认目标说话人是目标说话人的过程。通常应用于电子支付、智能硬件、银行证券交易等。1:1识别有两个系统的性能评价参量，分别为</p>
<ul>
<li>错误接受率(False Acceptation Rate, FAR)：将非目标说话人判别为目标说话人造成的错误率</li>
<li>错误拒绝率(False Rejection Rate, FRR)：将目标说话人误识成非目标说话人造成的错误率</li>
</ul>
<p>  对安全性要求越高，则设定阈值越高，此时接受目标说话人的条件越严格，即FRR越高，FAR越低；对用户体验要求越高，则设定阈值越低，此时接受目标说话人的条件越宽松，即FAR越高，FRR越低。在声纹系统中，可以通过设定不同的阈值来平衡FAR和FRR。</p>
</li>
<li><p>1:N识别：指判定待识别语音属于目标说话人模型集合中的哪一个人，即在N个人中找到目标说话人的过程。通常应用于公安司法、军队国防等。</p>
</li>
</ul>
<h1 id="2-语音的特征提取方法概述"><a href="#2-语音的特征提取方法概述" class="headerlink" title="2. 语音的特征提取方法概述"></a>2. 语音的特征提取方法概述</h1><p>语音是一种数字信号，其数字⾳频的采样率为44100Hz（根据乃奎斯特取样定理得出的结果，在模拟讯号数字化的过程中，如果保证取样频率大于模拟讯号最高频率的2倍，就能100%精确地再还原出原始的模拟讯息。音频的最高频率为20kHz，所以取样率至少应该大于40kHz，为了留一点安全系数，再考虑到工程上的习惯，最终选择了44.1kHz这个数值）。通常情况下使用傅里叶变换将信号在时域与频域之间进行转换，而频谱图可以显示傅里叶变换后的振幅与时间和频率的对应关系。</p>
<h2 id="2-1-特征提取方法"><a href="#2-1-特征提取方法" class="headerlink" title="2.1 特征提取方法"></a>2.1 特征提取方法</h2><p>对于语音识别系统而言，所提取的特征参数需要能够反映特定发信的信息，在说话人无关的系统中，更要求参数能够反映不同说话人相同发音的信息，要求说话人的特征参数要能够代表特定的说话人，能够区分不同说话人相同语音之间的差异，最好能够做到与具体的发音内容无关，也称为文本无关。</p>
<p>在语音特征参数提取技术的发展历程中，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qingkongyeyue/article/details/52149839">线性预测编码（Linear Predictive Coding, LPC）</a>被广泛应用于语音特征参数的提取，其中包括LPC系数、反射LPC系数、面积函数和LPC倒谱系数，能够很好的反映语音的声道特征，但是却对语音的其他特征无能为力。</p>
<p> 不同于LPC等通过对人的发声机理进行研究而得到的声学特征，Mel倒谱系数MFCC是受人的听觉系统研究成果推出而导出的声学特征。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉灵敏度。从200Hz到5000Hz的语音信号对语音的清晰度影响最大。人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPC相比具有更好的鲁棒性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。</p>
<p> MFCC（MeI-Freguency CeptraI Coefficients）是需要语音特征参数提取方法之一，因其独特的基于倒谱的提取方式，更加的符合人类的听觉原理，因而也是最为普遍、最有效的语音特征提取算法。MFCC是在Mel标度频率域提取出来的倒谱系数，Mel标度描述了人耳对频率感知的非线性特性。</p>
<h2 id="2-2-MFCC语音特征提取"><a href="#2-2-MFCC语音特征提取" class="headerlink" title="2.2 MFCC语音特征提取"></a>2.2 MFCC语音特征提取</h2><p>MFCC 语音特征的提取过程，如下图：</p>
<p><img src="/images/speech-recognition/mfcc-process.png"></p>
<p>需要对语音信号进行预加重、分帧、加窗等等处理，而这些处理的方式均是为了能够最大化语音信号的某些信息，以达到最好特征参数的提取。</p>
<h3 id="2-2-1-预加重"><a href="#2-2-1-预加重" class="headerlink" title="2.2.1 预加重"></a>2.2.1 预加重</h3><p>预加重其实就是将语音信号通过一个高通滤波器，来增强语音信号中的高频部分，并保持在低频到高频的整个频段中，能够使用同样的信噪比求频谱。在本实验中，选取的高通滤波器传递函数为：</p>
<p><img src="/images/speech-recognition/high_pass_filter.png"></p>
<p>式中a的值介于0.9-1.0之间，我们通常取0.97。同时，预加重也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_emphasis</span>(<span class="params">signal, coefficient=<span class="number">0.97</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;对信号进行预加重&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> numpy.append(signal[<span class="number">0</span>], signal[<span class="number">1</span>:] - coefficient * signal[:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-分帧"><a href="#2-2-2-分帧" class="headerlink" title="2.2.2 分帧"></a>2.2.2 分帧</h3><p>分帧是指在跟定的音频样本文件中，按照某一个固定的时间长度分割，分割后的每一片样本，称之为一帧，这里需要区分时域波形中的帧，分割后的一帧是分析提取MFCC的样本，而时域波形中的帧是时域尺度上对音频的采样而取到的样本。</p>
<p>分帧是先将N个采样点集合成一个观测单位，也就是分割后的帧。通常情况下N的取值为512或256，涵盖的时间约为20-30ms。也可以根据特定的需要进行N值和窗口间隔的调整。为了避免相邻两帧的变化过大，会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，一般M的值约为N的1&#x2F;2或1&#x2F;3。</p>
<p>语音识别中所采用的信号采样频率一般为8kHz或16kHz。以8kHz来说，若帧长度为256个采样点，则对应的时间长度是256&#x2F;8000×1000&#x3D;32ms。本次实验中所使用的采样率(Frames Per Second)16kHz，窗长25ms（400个采样点），窗间隔为10ms（160个采样点）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">audio2frame</span>(<span class="params">signal, frame_length, frame_step, winfunc=<span class="keyword">lambda</span> x: numpy.ones(<span class="params">(<span class="params">x,</span>)</span>)</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;分帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    signal_length = <span class="built_in">len</span>(signal)</span><br><span class="line">    frame_length = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_length))</span><br><span class="line">    frame_step = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_step))</span><br><span class="line">    <span class="keyword">if</span> signal_length &lt;= frame_length:</span><br><span class="line">        frames_num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        frames_num = <span class="number">1</span> + <span class="built_in">int</span>(math.ceil((<span class="number">1.0</span> * signal_length - frame_length) / frame_step))</span><br><span class="line">    pad_length = <span class="built_in">int</span>((frames_num - <span class="number">1</span>) * frame_step + frame_length)</span><br><span class="line">    zeros = numpy.zeros((pad_length - signal_length,))</span><br><span class="line">    pad_signal = numpy.concatenate((signal, zeros))</span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_length), (frames_num, <span class="number">1</span>)) + numpy.tile(numpy.arange(<span class="number">0</span>, frames_num * frame_step, frame_step),(frame_length, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    frames = pad_signal[indices]</span><br><span class="line">    win = numpy.tile(winfunc(frame_length), (frames_num, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> frames * win</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-加窗"><a href="#2-2-3-加窗" class="headerlink" title="2.2.3 加窗"></a>2.2.3 加窗</h3><p>在对音频进行分帧之后，需要对每一帧进行加窗，以增加帧左端和右端的连续性，减少频谱泄漏。在提取MFCC的时候，比较常用的窗口函数为Hamming窗。</p>
<p>假设分帧后的信号为 <em>S(n),n&#x3D;0,1,2…,N-1</em>，其中N为帧的大小，那么进行加窗的处理则为：</p>
<p><img src="/images/speech-recognition/fps_hamming1.jpg"></p>
<p>W(n)的形式如下：</p>
<p><img src="/images/speech-recognition/fps_hamming2.jpg"></p>
<p>不同的a值会产生不同的汉明窗，一般情况下a取值0.46。进行值替换后，W(n)则为：</p>
<p><img src="/images/speech-recognition/fps_hamming3.png"></p>
<p>对应的汉明窗时域波形类似下图：</p>
<p><img src="/images/speech-recognition/fps_hamming4.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deframesignal</span>(<span class="params">frames, signal_length, frame_length, frame_step, winfunc=<span class="keyword">lambda</span> x: numpy.ones(<span class="params">(<span class="params">x,</span>)</span>)</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;加窗&#x27;&#x27;&#x27;</span></span><br><span class="line">    signal_length = <span class="built_in">round</span>(signal_length)</span><br><span class="line">    frame_length = <span class="built_in">round</span>(frame_length)</span><br><span class="line">    frames_num = numpy.shape(frames)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> numpy.shape(frames)[<span class="number">1</span>] == frame_length, <span class="string">&#x27;&quot;frames&quot;矩阵大小不正确，它的列数应该等于一帧长度&#x27;</span></span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_length), (frames_num, <span class="number">1</span>)) + numpy.tile(numpy.arange(<span class="number">0</span>, frames_num * frame_step, frame_step),(frame_length, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    pad_length = (frames_num - <span class="number">1</span>) * frame_step + frame_length</span><br><span class="line">    <span class="keyword">if</span> signal_length &lt;= <span class="number">0</span>:</span><br><span class="line">        signal_length = pad_length</span><br><span class="line">    recalc_signal = numpy.zeros((pad_length,))</span><br><span class="line">    window_correction = numpy.zeros((pad_length, <span class="number">1</span>))</span><br><span class="line">    win = winfunc(frame_length)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, frames_num):</span><br><span class="line">        window_correction[indices[i, :]] = window_correction[indices[i, :]] + win + <span class="number">1e-15</span></span><br><span class="line">        recalc_signal[indices[i, :]] = recalc_signal[indices[i, :]] + frames[i, :]</span><br><span class="line">    recalc_signal = recalc_signal / window_correction</span><br><span class="line">    <span class="keyword">return</span> recalc_signal[<span class="number">0</span>:signal_length]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-对信号进行离散傅立叶变换-DFT"><a href="#2-2-4-对信号进行离散傅立叶变换-DFT" class="headerlink" title="2.2.4 对信号进行离散傅立叶变换 (DFT)"></a>2.2.4 对信号进行离散傅立叶变换 (DFT)</h3><p>由于信号在时域上的变换通常很难看出信号的特性，所有通常将它转换为频域上的能量分布来观察，不同的能量分布，代表不同语音的特性。所以在进行了加窗处理后，还需要再经过离散傅里叶变换以得到频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。设语音信号的DFT为：</p>
<p><img src="/images/speech-recognition/dft1.png"></p>
<p>能量的分布为：</p>
<p><img src="/images/speech-recognition/dft2.png"></p>
<p>在本次实验中，采用DFT长度 N&#x3D;512，结果值保留前257个系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spectrum_magnitude</span>(<span class="params">frames, NFFT = <span class="number">512</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算每一帧经过FFT变幻以后的频谱的幅度，若frames的大小为N*L,则返回矩阵的大小为N*NFFT&#x27;&#x27;&#x27;</span></span><br><span class="line">    complex_spectrum = numpy.fft.rfft(frames, NFFT)</span><br><span class="line">    <span class="keyword">return</span> numpy.absolute(complex_spectrum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spectrum_power</span>(<span class="params">frames, NFFT</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算每一帧傅立叶变换以后的功率谱&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / NFFT * numpy.square(spectrum_magnitude(frames, NFFT))</span><br></pre></td></tr></table></figure>

<p>下图是有频谱到功率谱的转换结果示意图：</p>
<p><img src="/images/speech-recognition/dft3.png"></p>
<h3 id="2-2-5-应用梅尔滤波器-Mel-Filterbank"><a href="#2-2-5-应用梅尔滤波器-Mel-Filterbank" class="headerlink" title="2.2.5 应用梅尔滤波器 (Mel Filterbank)"></a>2.2.5 应用梅尔滤波器 (Mel Filterbank)</h3><p>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。 在Mel频域内，人对音调的感知度为线性关系。举例来说，如果两段语音的Mel频率相差两倍，则人耳听起来两者的音调也相差两倍。Mel滤波器的本质其实是一个尺度规则，通常是将能量通过一组Mel尺度的三角形滤波器组，如定义有M个滤波器的滤波器组，采用的滤波器为三角滤波器，中心频率为 <em>f(m),m&#x3D;1,2…M</em>，M通常取22-26。f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示：</p>
<p><img src="/images/speech-recognition/mel1.jpg"></p>
<p>从频率到Mel频率的转换公式为： </p>
<p> <img src="/images/speech-recognition/mel_hz.jpg"></p>
<p> 其中 f 为语音信号的频率，单位赫兹（Hz）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hz2mel</span>(<span class="params">hz</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;把频率hz转化为梅尔频率&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2595</span> * numpy.log10(<span class="number">1</span> + hz / <span class="number">700.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mel2hz</span>(<span class="params">mel</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;把梅尔频率转化为hz&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">700</span> * (<span class="number">10</span> ** (mel / <span class="number">2595.0</span>) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>假如有10个Mel滤波器（在实际应用中通常一组Mel滤波器组有26个滤波器。），首先要选择一个最高频率和最低频率，通常最高频率为8000Hz，最低频率为300Hz。使用从频率转换为Mel频率的公式将300Hz转换为401.25Mels，8000Hz转换为2834.99Mels，由于有10个滤波器，每个滤波器针对两个频率的样点，样点之间会进行重叠处理，因此需要12个点，意味着需要在401.25和2834.99之间再线性间隔出10个附加点，如：</p>
<p><em>m(i) &#x3D; 401.25,622.50,843.75,1065.00,1286.25,1507.50, 1728.74,1949.99,2171.24,2392.49,2613.74,2834.99</em></p>
<p>现在使用从Mel频率转换为频率的公式将它们转换回赫兹：</p>
<p><em>h(i) &#x3D; 300,517.33,781.90,1103.97,1496.04,1973.32,2554.33, 3261.62,4122.63,5170.76,6446.70,8000</em></p>
<p>将频率映射到最接近的DFT频率：</p>
<p><img src="/images/speech-recognition/mel2.png"></p>
<p><em>f(i) &#x3D; 9,16,25,35,47,63,81,104,132,165,206,256</em></p>
<p>于是，我们得到了一个由10个Mel滤波器构成的Mel滤波器组。</p>
<p><img src="/images/speech-recognition/mel3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_filter_banks</span>(<span class="params">filters_num=<span class="number">20</span>, NFFT=<span class="number">512</span>, samplerate=<span class="number">16000</span>, low_freq=<span class="number">0</span>, high_freq=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算梅尔三角间距滤波器，该滤波器在第一个频率和第三个频率处为0，在第二个频率处为1&#x27;&#x27;&#x27;</span></span><br><span class="line">    low_mel = hz2mel(low_freq)</span><br><span class="line">    high_mel = hz2mel(high_freq)</span><br><span class="line">    mel_points = numpy.linspace(low_mel, high_mel, filters_num + <span class="number">2</span>)</span><br><span class="line">    hz_points = mel2hz(mel_points)</span><br><span class="line">    <span class="built_in">bin</span> = numpy.floor((NFFT + <span class="number">1</span>) * hz_points / samplerate)</span><br><span class="line">    fbank = numpy.zeros([filters_num, NFFT / <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, filters_num):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">int</span>(<span class="built_in">bin</span>[j]), <span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">1</span>])):</span><br><span class="line">            fbank[j, i] = (i - <span class="built_in">bin</span>[j]) / (<span class="built_in">bin</span>[j + <span class="number">1</span>] - <span class="built_in">bin</span>[j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">1</span>]), <span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">2</span>])):</span><br><span class="line">            fbank[j, i] = (<span class="built_in">bin</span>[j + <span class="number">2</span>] - i) / (<span class="built_in">bin</span>[j + <span class="number">2</span>] - <span class="built_in">bin</span>[j + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> fbank</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-对频谱进行离散余弦变换-DCT"><a href="#2-2-6-对频谱进行离散余弦变换-DCT" class="headerlink" title="2.2.6 对频谱进行离散余弦变换 (DCT)"></a>2.2.6 对频谱进行离散余弦变换 (DCT)</h3><p>在上一步的基础上使⽤离散余弦变换，即进⾏了⼀个傅⽴叶变换的逆变换，得到倒谱系数。</p>
<p><img src="/images/speech-recognition/dct.png"></p>
<p>由此可以得到26个倒谱系数。只取其[2:13]个系数，第1个用能量的对数替代，这13个值即为所需的13个MFCC倒谱系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lifter</span>(<span class="params">cepstra, L=<span class="number">22</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;升倒谱函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> L &gt; <span class="number">0</span>:</span><br><span class="line">        nframes, ncoeff = numpy.shape(cepstra)</span><br><span class="line">        n = numpy.arange(ncoeff)</span><br><span class="line">        lift = <span class="number">1</span> + (L / <span class="number">2</span>) * numpy.sin(numpy.pi * n / L)</span><br><span class="line">        <span class="keyword">return</span> lift * cepstra</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cepstra</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7-动态差分参数的提取（包括一阶微分系数和加速系数）"><a href="#2-2-7-动态差分参数的提取（包括一阶微分系数和加速系数）" class="headerlink" title="2.2.7 动态差分参数的提取（包括一阶微分系数和加速系数）"></a>2.2.7 动态差分参数的提取（包括一阶微分系数和加速系数）</h3><p>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。差分参数的计算可以采用下面的公式：</p>
<p><img src="/images/speech-recognition/dlog.png"></p>
<p>上式中，d(t)表示第t个一阶微分，c(t)表示第t个倒谱系数，Q表示倒谱系数的阶数，K表示一阶导数的时间差，可取1或2。将上式的结果再代入就可以得到加速系数。</p>
<p>⾄此，我们计算到了了⾳频⽂件每⼀帧的39个Mel频率倒谱系数（13个MFCC+13个一阶微分系数+13个加速系数），这些即为一个语音文件的特征数据，这些特征数据可以运用在之后的分类中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">derivate</span>(<span class="params">feat, big_theta=<span class="number">2</span>, cep_num=<span class="number">13</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算一阶系数或者加速系数的一般变换公式&#x27;&#x27;&#x27;</span></span><br><span class="line">    result = numpy.zeros(feat.shape)</span><br><span class="line">    denominator = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> theta <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, big_theta, big_theta):</span><br><span class="line">        denominator = denominator + theta ** <span class="number">2</span></span><br><span class="line">    denominator = denominator * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> numpy.linspace(<span class="number">0</span>, feat.shape[<span class="number">0</span>] - <span class="number">1</span>, feat.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = numpy.zeros((cep_num,))</span><br><span class="line">        numerator = numpy.zeros((cep_num,))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, cep_num, cep_num):</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> theta <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, big_theta, big_theta):</span><br><span class="line">                <span class="keyword">if</span> (t + theta) &gt; cep_num:</span><br><span class="line">                    a = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a = feat[row][t + theta - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> (t - theta) &lt; <span class="number">1</span>:</span><br><span class="line">                    b = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b = feat[row][t - theta - <span class="number">1</span>]</span><br><span class="line">                s += theta * (a - b)</span><br><span class="line">            numerator[t - <span class="number">1</span>] = s</span><br><span class="line">        tmp = numerator * <span class="number">1.0</span> / denominator</span><br><span class="line">        result[row] = tmp</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文针对语音数据的特征提取方法—MFCC进行了简单的概述和实践，MFCC是音频特征处理中比较常用而且很有效的方法。当特征数据提取出来之后，就可以进一步的进行数据的归一化、标准化，然后应用于机器学习、神经网络等等模型训练算法中，以得到能够识别语音类别的模型。在实际的应用中，可能还需要考虑很多的其他因素，例如源语音数据的采集方法、采集时长、模型的构建方式、模型的部署方式等等因素，因此需要根据业务的具体场景，来进行平衡取舍，以达到识别的时效性、准确性等。</p>
<p>目前关于语音识别相关的研究还在持续中，目标是能够最小化成本的在移动端部署语音识别相关的功能，提高SDK在人工智能方便的能力等。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel-frequency cepstrum</a></li>
<li><a target="_blank" rel="noopener" href="http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/">Mel Frequency Cepstral Coefficient (MFCC) tutorial
</a></li>
<li><a target="_blank" rel="noopener" href="https://musicinformationretrieval.com/">Notes on Music Information Retrieval</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/daniel-D/p/3244718.html">机器学习中距离和相似性度量方法</a></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/14/cover.jpg" alt="\#14\ 二分查找（Binary Search）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/">\#14\ 二分查找（Binary Search）</a></h1><div class="content"><p>二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足：</p>
<ul>
<li>集合必须是在恒定的时间内执行索引操作，意味着集合必须是<strong>RandomAccessCollection</strong>类型的；</li>
<li>集合必须是<strong>sorted</strong>的。</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>在Swift标准库中的Array结构中，通过*index(of:)*来实现线性的元素搜索，也就是意味着Array中的元素搜索需要遍历整个数组。</p>
<blockquote>
<p>在Swift 5中<em>index(of:)</em> 已经废弃，取而代之的为*firstIndex(of:)*。</p>
</blockquote>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/array-linear-search.png"></p>
<p>而二分查找则是在已排序的数组上，以不同的处理方式进行元素的搜索。例如下图所示，在已排序的数组中搜索元素31：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-31.png"></p>
<p>和一般的数组元素查找不同的是，二分查找按照如下的步骤进行元素的搜索：</p>
<p><strong>Step 1：找到中间位置的索引</strong></p>
<p>二分查找第一步，便是找到集合中间位置，这一步非常直接，通过集合的元素总数进行计算获得：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/step-1-find-middle-index.png"></p>
<p><strong>Step 2：检查中间索引位置的元素</strong></p>
<p>下一步则是检查中间位置的元素，如果和预检索的元素匹配，则直接返回索引，如果不相符，则继续第三步，继续检索元素。</p>
<p><strong>Step 3：递归进行二分查找</strong></p>
<p>最后一步是递归调用二分查找，但是这时，仅仅需要检索的是集合中间索引左侧或者右侧，而非整个集合。当中间位置的元素小于预检索的元素时，则检索中间位置右侧，反之，检索中间位置左侧。</p>
<p>二分查找每一步的检索之后，都会减少一半的检索范围，这样大大的减小了检索的时间耗时，提高检索效率。</p>
<p>在上述例子中，为了检索元素31，由于中间位置的元素为22，小于预检索的元素31，因此将继续检索中间位置元素22的右侧元素：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-22-right.png"></p>
<p>二分查找从大的方面来说，每一次的元素检索只需要三步，直到无法将集合再次进行左右划分或者找到元素为止。</p>
<p>二分查找的时间复杂度为O(log n)。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>首先定义二分查找使用范围，以及集合元素的可比较性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>? &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>由于二分查找仅仅适用于集合类型<strong>RandomAccessCollection</strong>，并且其中的元素需要可比较的特性，因此针对该类型进行扩展并设定元素可比较性，并添加二分查找方法的定义；</li>
<li>二分查找在运行过程中需要递归调用，因此在函数定义中要执行每一次递归的范围，参数<strong>range</strong>是可选类型，在首次进行二分查找的时候，不需要传入<strong>range</strong>，故其默认值为<strong>nil</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>?&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> range <span class="operator">=</span> range <span class="operator">??</span> startIndex <span class="operator">..&lt;</span> endIndex</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> range.lowerBound <span class="operator">&lt;</span> range.upperBound <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> size <span class="operator">=</span> distance(from: range.lowerBound, to: range.upperBound)</span><br><span class="line">        <span class="keyword">let</span> middle <span class="operator">=</span> index(range.lowerBound, offsetBy: size <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">&gt;</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: range.lowerBound <span class="operator">..&lt;</span> middle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: middle <span class="operator">..&lt;</span> range.upperBound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查<em>range</em>是否为<em>nil</em>，如果为<em>nil</em>，则获取集合完整的索引范围<em>startIndex ..&lt; endIndex</em>；</li>
<li>检查集合是否为空，这里的检查方式是通过集合的最小边界和最大边界进行判断集合是否至少有一个元素，否则直接返回<em>nil</em>；</li>
<li>通过集合的最小边界和最大边界，获取集合的长度，之后使用*index(offsetBy:)*方法获取集合中间位置的索引；</li>
<li>如果中间位置的元素就是我们要查找的元素，则直接返回中间位置索引；</li>
<li>如果中间位置的元素大于预查找的元素，则说明预查找元素在集合中间位置的左侧，递归调用*binarySearch(for:range:)*方法，继续查找；</li>
<li>如果中间位置的元素小于预查找的元素，则说明预查找的元素在集合中间位置的右侧，递归调用*binarySearch(for:range:)*方法，继续查找。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;binary search&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">105</span>, <span class="number">150</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> search31 <span class="operator">=</span> array.firstIndex(of: <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">let</span> binarySearch31 <span class="operator">=</span> array.binarySearch(for: <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index(of:): <span class="subst">\(String(describing: search31))</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;binarySearch(of:): <span class="subst">\(String(describing: binarySearch31))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of binary search---</span></span><br><span class="line"><span class="comment">index(of:): Optional(7)</span></span><br><span class="line"><span class="comment">binarySearch(of:): Optional(7)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>二分查找是一种强大的算法，每当某些场景下，集合的元素时已排序的情况下，都可以考虑使用二分查找的方法。另外，如果遇到的问题似乎进行元素搜索需要O(n^2)的时间复杂度，可以考虑先对集合进行前期的排序，然后采用二分查找的方法将时间复杂度降低到O(n log n)的程度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>二分查找仅仅对已排序的集合有效；</li>
<li>有时候，对集合进行排序后，再使用二分查找是有益的；</li>
<li>对于集合本身，其<em>sorted</em>方法的时间复杂度为O(n)，而二分查找的时间复杂度为O(log n)，对于大型数据集合来说，二分查找的可伸缩性更好。</li>
</ul>
<blockquote>
<p>二分查找思想典型的应用场景就是在Bug原因的追查上面，当面对一个无从知晓其最终的引发点的时候，可以尝试使用二分查找的思想，分段校验代码的执行结果，逐步缩小Bug追查的范围，提高Bug原因的追查效率等。</p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-10-Data-Structures-&amp;-Algorithms-in-Swift-15/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/15/cover.jpg" alt="\#15\ 堆数据结构（The Heap Data Structure）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.101Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">23 分钟读完 (大约3469个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-10-Data-Structures-&amp;-Algorithms-in-Swift-15/">\#15\ 堆数据结构（The Heap Data Structure）</a></h1><div class="content"><p>想必抓娃娃机如今没有人不知道其实什么了，抓娃娃机的爪子总是那么的难以控制，总是看起来容易的机会却难以如愿。抓抓机的爪子其实就工作在一个堆数据结构之上，爪子每次抓的几乎都是那边一堆玩具最上面的那一个，只有这样机会才会更大一些。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/zhuawawa.png"></p>
<p>在本文中将学习关于堆（Heap）的基础知识，包含如何创建一个堆数据结构，如果从堆数据结构中获取最大和最小元素等。</p>
<h2 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h2><p>堆是一个使用数组构建的完整二叉树，也称为二叉堆。</p>
<blockquote>
<p>这里的堆和内存堆是完全不同的一个概念，需要区分。在计算机科学中，经常有一些术语被重复使用，但是涵义却有所不同，本文不会对内存堆进行阐述。</p>
</blockquote>
<p>堆有两种类型：</p>
<ol>
<li><strong>最大堆：</strong>堆中元素越大，其优先级越高；</li>
<li><strong>最小堆：</strong>堆中元素越小，其优先级越高。</li>
</ol>
<h2 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h2><p>一个堆结构，有着必须始终满足的重要特征，称之为<strong>堆不变式</strong>或<strong>堆属性</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/max-min-heap.png"></p>
<p>在最大堆中，父节点必须包含一个大于等于其子节点的值，根节点包含最大的值。</p>
<p>在最小堆中，父节点必须包含一个小于等于其子节点的值，根节点包含最小的值。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/level-heap.png"></p>
<p>另一个堆的必须属性是<strong>堆是一个完全二叉树</strong>。意味着树除了叶子节点层之外，其他每一层都必须被填充，有点类似某些闯关类游戏，本关没有完成，则下一关无法开始。</p>
<h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><p>堆在很多场景下都被广泛的应用，例如：</p>
<ul>
<li>计算集合中最小元素和最大元素；</li>
<li>堆排序</li>
<li>优先级队列构造</li>
<li>构造图算法，例如普林演算法 (Prim’s algorithm)或狄克斯特拉算法（Dijkstra’s algorithm）等。</li>
</ul>
<h2 id="常用的堆操作"><a href="#常用的堆操作" class="headerlink" title="常用的堆操作"></a>常用的堆操作</h2><p>首先定义Heap的数据结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Equatable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">let</span> sort: (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sort <span class="operator">=</span> sort</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Heap的数据结构中，包含一个数组<em>elemtns</em>用来保存堆元素，一个<em>sort</em>函数定义堆中集合如何排序的排序函数。构造器接收一个适当的参数，后续用来构建最大和最小堆。</p>
<h2 id="如何表示堆？"><a href="#如何表示堆？" class="headerlink" title="如何表示堆？"></a>如何表示堆？</h2><p>树型结构中的节点能够保存值和其子节点的索引，二叉树同时保存左子树和右子树的引用。堆本质上是一颗二叉树，但是可以使用简单的数组进行表示。利用数组表示堆的好处是良好的时间复杂度和空间复杂度，因为这样堆中的元素保存在内存里，堆元素的交换等能够有良好的的性能表现，与使用二叉树来表示堆，使用数组更加的容易。接下来了解使用数组如何表示一个堆。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/array-heap-tree.png"></p>
<p>为了使用数组表示堆，只需要从左至右一层一层迭代元素即可。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/traversal-eg.png"></p>
<p>当遍历进入高层级的时候，所需要遍历节点数可能会成倍的增加。</p>
<p>现在可以轻松访问堆中的任何节点。您可以将这一点与访问数组中元素的方式进行比较：无需向下遍历左分支或右分支，只需使用简单公式访问数组中的节点即可。</p>
<p>例如给定一个以零为开始索引的 <em>i</em> 对应的节点：</p>
<ul>
<li>当前节点的左子树能够使用 <em>2i + 1</em> 进行访问；</li>
<li>当前节点的右子树能够使用 <em>2i + 2</em> 进行访问；</li>
</ul>
<p>如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/index-math.png"></p>
<p>如果需要访问节点的父节点，依然可以使用索引值 <em>i</em> 求解，例如在索引为 <em>i</em> 的节点上，其父节点索引可通过 *floor( (i - 1) &#x2F; 2)*求得。</p>
<blockquote>
<p>在二叉树中，左子树和右子树的节点搜索需要O(log n)时间复杂度，但是通过数组的方式获取的时候，时间复杂度仅为O(1)。</p>
</blockquote>
<p>了解了堆的知识后，即可继续完善堆的数据结构，并为其添加一些方便的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">leftChildIndex</span>(<span class="params">ofParentAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> <span class="operator">*</span> index) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">rightChildIndex</span>(<span class="params">ofParentAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> <span class="operator">*</span> index) <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">parentIndex</span>(<span class="params">ofChildAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index <span class="operator">-</span> <span class="number">1</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从堆中移除元素"><a href="#从堆中移除元素" class="headerlink" title="从堆中移除元素"></a>从堆中移除元素</h2><p>最基本的元素节点移除操作是移除根节点，例如下图所示的移除最大堆中的根节点10：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/remove-max-heap.png"></p>
<p>此时，移除操作将移除位于根节点的集合最大值。首先要使用堆中最末尾的元素和根节点进行交换，一旦交换了元素，就可以删除位于叶子节点上的需要删除的元素了。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/delete-leaf-node.png"></p>
<p>但是，删除后的堆还是最大堆结构么？需要注意的是，最大堆的原则或者规则是每一个子节点的值都小于或等于父节点的值，一旦不符合这个规则，则需要进行节点的<strong>sift down</strong>调整。（最大堆调整算法称为<strong>sift down</strong>，最小堆调整算法称为** sift up**）</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down.png"></p>
<p>针对上图所示，<strong>sift down</strong>调整的方法是，获取根节点元素3，判断和其左子节点和右子节点的大小，如果左子节点的值大于当前节点，则进行节点的交换，如果左子节点和右子节点均大于该值，则使用子节点中大的那个值和当前节点进行交换。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down-2.png"></p>
<p>继续使用<strong>sift down</strong>调整法，调整节点，直到所有的节点满足最大堆的规则。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down-done.png"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    elements.swapAt(<span class="number">0</span>, count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        siftSown(from: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查堆是否为空，如果为空，则返回<em>nil</em>；</li>
<li>交换根节点和堆中最后的元素位置；</li>
<li>移除集合中最后一个元素并返回该元素（最后一个元素不是最大值就是最小值）；</li>
<li>移除后，堆可能不符合最大堆或最小堆的原则，需要继续采用siftDown或者siftUp方法进行调整，直到符合堆的规则。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftSown</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parent <span class="operator">=</span> index</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> left <span class="operator">=</span> leftChildIndex(ofParentAt: parent)</span><br><span class="line">        <span class="keyword">let</span> right <span class="operator">=</span> rightChildIndex(ofParentAt: parent)</span><br><span class="line">        <span class="keyword">var</span> candidate <span class="operator">=</span> parent</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="operator">&lt;</span> count <span class="operator">&amp;&amp;</span> sort(elements[left], elements[candidate]) &#123;</span><br><span class="line">            candidate <span class="operator">=</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right <span class="operator">&lt;</span> count <span class="operator">&amp;&amp;</span> sort(elements[right], elements[candidate]) &#123;</span><br><span class="line">            candidate <span class="operator">=</span> right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> candidate <span class="operator">==</span> parent &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements.swapAt(parent, candidate)</span><br><span class="line">        parent <span class="operator">=</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**siftDown(from:)**接受任意的索引，并将其视为根节点，该方法的工作原理是：</p>
<ol>
<li>临时保存索引到变量<em>parent</em>；</li>
<li>一直进行sifting操作，直到return（while true）；</li>
<li>获取<em>parent</em>索引所在节点的左节点和右节点对应的索引；</li>
<li>使用临时变量<em>candidate</em>追踪和父节点进行交换的节点索引；</li>
<li>如果是左节点，并且左节点相比父节点有更高的优先级，则<em>candidate</em>为左节点；</li>
<li>如果是右节点，并且右节点相比父节点有更高的优先级，则<em>candidate</em>为右节点；</li>
<li>如果<em>candidate</em>依然是<em>parent</em>，说明已经调整到末尾，再无sifting的必要了；</li>
<li>一轮sifting结束时，重新设定parent为候选的<em>candidate</em>，进行下一轮的sifting。</li>
</ol>
<h2 id="向堆中插入元素"><a href="#向堆中插入元素" class="headerlink" title="向堆中插入元素"></a>向堆中插入元素</h2><p>假设需要向如下的堆中插入元素7：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/insert-origin.png"></p>
<p>首先将待插入的元素添加到堆的末端：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/insert-end.png"></p>
<p>之后，检查最大堆的堆属性。和<em>siftdown</em>不同的是，此时使用<em>siftup</em>方法，工作原理类似于<em>siftdown</em>，通过比较当前节点和其父节点进行节点的交换。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/siftup.png"></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/siftup-done.png"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">        siftUp(from: elements.count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftUp</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> child <span class="operator">=</span> index</span><br><span class="line">        <span class="keyword">var</span> parent <span class="operator">=</span> parentIndex(ofChildAt: child)</span><br><span class="line">        <span class="keyword">while</span> child <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> sort(elements[child], elements[parent]) &#123;</span><br><span class="line">            elements.swapAt(child, parent)</span><br><span class="line">            child <span class="operator">=</span> parent</span><br><span class="line">            parent <span class="operator">=</span> parentIndex(ofChildAt: child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入算法相较于移除算法，更为直接：</p>
<ul>
<li>首先直接向数组中追加待插入的元素，之后进行 <strong>sift up</strong> 调整；</li>
<li><em>siftUp</em>比较当前节点和其父节点，并进行条件进行交换，直到该节点有一个比其父节点更高的优先级为止。</li>
</ul>
<p>在从堆中移除元素的时候，删除算法只是移除了堆的根节点，但是非根节点的元素移除可能更加的符合实际的场景。</p>
<h2 id="从任意索引中删除"><a href="#从任意索引中删除" class="headerlink" title="从任意索引中删除"></a>从任意索引中删除</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> index <span class="operator">&lt;</span> elements.count <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index <span class="operator">==</span> elements.count <span class="operator">-</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elements.swapAt(index, elements.count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123;</span><br><span class="line">                siftSown(from: index)</span><br><span class="line">                siftUp(from: index)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查待删除的索引是否在集合的边界之内，如果不在，返回<em>nil</em>；</li>
<li>如果删除的是堆中最末尾的元素，则直接进行删除，类似<em>remove</em>；</li>
<li>如果是非末尾的元素，首先交换待删除索引和末尾索引；<ul>
<li>之后删除末尾的元素，并返回该元素</li>
<li>最后，调用<em>siftDown</em>和<em>siftUp</em>进行堆节点调整</li>
</ul>
</li>
</ul>
<p>但是为什么要同时调用<em>siftDown</em>和<em>siftUp</em>呢？</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-both.png"></p>
<p>例如上图所示的堆中，想要删除元素5，首先交换5和最末尾的元素8，之后删除元素5。此时需要使用<em>sift up</em>对最大堆属性进行调整。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-swap.png"></p>
<p>例如上图，想要删除元素7，需要和末尾元素1进行交换后删除，删除后，需要使用<em>sift down</em>进行调整。</p>
<h2 id="在堆中搜索元素"><a href="#在堆中搜索元素" class="headerlink" title="在堆中搜索元素"></a>在堆中搜索元素</h2><p>在删除元素之前，首先要通过索引查找对应的元素，此时需要进行堆元素的搜索。不过，堆本身并没有设计快速的搜索，对于一颗二叉搜索树来说，搜索元素有O(log n)的时间复杂度，但是对于使用数组构建的堆，数组中的元素进行排序确实不同于二叉搜索树的，此时并不能使用二分查找。</p>
<blockquote>
<p>在堆中搜索元素最差的情况下有O(n)的时间复杂度，因此在搜索的时候，可能要检查数组中的每一个元素。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">index</span>(<span class="params">of</span> <span class="params">element</span>: <span class="type">Element</span>, <span class="params">startingAt</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> i <span class="operator">&gt;=</span> count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sort(element, elements[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> element <span class="operator">==</span> elements[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> j <span class="operator">=</span> index(of: element, startingAt: leftChildIndex(ofParentAt: i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> j <span class="operator">=</span> index(of: element, startingAt: rightChildIndex(ofParentAt: i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果索引i大于或者等于堆元素个数，则搜索失败，返回<em>nil</em>；</li>
<li>判断当前元素是否比索引i所对应的元素有更高的优先级，如果是，则所搜索的元素不可能在堆的更低的索引；</li>
<li>如果所搜索的元素和索引i所对应的元素相等，则待删除元素所在的索引就是i；</li>
<li>递归的搜索左子树从索引i开始的元素；</li>
<li>递归的搜索右子树从索引i开始的元素；</li>
<li>如果上述过程全部搜索失败，则整个搜索失败。</li>
</ul>
<h2 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h2><p>至此，已经有足够的工具针对堆进行各类操作了，但是还有一个问题就是，如果使用已存在的数组构建一个堆？在开始定义堆数据结构的时候，我们使用了一个非常简单的构造器，对其进行改造如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>, <span class="params">elements</span>: [<span class="type">Element</span>] <span class="operator">=</span> []) &#123;</span><br><span class="line">    <span class="keyword">self</span>.sort <span class="operator">=</span> sort</span><br><span class="line">    <span class="keyword">self</span>.elements <span class="operator">=</span> elements</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>elements.isEmpty &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: elements.count <span class="operator">/</span> <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span>, through: <span class="number">0</span>, by: <span class="operator">-</span><span class="number">1</span>) &#123;</span><br><span class="line">            siftSown(from: i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器现在能够接收一个额外的参数，如果传入一个非空的数组，将会使用该数组构建堆，为了使得堆满足堆属性，从第一个非叶节点开始向后循环数组，然后筛选所有父节点。您只遍历了一半的元素，因为筛选叶节点没有点，只有父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/build-heap-with-array.png"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;building a heap with array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>heap.isEmpty  &#123;</span><br><span class="line">        <span class="built_in">print</span>(heap.remove()<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of building a heap with array---</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>对于堆的各类操作，有着不同的时间复杂度，具体如下：<br>  <img src="/images/Data-Structures-&-Algorithms-in-Swift/15/heap-time.png"></li>
<li>堆数据结构非常适合维护优先级最高或最低优先级的元素。</li>
<li>每次从堆中插入或删除项时，都必须检查它是否符合优先级的规则。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.099Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.099Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item">27 分钟读完 (大约4117个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-06-24-iOS-runtime-message-forward/">Runtime剖析02 --- 消息与消息发送机制</a></h1><div class="content"><p>在Objective-C中，消息发送指Runtime会根据<strong>SEL</strong>查找对应的<strong>IMP</strong>，当查找到，则调用函数指针进行方法调用，若查找不到，则进入动态消息解析和消息转发流程，如果动态解析和消息转发失败，则程序会崩溃。</p>
<h2 id="消息相关数据结构"><a href="#消息相关数据结构" class="headerlink" title="消息相关数据结构"></a>消息相关数据结构</h2><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><strong>SEL</strong>称之为消息选择器，相当于一个<strong>key</strong>，在类的消息列表中，可以根据这个<strong>key</strong>查找对应的消息实现<strong>IMP</strong>。</p>
<p>在Runtime中，SEL的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method selector.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<strong>SEL</strong>其实是一个<strong>objc_selector *<strong>结构体指针，但是在苹果开源的runtime中并没有其定义，目前</strong>SEL</strong>仅是一个字符串。</p>
<p>虽然<strong>SEL</strong>可以作为key对消息进行查找，但是当不同的类有着相同的<strong>SEL</strong>的时候，再进行消息实现查找时，可能无法确定消息实现真实的归属，因此在进行消息实现查找时，会结合消息发送的目标Class，才能找到具体的最终的<strong>IMP</strong>。</p>
<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>开篇已说，runtime会根据<strong>SEL</strong>查找对应的实现<strong>IMP</strong>。具体地说，runtime会在Class的方法列表中查找方法的实现，在方法列表中方法的实现是以<strong>method_t</strong>结构体的形式存储的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></span><br><span class="line">        public <span class="built_in">std</span>::binary_function&lt;<span class="type">const</span> <span class="type">method_t</span>&amp;,</span><br><span class="line">                                    <span class="type">const</span> <span class="type">method_t</span>&amp;, <span class="type">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">method_t</span>&amp; lhs,</span></span><br><span class="line"><span class="params">                         <span class="type">const</span> <span class="type">method_t</span>&amp; rhs)</span></span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>method_t</strong>结构体重包含了<strong>SEL</strong>的名称，以及指向对应试下的<strong>imp</strong>指针，另外<strong>types</strong>指的是方法的返回值和参数类型，其格式一般为<strong>v24@0:8@16</strong>，此种格式被称为<strong>Type Encodings</strong>，对应的解释说明详见<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><strong>IMP</strong>本质上是一个函数指针，用于指向方法的具体实现，在runtime中，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> )</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IMP</strong>是由编译器生成的，如果知道了<strong>IMP</strong>的地址，就可以绕过runtime的消息发送过程，直接调用函数实现。</p>
</blockquote>
<p>在消息发送过程中，runtime会根据<strong>id</strong>和<strong>SEL</strong>来唯一确定<strong>IMP</strong>并进行调用。</p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>在Objective-C中，函数的调用被称为<strong>消息发送</strong>。在进行代码编译时，代码会被修改为<strong>objc_msgSend</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>**objc_msgSend()**形式即为Objective-C中的消息发送的入口，该函数的具体实现是由汇编语言实现的，其目的一是为了提高执行效率，二是因为该函数的返回值类型是可变的，汇编正好具有返回值类型多样性的特性。</p>
<p>除了**objc_msgSend()**之外，编译器还会根据具体的情况，将消息转发改写为如下形式之一：</p>
<ul>
<li>objc_msgSend</li>
<li>objc_msgSend_stret</li>
<li>objc_msgSendSuper</li>
<li>objc_msgSendSuper_stret</li>
</ul>
<p>当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSendSuper</span><span class="params">(<span class="keyword">struct</span> objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在<strong>objc_msgSendSuper</strong>函数的参数中，第一个参数不再是当前类的指针，而变为<strong>objc_super *<strong>结构体指针，</strong>objc_super</strong>结构体包含两个数据，<strong>receiver</strong>指调用super方法的对象，即消息接收者，而<strong>super_class</strong>表示当前子类的父类对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>带有**_stret**的函数，表示方法返回的是结构体类型。</p>
</blockquote>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">ENTRY</span> _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">	<span class="keyword">cmp</span>	<span class="built_in">p0</span>, <span class="number">#0</span>			<span class="comment">// nil check and tagged pointer check</span></span><br><span class="line"><span class="comment">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class="line">	b.le	LNilOrTagged		<span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">	<span class="keyword">ldr</span>	<span class="built_in">p13</span>, [x0]		<span class="comment">// p13 = isa</span></span><br><span class="line">	GetClassFromIsa_p16 <span class="built_in">p13</span>		<span class="comment">// p16 = class</span></span><br><span class="line"><span class="symbol">LGetIsaDone:</span></span><br><span class="line">	<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend</span><br><span class="line"></span><br><span class="line"><span class="comment">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class="line"><span class="symbol">LNilOrTagged:</span></span><br><span class="line">	b.eq	LReturnZero		<span class="comment">// nil check</span></span><br><span class="line"><span class="comment">// 省略其他</span></span><br></pre></td></tr></table></figure>

<ol>
<li>进入<strong>objc_msgSend</strong>后，首先通过<strong>cmp	p0, #0</strong>检查函数参数<strong>receiver</strong>是否为<strong>nil</strong>，如果为<strong>nil</strong>，则进入<strong>LReturnZero</strong>，返回0；</li>
<li>如果不为<strong>nil</strong>，则将<strong>receiver</strong>的<strong>isa</strong>存储在<strong>p13</strong>寄存器；</li>
<li>在寄存器<strong>p13</strong>中，取出<strong>isa</strong>对应的<strong>Class</strong>，存储到<strong>p16</strong>寄存器；</li>
<li><strong>Class</strong>获取完成后，调用<strong>CacheLookup NORMAL</strong>函数，查找<strong>Class</strong>的方法缓存列表，如果命中，则调用**_objc_msgSend<strong>，如果未命中，则调用</strong>objc_msgSend_uncached**。</li>
</ol>
<p><strong>objc_msgSend_uncached</strong>也是汇编语言实现，作用是为方法缓存列表中未查找到方法缓存时，在<strong>Class</strong>的方法列表中进行查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">	<span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line">	<span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line">	</span><br><span class="line">	MethodTableLookup</span><br><span class="line">	TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p><strong>objc_msgSend_uncached</strong>内部调用了<strong>MethodTableLookup</strong>，<strong>MethodTableLookup</strong>是一个汇编实现的宏定义，其内部调用了C语言函数<strong>lookUpImpOrForward</strong>。</p>
<h2 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> IMP <span class="title function_">lookUpImpOrForward</span><span class="params">(id obj, SEL, Class cls, <span class="type">int</span> behavior)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>lookUpImpOrForward</strong>函数的目的是根据<strong>Class</strong>和<strong>SEL</strong>，在当前类或者当前类的父类中找到方法对应的<strong>IMP</strong>，同时，缓存找到的对应<strong>IMP</strong>到当前类的方法缓存列表中。如果没有找到对应的<strong>IMP</strong>，则会进入到消息转发流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">IMP <span class="title function_">lookUpImpOrForward</span><span class="params">(id inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Class curClass;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="comment">// 首先在根据class和sel在方法缓存中查找imp</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="comment">// 如果查找到，则直接进入到done_nolock</span></span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t want people to be able to craft a binary blob that looks like</span></span><br><span class="line">    <span class="comment">// a class but really isn&#x27;t one and do a CFI attack.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// To make these harder we want to make sure this is a class that was</span></span><br><span class="line">    <span class="comment">// either built into the binary or legitimately registered through</span></span><br><span class="line">    <span class="comment">// objc_duplicateClass, objc_initializeClassPair or objc_allocateClassPair.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this check is quite costly during process startup.</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果class还未realize，先进行realize</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果class还未initialize，先进行initialize</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If sel == initialize, class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won&#x27;t happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code used to lookpu the class&#x27;s cache again right after</span></span><br><span class="line">    <span class="comment">// we take the lock but for the vast majority of the cases</span></span><br><span class="line">    <span class="comment">// evidence shows this is a miss most of the time, hence a time loss.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The only codepath calling into this without having performed some</span></span><br><span class="line">    <span class="comment">// kind of cache lookup is class_getInstanceMethod().</span></span><br><span class="line">    <span class="comment">// 在当前class中没有找到imp，则依次向上查找super class的方法列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        <span class="comment">// 首先获取当前类的方法体</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过继承链，向上查找IMP</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</span><br><span class="line">            <span class="comment">// No implementation found, and method resolver didn&#x27;t help.</span></span><br><span class="line">            <span class="comment">// Use forwarding.</span></span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        <span class="comment">// 父类缓存</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">            <span class="comment">// Stop searching, but don&#x27;t cache yet; call method</span></span><br><span class="line">            <span class="comment">// resolver for this class first.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到父类的IMP，并缓存</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="comment">// 没有查找到IMP，进入动态方法解析流程</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line"> 	<span class="comment">// 记录并缓存IMP</span></span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line"> 	<span class="comment">// 未找到对应的IMP，返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lookUpImpOrForward</strong>工作流程：</p>
<ol>
<li>尝试在当前receiver对应class的cache中查找imp，如果查找到，则调用；</li>
<li>如果在cache中为查找到imp，则在class的方法列表中查找imp；</li>
<li>尝试在class的所有super class中查找imp。（首先在super class的cache中查找，如果为找到，则在super class的方法列表中查找）；</li>
<li>如果还未找到imp，则尝试进行动态方法解析SEL；</li>
<li>动态解析失败，则尝试进入消息转发流程，让其他class处理SEL。</li>
</ol>
<p>在查找class的方法列表中是否有SEL对应的IMP时，调用的是**getMethodNoSuper_nolock()**：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">method_t</span> *</span><br><span class="line"><span class="title function_">getMethodNoSuper_nolock</span><span class="params">(Class cls, SEL sel)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> methods = cls-&gt;data()-&gt;methods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = methods.beginLists(),</span><br><span class="line">              end = methods.endLists();</span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/46904873&gt; getMethodNoSuper_nolock is the hottest</span></span><br><span class="line">        <span class="comment">// caller of search_method_list, inlining it turns</span></span><br><span class="line">        <span class="comment">// getMethodNoSuper_nolock into a frame-less function and eliminates</span></span><br><span class="line">        <span class="comment">// any store from this codepath.</span></span><br><span class="line">        <span class="type">method_t</span> *m = search_method_list_inline(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取出class的方法列表<strong>method_array_t</strong>，然后调用<strong>search_method_list_inline()<strong>，根据SEL查找对应的</strong>method_t</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="type">static</span> <span class="type">method_t</span> *</span><br><span class="line"><span class="title function_">search_method_list_inline</span><span class="params">(<span class="type">const</span> <span class="type">method_list_t</span> *mlist, SEL sel)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="type">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(<span class="type">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fastpath(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法查找的时候，会分为两种方式：</p>
<ol>
<li>如果方法列表是有序的，则使用<strong>findMethodInSortedMethodList</strong>进行前向查找，使用<strong>二分查找</strong>方式</li>
<li>否则直接进行遍历</li>
</ol>
<h2 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h2><p>上文已经提到，当消息发送给当前类的Super Class的时候，编译器会将消息发送改写为<strong>objc_msgSendSuper</strong>的格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line"><span class="title function_">objc_msgSendSuper</span><span class="params">(<span class="keyword">struct</span> objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span><br><span class="line">    <span class="title function_">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，当使用<strong>super</strong>关键字调用方法时，编译器则会将代码编译为<strong>objc_msgSendSuper</strong>的格式。</p>
<p><strong>super关键字本质上类似一个“语法糖”，在代码编译时，编译器会将其替换为objc_super指针类型，来传入到objc_msgSendSuper方法中，而并不是父类的意思。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    <span class="comment">// 消息的接收者，一般为当前类的实例对象。</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line">    <span class="comment">// 告知查找方法IMP的去向，当前类实例的父类对象。</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>当使用super关键字调用方法时，runtime会到当前类的父类中查找对应IMP，然后将消息发送到当前类的实例上。</strong></p>
<p>这也解释了为什么**[self class] 和 [super class]**会输出同样结果的原因。</p>
<p>同样<strong>objc_msgSendSuper</strong>也是由汇编语言实现的，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line"></span><br><span class="line">ldr	r9, [r0, #CLASS]	<span class="comment">// r9 = struct super-&gt;class</span></span><br><span class="line">CacheLookup NORMAL, _objc_msgSendSuper</span><br><span class="line"><span class="comment">// cache hit, IMP in r12, eq already set for nonstret forwarding</span></span><br><span class="line">ldr	r0, [r0, #RECEIVER]	<span class="comment">// load real receiver</span></span><br><span class="line">bx	r12			<span class="comment">// call imp</span></span><br><span class="line"></span><br><span class="line">CacheLookup2 NORMAL, _objc_msgSendSuper</span><br><span class="line"><span class="comment">// cache miss</span></span><br><span class="line">ldr	r9, [r0, #CLASS]	<span class="comment">// r9 = struct super-&gt;class</span></span><br><span class="line">ldr	r0, [r0, #RECEIVER]	<span class="comment">// load real receiver</span></span><br><span class="line">b	__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure>

<p>寄存器<strong>r9</strong>中保存的是当前实例的父类对象，获取到对应的父类后，调用<strong>CacheLookup</strong>在方法缓存中查找对应imp，缓存命中后，取出<strong>receiver</strong>，调用imp。如果未在缓存中命中IMP，则调用**__objc_msgSend_uncached<strong>，传入</strong>super class**进行方法查找。</p>
<h2 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h2><p>如果在类的继承链中没有找到对应的IMP，runtime则会进入消息的动态解析流程，即进入到<strong>lookUpImpOrForward</strong>中的<strong>resolveMethod_locked</strong>函数调用中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">       behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">       <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态解析，就是将方法实现在运行时动态的添加到当前类中。</strong>之后runtime会重新尝试消息查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> NEVER_INLINE IMP</span><br><span class="line"><span class="title function_">resolveMethod_locked</span><span class="params">(id inst, SEL sel, Class cls, <span class="type">int</span> behavior)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chances are that calling the resolver have populated the cache</span></span><br><span class="line">    <span class="comment">// so attempt using it</span></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>resolveMethod_locked</strong>中，runtime会根据调用的是实例方法还是类方法，进入到不同的处理逻辑中。</p>
<ul>
<li>动态解析实例方法： **resolveInstanceMethod()**用来动态解析实例方法，在运行时可以动态的将对应的方法实现添加到类实例所对应的类的消息列表中。</li>
<li>动态解析类方法： **resolveClassMethod()**用来动态解析类方法，同样可以在运行时动态的将对应的类方法添加到类的消息列表中。</li>
</ul>
<p><strong>举例：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(testInstanceMethod)), <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testInstanceMethod&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(testClassMehotd)), <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)testClassMehotd&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<strong>test()<strong>方法仅仅声明，没有实现。在运行时，runtime则会进入到消息的动态解析。需要注意的是，动态解析类方法时，方法</strong>class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)<strong>中的第一个参数，需要使用</strong>object_getClass()<strong>进行获取后传参。因为在动态解析类方法时，需要将方法的实现添加到当前类的isa指向类中，而类的指向类为</strong>元类</strong>。</p>
<ul>
<li>当<strong>self</strong>是实例对象时，**[self class]** 和 **object_getClass(self)**等价，因为前者会直接调用后者，都是返回对象实例所对应的类。</li>
<li>当<strong>self</strong>是类对象时，**[self class]<strong>返回类对象本身，而</strong>object_getClass(self)**返回类对应的元类。</li>
</ul>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当动态解析依然失败，runtime则进入到消息转发流程。<strong>消息转发，是将当前消息转发到其他对象进行处理。</strong> 在NSObject中，针对消息转发提供了专门的API来处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发类方法，id返回的是类对象</span></span><br><span class="line">+ (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel;</span><br><span class="line"><span class="comment">// 转发实例方法，id返回的是实例对象</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure>

<p><strong>消息转发示例</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">        <span class="keyword">return</span> testForward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>testForward</strong>为实现了<strong>test</strong>方法的实例对象。如果没有实现<strong>forwardingTargetForSelector</strong>，或者该方法返回<strong>nil</strong>或者<strong>self</strong>，则runtime会进入到另一个转发流程。此时runtime会依次调用**- (NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector<strong>，获取方法签名，然后根据方法签名，包装成了一个</strong>NSInvocation*<em>对象，并调用</em></em>- (void)forwardInvocation:(NSInvocation *)anInvocation**，此时无论转发的消息是否实现，系统都会默认消息已经得到了解析，从而避免崩溃。</p>
<p><img src="/images/runtime/2/message-forward.jpg"></p>
<p>消息转发实际上是将消息转发给另一个对象进行处理，而消息动态解析是在当前类的范围内进行处理。</p>
<h2 id="消息转发与多继承"><a href="#消息转发与多继承" class="headerlink" title="消息转发与多继承"></a>消息转发与多继承</h2><p>通过消息转发流程，可以模拟实现Objective-C语言的多继承机制，具体可查看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Runtime官方文档</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Objective-C语言中，方法调用实现的底层机制为<strong>消息发送机制</strong>。在开发中，类的实例对象不能调用类方法，原因是类的实例对象在查找消息IMP的流程仅仅是查找类的方法列表，而对于类方法而言，其实现存放在元类的方法列表中，因此实例对象通过objc_msgSend方法是找不到对应类消息的IMP的。</p>
<p>类大多数情况下是不能调用实例方法的，除非实例方法定义在根类中，即NSObject中。因为当调用类方法是，会在元类的继承链的方法列表中查找对应的IMP，而跟元类对应的父类是NSObject，因此在NSObject中定义的实例方法，其实是可以通过类方法形式来调用的。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/7/cover.jpeg" alt="\#7\ Stack &amp; Stack Simple Challenges"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1820个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-08-Data-Structures-&amp;-Algorithms-in-Swift-07/">\#7\ Stack &amp; Stack Simple Challenges</a></h1><div class="content"><p><strong>栈（Stack）</strong>是一个常见的基础类型数据结构，在生活中经常也能看到栈的身影，例如一本书、一叠现金等等。栈的数据结构在概念上和对象的物理存储栈相同。再向栈添加元素时，需要将其放在栈顶，通俗称压栈，而从站内删除元素时，始终删除的是栈顶的元素，又称为出栈，而这种进栈和出栈的特性使得栈属于一种受限的线性表结构。栈的操作特性通常被称为**后进先出(LIFO-last in first out)<strong>的方式，另一种数据结构队列的操作特性与栈有着不同，通常称为</strong>先进先出(FIFO-first in first out)**。</p>
<h2 id="栈的一般操作"><a href="#栈的一般操作" class="headerlink" title="栈的一般操作"></a>栈的一般操作</h2><p>栈是一种很有用，但是相对简单的数据结构。构建栈类型数据结构的主要目标是数据的访问权限和方式问题。相比于链表而言，栈并没有链表那个复杂和琐碎。</p>
<p>对于栈来说，主要的操作有两个，即上述所说的<strong>压栈</strong>和<strong>出栈</strong>的操作：</p>
<ul>
<li><strong>push：</strong>添加一个元素到栈顶；</li>
<li><strong>pop：</strong>从栈顶删除一个元素</li>
</ul>
<p>也就是说，对于栈而言，只能从栈的一边添加或者移除元素，也就是上述所说的**后进先出(LIFO-last in first out)**的方式。在计算机编程中，栈的身影无处不在，例如下面几个场景中，都是栈的理念和其应用的结果：</p>
<ul>
<li>在iOS中,导航控制器的作用是将视图控制器的视图弹出或者弹入，并且最新弹出的总是最后弹入的视图控制器视图；</li>
<li>内存分配在体系结构级别使用堆栈。局部变量的内存也使用堆栈进行管理；</li>
<li>Search和conquer算法，例如从迷宫中寻找路径，均使用堆栈来方便回溯。</li>
</ul>
<h2 id="栈数据结构实现"><a href="#栈数据结构实现" class="headerlink" title="栈数据结构实现"></a>栈数据结构实现</h2><p>首先定义栈的基础结构，对于栈而言，其核心就是一个列表，只是再具体的操作时有LIFO的限制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">CustomStringConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> topDivider <span class="operator">=</span> <span class="string">&quot;---- top ----<span class="subst">\n</span>&quot;</span></span><br><span class="line">        <span class="keyword">let</span> bottomDivider <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span> -----------&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> stackElements <span class="operator">=</span> storage</span><br><span class="line">            .map &#123; <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span> &#125;</span><br><span class="line">            .reversed()</span><br><span class="line">            .joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> topDivider <span class="operator">+</span> stackElements <span class="operator">+</span> bottomDivider</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在栈的数据结构中使用列表的方式进行数据存储，是因为对于列表来说，在其一端进行操作 — <strong>append</strong> 和<strong>popLast</strong>，都属于恒定时间的复杂度O(1)。也更是促进了栈的进栈和出栈特性的性能表现。</p>
<h2 id="push-amp-pop-操作"><a href="#push-amp-pop-操作" class="headerlink" title="push &amp; pop 操作"></a>push &amp; pop 操作</h2><p>在栈的数据结构定义中，增加基本的压栈和出栈操作，压栈操作直接使用列表的<strong>append</strong>，出栈使用<strong>popLast</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">    storage.append(element)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.popLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个基本操作来说，实现也非常直截了当。接下来对其进行实际测试，在主Playground中，进行测试代码编写。</p>
<blockquote>
<p>在进行测试前，可以将<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/03/Data-Structures-&-Algorithms-in-Swift-04.html">\#4\ Linked List 的Swift实现
</a>中的<strong>Helper.swift</strong>拷贝到当前工程中。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;using a stack&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    stack.push(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">4</span> <span class="operator">==</span> poppedElement)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">---Example of using a stack---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展性操作"><a href="#扩展性操作" class="headerlink" title="扩展性操作"></a>扩展性操作</h2><p>对于栈来说，除了常用的push和pop操作之外，还有一些额外的操作，能够提高对栈的使用等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> storage.last</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// isEmpty</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> peek() <span class="operator">==</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>peek()：</strong>获取栈顶元素</li>
<li><strong>isEmpty：</strong>判断栈是否为空</li>
</ul>
<h2 id="Less-is-more"><a href="#Less-is-more" class="headerlink" title="Less is more"></a>Less is more</h2><p>在链表的实现中，我们使用了Swift标准库中的Collection协议，那么在栈的实现中是否也能够使用Collection协议呢？栈的目的是有限制的访问数据，通过迭代或者下标的方式即可实现该目标，但是对于Collection协议来说，并不止于此，因此在栈上使用Collection协议和栈的最初目标是相互制约的。在这种情况下，少即是多！</p>
<p>您可能希望采用现有数组并将其转换为栈，以便保证访问顺序，也可以循环遍历数组元素以及添加元素。对于栈来说，为了能够对栈的操作有一个统一的初始化存储方式，可以定义其初始化方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">elements</span>: [<span class="type">Element</span>]) &#123;</span><br><span class="line">    storage <span class="operator">=</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from a array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>(array)</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from a array---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述实现中，将一个数组转化为了栈，并且栈中元素的数据类型是String，也就意味着栈中可以放置多种类型的数据元素。</p>
<p>既然可以使用数组直接转化为栈，那么是否可以直接使用数组的方式初始化栈呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span>: <span class="title class_">ExpressibleByArrayLiteral</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">arrayLiteral</span> <span class="params">elements</span>: <span class="type">Element</span>...) &#123;</span><br><span class="line">        storage <span class="operator">=</span> elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;initializing a stack from an array literal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> stack: <span class="type">Stack</span> <span class="operator">=</span> [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>]</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> poppedElement <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Popped: <span class="subst">\(poppedElement)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of initializing a stack from an array literal---</span></span><br><span class="line"><span class="comment">---- top ----</span></span><br><span class="line"><span class="comment">4.0</span></span><br><span class="line"><span class="comment">3.0</span></span><br><span class="line"><span class="comment">2.0</span></span><br><span class="line"><span class="comment">1.0</span></span><br><span class="line"><span class="comment"> -----------</span></span><br><span class="line"><span class="comment">Popped: 4.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在搜索树和图的问题求解中，栈至关重要。例如在查找迷宫的路径方法中，每次叨叨左、右、前或后的决策点时，都可以将所有可能的决策点压入栈中，当栈顶的路径是一个死胡同时，只需要从栈中弹出并继续下一个判断，直到走出迷宫即可。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>栈的数据结构虽然非常简单，但栈是解决很多问题的关键性数据结构；</li>
<li>对于栈爱说，只有两个基本操作，分别是压栈<strong>push</strong>和出栈<strong>pop</strong>。</li>
</ul>
<h2 id="栈的挑战"><a href="#栈的挑战" class="headerlink" title="栈的挑战"></a>栈的挑战</h2><h2 id="Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。"><a href="#Challenge-1：在不适用递归的情况下，反向打印一个单向链表的节点。" class="headerlink" title="Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。"></a>Challenge 1：在不适用递归的情况下，反向打印一个单向链表的节点。</h2><blockquote>
<p>在<a target="_blank" rel="noopener" href="https://robinchao.github.io/2019/12/05/Data-Structures-&-Algorithms-in-Swift-06.html">\#6\ Linked List 挑战</a>中我们使用了递归的方式，反向打印了一个链表的节点。在这里将使用栈的结构进行，避免递归调用。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverseNoRecursion</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> current &#123;</span><br><span class="line">        stack.push(node.value)</span><br><span class="line">        current <span class="operator">=</span> node.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> value <span class="operator">=</span> stack.pop() &#123;</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Print Linkedlist reverse without recursion&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverseNoRecursion(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Print Linkedlist reverse without recursion---</span></span><br><span class="line"><span class="comment">Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">Printing in reverse: </span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如："><a href="#Challenge-2：检查括号是否平衡。给定一个字符串，检查是否有-（-和-）-字符，如果字符串中的括号是平衡的，则返回-true。例如：" class="headerlink" title="Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 （ 和 ） 字符，如果字符串中的括号是平衡的，则返回 true。例如："></a>Challenge 2：检查括号是否平衡。给定一个字符串，检查是否有 <code>（</code> 和 <code>）</code> 字符，如果字符串中的括号是平衡的，则返回 <code>true</code>。例如：</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1 h((e))llo(world)() // balanced parentheses</span><br><span class="line"></span><br><span class="line">// 2 (hello world // unbalanced parentheses</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">checkParentheses</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack <span class="operator">=</span> <span class="type">Stack</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> character <span class="keyword">in</span> string &#123;</span><br><span class="line">        <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;(&quot;</span> &#123;</span><br><span class="line">            stack.push(character)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> character <span class="operator">==</span> <span class="string">&quot;)&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> stack.isEmpty &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;check parentheses&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string <span class="operator">=</span> <span class="string">&quot;h((e))llo(world)())&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> checkParentheses(string)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of check parentheses---</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-03-14-cart/"><img class="fill" src="/images/cart/cover.jpg" alt="什么是决策树"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">17 分钟读完 (大约2597个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-03-14-cart/">什么是决策树</a></h1><div class="content"><p>决策树(Decision Tree）是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。Entropy &#x3D; 系统的凌乱程度，使用算法ID3, C4.5和C5.0生成树算法使用熵。这一度量是基于信息学理论中熵的概念。<br>决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。<br>分类树（决策树）是一种十分常用的分类方法。他是一种监管学习，所谓监管学习就是给定一堆样本，每个样本都有一组属性和一个类别，这些类别是事先确定的，那么通过学习得到一个分类器，这个分类器能够对新出现的对象给出正确的分类。这样的机器学习就被称之为监督学习。</p>
<h2 id="什么是决策树？"><a href="#什么是决策树？" class="headerlink" title="什么是决策树？"></a>什么是决策树？</h2><p>有的人可能听过一个词：<strong>CART</strong>，这个代表的意思是<strong>Classification And Regression Tree</strong>。它是一个分类和回归的决策树。它被分为两类，一类是<strong>分类决策树</strong>(Classification Trees)，另一个类是<strong>回归决策树</strong>(Regression Trees)。也就是我们要用这个决策树解决两类问题，一个分类问题一个回归问题。</p>
<p><img src="/images/cart/cart.png"></p>
<p>对于分类决策树，一般来说用于一些分类离散的数据，比如说人的性别是男或者女，水果的种类有苹果梨子等等都是离散的。反之回归决策树，那么对应的场景就是连续的数据，比如人的年龄或者室外的温度。当我们进行分类问题时，分类的组之间是无序的。这里首先介绍下什么是有序，可以举个例子比如年龄，又年龄大或者年龄小。那么对于性别问题，男或女，它是没有顺序的。本文要讲的是分类问题在决策树上的应用。</p>
<p>来看个例子，在一个二维平面上有两个颜色分组的数据，我们要用决策树算法来构建分类器。这里的决策树算法要做的事情就是不断用水平和竖直的线不断对平面进行分隔，直到某一个区域类只有红类或者绿类。如图所示，我们画出几条线对平面进行分隔。</p>
<p><img src="/images/cart/cart-split.png"></p>
<p>这样图中的红组和蓝组的数据点就被这些数据分隔开来了，但这组数据是为了方便展示而特地画成这个样子的，实际情况并不一定会出现这种比较清晰的分割线。那我们先看看第一条分割线，将其分割成了上下两块区域，虽然两边都是既有红色又有蓝色，但我们可以说分类的结果还是比较纯的。用复杂点的数学语言来说就是，我们正在寻找一条分隔线，可以是水平的也可以是竖直的，我们想要做一个优化的问题，需要最小化分隔后的基尼不纯度。什么叫纯，指的是分隔后的一边如果只有红点或者绿点，那么可以说这个分隔的结果是非常纯的，那么如果两边既有红也有蓝，那么就是不纯的。我们希望当我们添加一条分割线后，想要将两边的纯度和最小化。那么每一条的分割线的寻找实际上就是在做一个优化的问题，那么优化的对象可以是基尼不纯度，也可以是信息学中的熵。这里不做过多解释，只是展示下决策树是如果运作的。</p>
<p>画出第一条分隔线后如图可以得到两组分类结果，一个是x2小于或者不小于60，再然后我们画出第二条分割线，看出x1&lt;50是绿组，否则就是红组，接着再画出第三条分割线，x1&lt;70都是红组，再对x1&gt;70分隔，得出红组和绿组数据。</p>
<p><img src="/images/cart/cart-tree.png"></p>
<p>如图其实就是上述所说的工作流程，我们得到的每一片叶子都是比较纯的结果，如果在实际实际生活中，数据可能非常复杂，那么我们的树可能就非常非常大，枝节非常非常多。那么有的时候，有的枝节不一定非要到最后知道yes or no，也许可能在前面某个枝节就停止了。比如对于x2&lt;20这里不再继续分割，假设有个新的数据点落在了这个区域，它落在绿色的区域的概率比落在红色的概率要大，那么我们就可以把这一部分都划分到绿色组中，也就是说可以剪掉多余的枝节，也许它对于训练集是有意义的，但对于更多其他的数据来说，它可能就是个噪音，我们不需要知道这么详细的信息。那最终就没有这两片叶子，到前面一步就结束了。</p>
<p>决策树算法是个很经典的机器学习算法，很多年以前是比较流行的。但到了20世纪初已经逐渐被其他算法所取代。直到最近又发现这个算法中一些新的精妙的东西，比如说随机森林，就是以决策树为根本来展开的。还有提升梯度(Gradient Boosting)等等都是在决策树算法之上我们加上了一些新的元素。</p>
<p>代码实现<br>由于这次决策树算法，我们没有使用欧式距离，也就是说可以不用进行特征缩放。但最终画图像时之前模版中定义的步距可能就过大或者过小，所以这里就妥协一下保留特征缩放的代码。分类器改成决策树算法的DecisionTreeClassifier。这个方法的参数criterion指的就是标准，默认gini，即基尼指数或者说基尼不纯度。它和熵都是表示分类时划分质量的好坏。这里我们使用熵。其他的参数暂时用不到,random_state依然只是用来大家如果想得到相同的结果时就设置为相同的值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">classifier = DecisionTreeClassifier(criterion=<span class="string">&#x27;entropy&#x27;</span>,random_state=)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>

<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>在开始讲随机森林之前我们先讲一个更为广义的概念: Ensemble Learning，集成学习。它的意思是我们使用多个分类器对我们的结果进行预测，最后再对分类结果进行一个组合，以达到最终的结果。这个组合的方式有很多种，比如平均，加权平均或者投票等等。这个集成学习的作用就是，我们觉得任何一个单独的分类器去分类结果回感觉有误差，这时可以用成百上千个分类器都进行预测，然后再对结果进行一个组合，可以减少预测结果的浮动率。下面来看看随机森林算法的步骤。</p>
<p>首先，随机采用训练集合中的数据，相当于装袋的过程，构建自己新的训练集；然后用这些数据训练决策树分类器；再然后实际上就是重复第一第二步，但每一次得到的结果是不同的，因为在第一步中我们取得的数据都是随机的。对于一个新的数据点，我们用已经训练好的多个训练器分别对这个新数据的分类进行预测，最后进行一个投票，拥有最大投票数量的分类结果胜出就使用这个分类结果。</p>
<p><img src="/images/cart/random-forest.png"></p>
<p>前文讲述了如何构建一棵决策树，现在拥有成百上千棵决策树来帮助我们解决分类问题。这个分类算法还有不少数学上的一些细节问题，比如Boosting(提升)，还有当我们有高维度的情况时，我们每次选取数据时可能只选取部分维度，这样可以避免个别维度比其他维度大的多情况。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里依然开始先套用分类的模版，然后换成随机森林分类器，这里的参数n_estimators指的是决策树的数量,这里暂时设置成10 criterion依然设置为entropy。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">classifier = RandomForestClassifier(n_estimators=<span class="number">10</span>, criterion=<span class="string">&#x27;entropy&#x27;</span>, random_state=<span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>

<p>通过结果观察，这里使用随机森林分类器是会出现过拟合的情况。对比这几篇文章中的分类器，实际上最适合的是核svm和朴素贝叶斯，线性分类器准确度不够，随机森林分类器会出现过拟合，而这两者它们保证了拟合的准确率，并且也不会出现过拟合的问题。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-08-31-technical-debt/"><img class="fill" src="/images/technical-debt/cover.jpeg" alt="技术债务，到底应该怎么还？"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.097Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.098Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></span><span class="level-item">24 分钟读完 (大约3665个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-08-31-technical-debt/">技术债务，到底应该怎么还？</a></h1><div class="content"><p>几乎所有的技术团队，都会经历或多或少的技术债务，技术债务虽然是实现快速收益的一种捷径，但是为了修复哪些为了快速收益而不得不为之的技术问题，企业往往需要花费大量的金钱、人力等。那么如何有效地避免技术债务，使得开发人员更多的精力投入在有效的工作，从而产生额外价值，提高企业的产品竞争力呢？</p>
<p>技术债务的产生有着很多的原因，但是其中更多的是由于匆忙的工作使得原来耗时较长的工作，在短时间内完成，导致部分业务逻辑没有完整的设计等，使得产品在短时间内有效，但是长远来看，却是一颗不稳定的炸弹，一旦触发，对产品、对企业都有可能造成无法挽回的损失。总而言之，技术债务会带来很多麻烦，有些甚至是“致命”的。</p>
<blockquote>
<p>本文以发布至：<a target="_blank" rel="noopener" href="https://weibo.com/ttarticle/p/show?id=2309404395386419675203">技术专栏丨技术债务，到底应该怎么还？</a></p>
</blockquote>
<h2 id="什么是技术债务？"><a href="#什么是技术债务？" class="headerlink" title="什么是技术债务？"></a>什么是技术债务？</h2><p><img src="/images/technical-debt/what-is-technical-debt.png"></p>
<blockquote>
<p>技术负债（英语：Technical debt），又译技术债，也称为设计负债（design debt）、代码负债（code debt），是编程及软件工程中的一个比喻。指开发人员为了加速软件开发，在应该采用最佳方案时进行了妥协，改用了短期内能加速软件开发的方案，从而在未来给自己带来的额外开发负担。这种技术上的选择，就像一笔债务一样，虽然眼前看起来可以得到好处，但必须在未来偿还。软件工程师必须付出额外的时间和精力持续修复之前的妥协所造成的问题及副作用，或是进行重构，把架构改善为最佳实现方式。 </p>
<p>摘自 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA">维基百科</a></p>
</blockquote>
<p>很多人将技术债务类比于金融债务，但是和金融债务不同的是，技术债务可能不会承担利息。例如当需要快速验证产品的某个特点的时候，带有一定技术债务的产品可能是个好的选择，当验证之后，无需该特点的时候，可以直接移除等，此时可能不会承担债务利息。但是大多数情况下，此类情况较少，就算仅仅是为了验证产品，也不建议使用技术债务的方式去实施。类似这样方式的技术债务可称为有意的技术债务，另一种更加危险的技术债务称为无意的技术债务，无意的技术债务就像是前文说到的隐藏在代码中的炸弹。</p>
<p>无论是那种技术债务，在未来的产品迭代过程中，都需要开发人员去界定债务边界，不能任由技术债务滋生，否则在迭代过程中，面临的困难越来越多，甚至需要被迫承担更多的技术债务。基本上，你承担的债务越多，项目的进度就越慢，项目的后续阶段就会更加困难。</p>
<p>但是需要清楚的是，技术债务是无法消除的，你必须随时做好承担技术债务的准备。因为在一些项目场景中，一些具体问题的解决方案本身是可以解决问题的，但是该方案可能不是全局有效或最佳的，在系统的其他方面，就形成了一个不可避免而必须承担的技术债务问题。一个好的工程师团队应该是最小化技术债务影响，并对技术债务进行合理管理的团队。</p>
<p><img src="/images/technical-debt/techdebttype.png"></p>
<p>上文提到，技术债务分为<strong>有意的技术债务</strong>和<strong>无意的技术债务</strong>，两种形式的技术债务形成的原因和带来的结果也是不同的。在某些情况下，有意的技术债务相比无意的技术债务更好，有意的技术债务会让团队意识到问题，从而有意的去进行优化改进等，而无意的技术债务可能在项目中潜伏很长一段时间，可能导致严重的问题，然而，无意的技术债务在项目中是无法避免的，在工程师团队中可以强化编码规范、业务理解等来进行管理或者减弱技术债务出现的可能。</p>
<p>另外还可以将技术债务分类为<strong>鲁莽型技术债务</strong>和<strong>谨慎型技术债务</strong> 。一些谨慎型的技术债务在项目的进度中是可取的，但是不论是那种技术债务，都需要每个人用于去承担，两者是共同工作的。理想的情况下，承担的债务应当是哪些有意的和谨慎的技术债务，而哪些无意的和鲁莽的技术债务应当不惜一切代价避免。</p>
<h2 id="为什么要关心技术债务？"><a href="#为什么要关心技术债务？" class="headerlink" title="为什么要关心技术债务？"></a>为什么要关心技术债务？</h2><p><img src="/images/technical-debt/why-care-about-technical-debt.png"></p>
<h3 id="技术债务如何影响开发"><a href="#技术债务如何影响开发" class="headerlink" title="技术债务如何影响开发"></a>技术债务如何影响开发</h3><p>在开发阶段，开发人员不可避免会遇到技术债务，开发人员应当直面技术债务，并处理技术债务问题。虽然处理技术债务可能会使得开发周期变长，但从长远来看，开发人员及时处理技术债务是有益的，一方面处理技术债务是一个技术经验积累的过程，另一方面及时的处理在之后的迭代中也减少了技术债务产生的可能等。每一个开发员都应当有意的或者尽力地避免那些无意的技术债务和鲁莽的技术债务等。</p>
<h3 id="技术债务如何影响客户"><a href="#技术债务如何影响客户" class="headerlink" title="技术债务如何影响客户"></a>技术债务如何影响客户</h3><p>虽然乍看起来，技术债务和客户并无联系，客户也不太关心产品的代码质量等，客户只需要在成本没有增加的情况下，产品按时交付使用。然而，一个携带无意或者鲁莽的技术债务的产品在开发过程中，往往需要花费更多的时间、精力和资源，导致成本增加，但是收益却减少的情况等。</p>
<p><img src="/images/technical-debt/techdebtcost.png"></p>
<h3 id="技术债务如何影响用户"><a href="#技术债务如何影响用户" class="headerlink" title="技术债务如何影响用户"></a>技术债务如何影响用户</h3><p>即使是间接的，用户也会受到技术债务的影响。 他们可能不关心软件中的工作量或资金数量，但他们确实关心它的可靠运行，以及快速添加的新功能，这两者都可能受到大量技术债务的影响。 用户越快乐，客户越快乐，开发者越快乐。</p>
<h2 id="技术债务最佳实践"><a href="#技术债务最佳实践" class="headerlink" title="技术债务最佳实践"></a>技术债务最佳实践</h2><p><img src="/images/technical-debt/technical-debt-best-practices.png"></p>
<p>解决科技债务的最大问题是，它无法真正量化。这使得开发团队很难跟踪并让管理层向客户展示为什么要投入更多的资源和时间。</p>
<p>但是这里有一些你可以做的事情：</p>
<h3 id="保持最新状态"><a href="#保持最新状态" class="headerlink" title="保持最新状态"></a>保持最新状态</h3><p>不言而喻，工具，框架和库应该始终保持最新状态，可能你还未意识到这个问题所带来的影响，那只是你还没意识到而已。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>记录需要修复或更新的所有内容是确保实际修复和更新的最重要步骤。</p>
<p>如果存在技术债务，最好了解它并确保团队或未来的开发人员也知道。 文档减少了定位和修复任何问题所需的工作量，如果债务记录良好，甚至可能在业务层面上可见，将可能导致客户承认并提供额外资源。</p>
<h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><p>另一个强大的工具是在sprint期间定期审查代码。 代码审查可以捕捉到可能导致问题的隐患，并找到解决方案。 代码评审确实需要一些时间，但在整个项目的背景下肯定是值得的。</p>
<p>但是，代码审查也有其缺点。 开发人员往往太忙，无法深入挖掘他人的代码，因此他们只会发现明显的错误，而挑剔可能会导致团队内部紧张。 因此，它可以成为减少技术债务的有力工具，但应该谨慎应用。</p>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>自动化测试是一种非常强大的工具，但是经常被忽视。 自动化测试被忽略后，代码中的隐藏问题可能会无法察觉出，往往导致产品发布后需要投入不成比例的人力和时间来应对，是的成本变高甚至不可控。在开发阶段，有必要实施测试驱动开发，编写完善的测试用例，以清除代码中的许多不易察觉的问题等。</p>
<h3 id="敏捷架构"><a href="#敏捷架构" class="headerlink" title="敏捷架构"></a>敏捷架构</h3><p>敏捷架构具有很多优点，在构建软件的过程中对更改更加开放，基本上保证在任何项目上都会发生。 但是，它确实要求代码具有灵活性和可维护性，因此敏捷方法自然会使开发人员保持良好的代码，这有助于防止大量技术债务的积累。</p>
<h3 id="有效地复盘"><a href="#有效地复盘" class="headerlink" title="有效地复盘"></a>有效地复盘</h3><p>如果出现问题，应该用于面对，当问题解决后，需要进行有效地复盘。 但是要注意的是复盘是为了提高工作效率，绝不应该是找人责备。 复盘的重点应放在了解问题及其产生的原因上，以便团队可以采取必要措施防止同样的问题再次发生。 </p>
<h2 id="管理技术债务的最佳做法"><a href="#管理技术债务的最佳做法" class="headerlink" title="管理技术债务的最佳做法"></a>管理技术债务的最佳做法</h2><p><img src="/images/technical-debt/manage-technical-debt.png"></p>
<p>即使你做了以上所有事情，并尽可能避免堆积技术债务，你仍然需要处理一些问题。 这是无法避免的，因此您应该实施实践和流程以防止技术债务陷入困境。</p>
<h3 id="高息技术债务优先"><a href="#高息技术债务优先" class="headerlink" title="高息技术债务优先"></a>高息技术债务优先</h3><p>并非所有技术债务都是平等的，因此您应该优先考虑在特定时间解决的问题以及不解决的问题。 对于经常使用和更改的代码而言，比在几乎没有使用或更改过的部分的重要性要重要得多。</p>
<p>高息债务往往是那些在项目中起重要做的核心部分，通常围绕它进行了很多工作并以此为基础。 如果此部分的技术债务保持不变，就会妨碍所有的工作，并可能迫使更多的技术债务被添加到代码的其他部分。 因此，如果有可能，首先应优先考虑这些问题，从长远来看，使一切变得更加顺畅。</p>
<h3 id="童子军规则"><a href="#童子军规则" class="headerlink" title="童子军规则"></a>童子军规则</h3><p>“要始终保持营地比你发现它的时候更清洁”也是适用于软件开发的：“提交的代码比检出的要更好”。鼓励团队成员，以积极减少技术债务 ; 例如，当他们发现了一块为了功能增加或错误修复的代码时激励他们重构。</p>
<p>当然，它不能没有边界，否则它可能是一直消耗。 但是，如果你在每个sprint中留出一定比例的时间专门用于修复开发人员可能发现的任何技术债务，那么它可以在很大程度上保持产品尽可能无债务。</p>
<p><img src="/images/technical-debt/techdebtcruft.png"></p>
<h3 id="在履行有价值的客户工作时偿还债务"><a href="#在履行有价值的客户工作时偿还债务" class="headerlink" title="在履行有价值的客户工作时偿还债务"></a>在履行有价值的客户工作时偿还债务</h3><p>在项目的整个冲刺阶段，用于修复技术债务不是一个好主意。 一方面，客户往往不喜欢延期，对他们来说，看起来你似乎花了他们的时间和金钱来解决你做错的事情。另一方面，它也表明你已经做了大量的技术债务工作，所以你可能已经支付了更高的债务利息。</p>
<p>你最好指定在每个冲刺中偿还技术债务所花费的时间，并用它来解决高优先级或发生过的问题。 让客户满意，并使技术债务处于可控水平。</p>
<h3 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h3><p>同样重要的是要注意技术债务不应该总是得到偿还。 当产品接近其使用寿命时，如果它是短期制造的，或者它是一次性原型，技术债务不是主要问题。 这些实例很少见，但是当它们出现时你可以节省一些时间和精力。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>技术债务是伴随着项目的，无法避免，但是如何保持其在可控范围之内，是我们应该思考的问题。技术债务的避免和消除都需要好的优秀的开发人员，人始终是软件开发中最重要的因素。作为一名普通的码农，不断地提升自己是非常必要的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://codingsans.com/blog/technical-debt">TECHNICAL DEBT: EVERYTHING YOU NEED TO KNOW, AND HOW TO MANAGE IT</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8A%80%E6%9C%AF%E8%B4%9F%E5%80%BA">技术负债</a></li>
<li><a target="_blank" rel="noopener" href="https://insights.thoughtworks.cn/managing-technical-debt/">技术债治理的四条原则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2009/10/dissecting-technical-debt/">解析技术债务</a></li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T12:55:38.000Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2022-04-30-log-md/">2022-04-30</a></p><p class="categories"><a href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">每日随想</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.804Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2018-08-28-coreml-vs-mlkit/">Core ML vs ML Kit：哪一个移动端机器学习框架更适合你？</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.803Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2020-07-13-iOS-memory-manager/">Runtime剖析05 --- 再议iOS内存管理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.802Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-09-07-machine-learning-feature/">机器学习与移动应用开发的未来</a></p><p class="categories"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-30T06:35:13.801Z">2022-04-30</time></p><p class="title"><a href="/2022/04/30/2019-08-31-mind-flower/">思维的火花 --- 大数据与数据思维</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/">技术人生</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Runtime/"><span class="tag">Runtime</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">Swift中的数据结构与算法</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-iOS/"><span class="tag">开发知识 iOS</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86-%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">开发知识 技术人生</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="tag">技术人生</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F-%E8%AF%BB%E4%B9%A6%E8%AE%A1%E5%88%92/"><span class="tag">技术人生 读书计划</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-Python/"><span class="tag">数据科学 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Keras-MNIST/"><span class="tag">机器学习 Keras MNIST</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-MFCC/"><span class="tag">机器学习 MFCC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Python/"><span class="tag">机器学习 Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97-CoreML/"><span class="tag">端测计算 CoreML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>