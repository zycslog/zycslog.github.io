<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/19/cover.jpg" alt="\#19\ 基数排序（Radix Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">9 分钟读完 (大约1354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/">\#19\ 基数排序（Radix Sort）</a></h1><div class="content"><p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p>
<p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>基数排序依赖于整数的位置表示法，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png"></p>
<p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png"></p>
<p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">410</span>, <span class="number">20</span>, <span class="number">1772</span>, <span class="number">88</span>]</span><br></pre></td></tr></table></figure>

<p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png"></p>
<p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p>
<p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png"></p>
<p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>最后，在堆集合中的元素进行千位拆解：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png"></p>
<p>重新按照千位拆解结果进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">radixSort</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> base <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> digits <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>done &#123;</span><br><span class="line">            <span class="comment">// more to come</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p>
<ol>
<li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li>
<li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li>
</ol>
<p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p>
<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buckets: [[<span class="type">Int</span>]] <span class="operator">=</span> .<span class="keyword">init</span>(repeating: [], count: base)</span><br><span class="line">            </span><br><span class="line">forEach &#123;</span><br><span class="line">    number <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> remainingPart <span class="operator">=</span> number <span class="operator">/</span> digits</span><br><span class="line">    <span class="keyword">let</span> digit <span class="operator">=</span> remainingPart <span class="operator">%</span> base</span><br><span class="line">    buckets[digit].append(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digits <span class="operator">*=</span> base</span><br><span class="line"><span class="keyword">self</span> <span class="operator">=</span> buckets.flatMap &#123; <span class="variable">$0</span> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li>
<li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li>
<li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li>
</ol>
<p><strong>循环何时结束？</strong></p>
<p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p>
<ol>
<li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li>
<li>在forEach闭包结构中，增加如下语句：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remainingPart <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;radix sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    array.radixSort()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Radix sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of radix sort---</span></span><br><span class="line"><span class="comment">Original: [88, 410, 1772, 20]</span></span><br><span class="line"><span class="comment">Radix sorted: [20, 88, 410, 1772]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p>
<p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p>
</li>
<li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p>
</li>
<li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/"><img class="fill" src="/images/keras-mnist-for-ios/cover.jpg" alt="从Keras开始构建iOS平台手写数字实时识别"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.164Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">36 分钟读完 (大约5406个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-01-22-keras_mnist_for_iOS/">从Keras开始构建iOS平台手写数字实时识别</a></h1><div class="content"><p>本文将介绍如何构建和训练一个深度学习网络来识别手写数字，以及如何将训练所得的深度网络模型转换为iOS平台的机器学习框架CoreML格式，并集成进iOS应用程序中以实时识别数字等。</p>
<h1 id="10步之内完成模型的构建、训练和发布使用"><a href="#10步之内完成模型的构建、训练和发布使用" class="headerlink" title="10步之内完成模型的构建、训练和发布使用"></a><strong>10步之内完成模型的构建、训练和发布使用</strong></h1><p><strong>TLDR；</strong></p>
<p>本文中暂时不会介绍卷积神经网络的细节内容，例如如何使用卷积层、池化层训练深度学习网络，以及如何使用预训练模型识别目标等，相关卷积神经网络细节的内容将会放在本文内容之后，进行详细的介绍。本文旨在介绍如何一步一步的从数据的获取、整理、模型的构建、训练以及后面的格式转换、使用等介绍Keras框架的基本使用和如何使用CoreML体系在一个实实在在的应用程序中使用模型等。</p>
<p>下图是最终结果的预览：</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<p>接下来，开始一步步的实现相关的过程等。</p>
<h2 id="1-如何开始"><a href="#1-如何开始" class="headerlink" title="1. 如何开始"></a>1. <strong>如何开始</strong></h2><p>To have a fully working example I thought we’d start with a toy dataset like the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST set of handwritten letters</a> and train a deep learning network to recognize those. Once it’s working nicely on our PC, we will port it to an iPhone X using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">CoreML standard</a>.</p>
<p>在计算机程序设计学习的过程中，几乎都是以一个经典的“Hello World”程序开始的。而在机器学习领域，同样具有类似“Hello World”的一个经典入门级数据集——<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MNIST_database">MNIST</a>，该数据集是一系列手写数字0到9的图片文件，这里的目的是使用这个数据集训练一个深度学习网络来识别它们。在开始之前，你或许对iOS平台的CoreML以及keras还很陌生，你可以先了解一下它们的体系和设计：</p>
<ul>
<li>CoreML：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coreml">Core ML | Apple Developer Documentation</a></p>
<ul>
<li>Keras：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://keras.io/zh/">Keras 中文文档</a></p>
<h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><p>在大多数的Python机器学习类库中，都有内置的数据集访问接口，以方便使用者的使用，在Keras中也不例外，可以很方便的使用其内置的数据集访问接口获取数据集，具体的接口定义在<code>keras.datasets</code>中，具体的使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Keras内置数据集访问接口导入数据集并对数据集进行转换</span></span><br><span class="line">    <span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line">    <span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line">    <span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mnist_data</span>():</span><br><span class="line">        <span class="comment"># 定义输入图像的维度</span></span><br><span class="line">        img_rows, img_cols = <span class="number">28</span>, <span class="number">28</span></span><br><span class="line">        <span class="comment"># 加载数据集</span></span><br><span class="line">        (X_train, Y_train), (X_test, Y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> K.image_data_format() == <span class="string">&#x27;channels_first&#x27;</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], <span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">            input_shape = (<span class="number">1</span>, img_rows, img_cols)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = X_train.reshape(X_train.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            X_test = X_test.reshape(X_test.shape[<span class="number">0</span>], img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">            input_shape = (img_rows, img_cols, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 数据缩放，将原来的 [0, 255] 缩放至 [0, 1]</span></span><br><span class="line">        X_train = X_train.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">        X_test = X_test.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 对原始数据中的目标值进行One-Hot Encoding，使得目标数据更加的稀疏</span></span><br><span class="line">        Y_train = np_utils.to_categorical(Y_train, <span class="number">10</span>)</span><br><span class="line">        Y_test = np_utils.to_categorical(Y_test, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> (X_train, Y_train), (X_test, Y_test), input_shape</span><br><span class="line">    </span><br><span class="line">    (X_train, Y_train), (X_test, Y_test), input_shape = mnist_data()</span><br></pre></td></tr></table></figure>

<h2 id="3-正确地编码"><a href="#3-正确地编码" class="headerlink" title="3. 正确地编码"></a>3. 正确地编码</h2><p>当处理图片数据的时候，必须要区分想要的编码方式。Keras是一个可以处理多个“后端”的高级库，例如<a target="_blank" rel="noopener" href="https://www.tensorflow.org/">Tensorflow</a>, <a target="_blank" rel="noopener" href="http://deeplearning.net/software/theano/">Theano</a> 和 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/cognitive-toolkit/">CNTK</a>，首先我们要了解我们所使用的后端是如何编码数据的。在Keras默认使用的TensorFlow后端中，针对图像的处理通常是以“通道优先”或“通道末尾”的方式进行编码的，因此在我们的使用TensorFlow作为后端的时候，编码结果其实是一个张量，其形状为(batch_size, rows, cols, channels)。意味着首先是输入的batch_size，然后输入28行28列的图像维度，最后输入1作为通道数，因为我们使用的是灰度图像数据。</p>
<p>我们可以看看前6张图像具体是什么样子，可以使用如下代码查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可视化数据集中前6张图像</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    %matplotlib inline</span><br><span class="line">    <span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cm</span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    </span><br><span class="line">    (X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">    </span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">6</span>, i+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        ax.imshow(X_train[i], cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="built_in">str</span>(y_train[i]))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://liip.rokka.io/www_inarticle/7cce04/numbers.png"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-规范化数据"><a href="#4-规范化数据" class="headerlink" title="4. 规范化数据"></a>4. 规范化数据</h2><p>可以看到，在黑色背景中显示了白色数字，每一张图像中的数字都是居中的，而且分辨率都很低——在这个例子中我们使用的是28x28像素。</p>
<p>你可能已经注意到，在上述获取数据的部分，我们对每一张图片除以255来缩放了图像像素，这导致像素值在0和1之间，这对于任何类型的训练都非常有用。每个图像像素值在转换之前都是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用像素值可视化一个数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_input</span>(<span class="params">img, ax</span>):</span><br><span class="line">    ax.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    width, height = img.shape</span><br><span class="line">    thresh = img.<span class="built_in">max</span>()/<span class="number">2.5</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            ax.annotate(<span class="built_in">str</span>(<span class="built_in">round</span>(img[x][y], <span class="number">2</span>)),</span><br><span class="line">                        xy=(y, x),</span><br><span class="line">                        horizontalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        verticalalignment=<span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                        color=<span class="string">&#x27;white&#x27;</span> <span class="keyword">if</span> img[x][y] &lt; thresh <span class="keyword">else</span> <span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">visualize_input(X_train[<span class="number">0</span>], ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/keras-mnist-for-ios/pixes-daf69647-717f-499d-aa39-fa83904d7675.png"></p>
<p>可以看到图像中的每个灰度像素都是介于0到255之间的，并且当像素为255时，背景色为白色，像素为0时，背景色为黑色。在这里使用的是<code>mnist.load_data()</code>加载的数据集，此时并没有对图像进行像素缩放，而在我们自定义的数据集加载方法<code>mnist_data()</code>方法中，我们进行了像素的缩放，<code>X_train = X_train.astype(&#39;float32&#39;)/255</code> 。</p>
<h2 id="5-One-Hot-编码"><a href="#5-One-Hot-编码" class="headerlink" title="5. One-Hot 编码"></a>5. One-Hot 编码</h2><p>最初，数据以Y-Vector包含X Vector（像素数据）包含的数值的方式编码。例如，如果图像看起来像7，那么Y-Vector中必定包含数字7。但是这种方式不利于我们在网络结构中直接使用，我们需要进行这种转换，希望将数据的输出映射到网络中的10个输出神经元，此时当相应的数字被识别时，相应的神经元就会触发，从而达到有效的识别。</p>
<p><img src="https://liip.rokka.io/www_inarticle/46a2ef/onehot.png"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="6-网络模型化"><a href="#6-网络模型化" class="headerlink" title="6. 网络模型化"></a>6. 网络模型化</h2><p>了解了数据集的基本情况以及进行合理的数据转换后，该是定义卷积神经网络的时候了。这里讲直接使用卷积神经网络中的卷积层和池化层来定义网络，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义网络模型</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adadelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">network</span>():</span><br><span class="line">    model = Sequential()</span><br><span class="line">    input_shape = (<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Conv2D(filters=<span class="number">32</span>, kernel_size=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">500</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dropout(<span class="number">0.4</span>))</span><br><span class="line"></span><br><span class="line">    model.add(Dense(num_classes, activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型概述</span></span><br><span class="line">    <span class="built_in">print</span>(model.summary())</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<p>在模型的定义中，我们以内核大小为3的<a target="_blank" rel="noopener" href="https://keras.io/layers/convolutional/">卷积</a>，这也意味着窗口为3x3像素，输入形状的大小为28x28像素。紧跟着使用了一个池化大小为2的<a target="_blank" rel="noopener" href="https://keras.io/layers/pooling/">池化层</a>，这里的池化大小为2，意味着将会对每一个输入缩减为原来的一般，因此在下一个卷积层中，输入大小为14x14像素。按照此方式重复两次后，最终的卷积输入大小转换为3x3像素。接下来，使用了<a target="_blank" rel="noopener" href="https://keras.io/layers/core/#dropout">Dropout层</a>，将30%的输入单元随机设置为0，以防止训练的过拟合。最后，展平输入层（此例子中为3x3x32&#x3D;288），并将它们连接到一个具有500个输入的密度层。在这些步骤之后，添加了另一个Dropout层，之后连接到最后的密度层，该密度层中包含10个输出单元，这些输出单元对应着我们的目标类别，0到9之间的数字。</p>
<pre><code>_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d_1 (Conv2D)            (None, 28, 28, 32)        320       
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 14, 14, 32)        0         
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 14, 14, 32)        4128      
_________________________________________________________________
max_pooling2d_2 (MaxPooling2 (None, 7, 7, 32)          0         
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 7, 7, 32)          4128      
_________________________________________________________________
max_pooling2d_3 (MaxPooling2 (None, 3, 3, 32)          0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 3, 3, 32)          0         
_________________________________________________________________
flatten_1 (Flatten)          (None, 288)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 500)               144500    
_________________________________________________________________
dropout_2 (Dropout)          (None, 500)               0         
_________________________________________________________________
dense_2 (Dense)              (None, 10)                5010      
=================================================================
Total params: 158,086
Trainable params: 158,086
Non-trainable params: 0
_________________________________________________________________
</code></pre>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7. 训练模型"></a>7. 训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model = network()</span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=Adadelta(), metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line"><span class="comment"># 使用训练数据拟合模型</span></span><br><span class="line">model.fit(X_train, Y_train, batch_size=<span class="number">512</span>, epochs=<span class="number">6</span>, verbose=<span class="number">1</span>, validation_data=(X_test, Y_test))</span><br><span class="line"><span class="comment"># 模型评估分数</span></span><br><span class="line">score = model.evaluate(X_test, Y_test, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test loss:&#x27;</span>, score[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Test accuracy:&#x27;</span>, score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>categorical_crossentropy</code>作为损失函数，因为我们的目标类别有多个（0至9），Keras库提供了多种<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#usage-of-optimizers">优化器</a>，你可以选择任意一个进行模型训练，并最终找到一个最好的。经过尝试之后，这里选择<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adadelta"><code>AdaDelta</code></a>作为优化器进行模型训练，当然你也可以尝试AdaDelta的高级版<a target="_blank" rel="noopener" href="https://keras.io/optimizers/#adagrad">AdaGrad</a>。</p>
<p><img src="https://liip.rokka.io/www_inarticle/42b4b8/train.png"></p>
<p>可以看到，经过训练，所得到的模型识别准确率达到了98%，考虑到这里仅仅使用了简单的网络结构，达到这样的准确率已经是非常出色了。在上述截图中，每次迭代的准确性都是在提高，可以说明这里使用的简单结构是合理的，训练得到的模型可以很好地预测输入28x28像素所表示的数字。</p>
<h2 id="8-保存模型"><a href="#8-保存模型" class="headerlink" title="8. 保存模型"></a>8. 保存模型</h2><p>由于我们想要在iOS设备上使用该模型，因此需要将该模型转换为iOS系统能够理解的格式。实际上，微软、Facebook以及亚马逊等企业已经研发出了一套能够在所有深度学习网络格式见转换的协议，以便能够在任何设备上使用的可交换的开放式神经网络交换格式——<a target="_blank" rel="noopener" href="https://onnx.ai/">ONNX</a>。</p>
<p>但是，截止目前，Apple设备上仅仅能够使用的是CoreML格式。为了能够将Keras模型转换为CoreML格式，Apple特意推出来一个非常方便的帮助类库——<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">coremltools</a>，这里我们就可以使用该类库来完成工作。该类库能够将scikit-learn、Keras、XGBoost等机器学习类库训练的模型转换为CoreML支持的格式，从而使得模型能够直接在Apple设备上使用。如果你还未安装coremltools类库，可以使用<code>pip install coremltools</code>进行安装，然后再使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coreml_model = coremltools.converters.keras.convert(model,</span><br><span class="line">                                                        input_names=<span class="string">&quot;image&quot;</span>,</span><br><span class="line">                                                        image_input_names=<span class="string">&#x27;image&#x27;</span>,</span><br><span class="line">                                                        class_labels=[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">                                                        )</span><br></pre></td></tr></table></figure>

<p>在进行模型转换的时候，最重要的参数是class_labels，它定义了模型尝试预测的类数，以及input_names或者image_input_names。通过将它们设置为图像，Xcode会自动识别该模型是关于接收图像并从中预测某些内容，也就是说这些参数是告诉Xcode，该模型是关于那方面的任务。根据应用程序和模型的特定功能，需要研究<a target="_blank" rel="noopener" href="https://apple.github.io/coremltools/generated/coremltools.converters.keras.convert.html">官方文档</a>进一步的了解这些参数的可选值等。</p>
<p>另外还有一些可以定义模型元信息的参数，这些参数可以给模型一个简要的说明，甚至作者、license等，可以让使用者能够方便的查阅模型所针对的特定任务等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑模型元信息</span></span><br><span class="line">coreml_model.author = <span class="string">&#x27;Robin&#x27;</span></span><br><span class="line">coreml_model.license = <span class="string">&#x27;MIT&#x27;</span></span><br><span class="line">coreml_model.short_description = <span class="string">&#x27;MNIST handwriting recognition with a 3 layer network&#x27;</span></span><br><span class="line">coreml_model.input_description[<span class="string">&#x27;image&#x27;</span>] = <span class="string">&#x27;28x28 grayscaled pixel values between 0-1&#x27;</span></span><br><span class="line">coreml_model.save(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(coreml_model)</span><br></pre></td></tr></table></figure>

<h2 id="9-使用模型预测"><a href="#9-使用模型预测" class="headerlink" title="9. 使用模型预测"></a>9. 使用模型预测</h2><p>在将模型保存为CoreML格式之后，我们可以尝试使用转换后的模型进行一个预测，来确定模型是否工作正常。在这里我们将从MNIST数据集中选择一张图像进行预测验证。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用CoreML模型预测验证</span></span><br><span class="line"> <span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> model =  coremltools.models.MLModel(<span class="string">&#x27;SimpleMnist.mlmodel&#x27;</span>)</span><br><span class="line"> im = Image.fromarray((np.reshape(mnist_data()[<span class="number">0</span>][<span class="number">0</span>][<span class="number">12</span>]*<span class="number">255</span>, (<span class="number">28</span>, <span class="number">28</span>))).astype(np.uint8),<span class="string">&quot;L&quot;</span>)</span><br><span class="line"> plt.imshow(im)</span><br><span class="line"> predictions = model.predict(&#123;<span class="string">&#x27;image&#x27;</span>: im&#125;)</span><br><span class="line"> <span class="built_in">print</span>(predictions)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<pre><code>&#123;u&#39;classLabel&#39;: u&#39;3&#39;, 
u&#39;output1&#39;: &#123;u&#39;1&#39;: 0.0, 
                        u&#39;0&#39;: 0.0, 
                        u&#39;3&#39;: 1.0, 
                        u&#39;2&#39;: 0.0, 
                        u&#39;5&#39;: 0.0, 
                        u&#39;4&#39;: 0.0, 
                        u&#39;7&#39;: 0.0, 
                        u&#39;6&#39;: 0.0, 
                        u&#39;9&#39;: 0.0, 
                        u&#39;8&#39;: 0.0
                        &#125;
&#125;
</code></pre>
<p><img src="/images/keras-mnist-for-ios/download-45f07bef-9ca6-4ea6-a674-789607207e9c.png"></p>
<p>可以看到，预测过程和结果均符合预期。接下来是时候在Xcode项目中使用该模型了。</p>
<h1 id="10步完成模型在Xcode项目中的应用"><a href="#10步完成模型在Xcode项目中的应用" class="headerlink" title="10步完成模型在Xcode项目中的应用"></a>10步完成模型在Xcode项目中的应用</h1><p>为了能够让几乎所有人了解机器学习模型文件是如何一步一步在Xcode项目中使用的，这里将会从最为基础的Xcode安装、项目创建等说起，如果你是iOS开发的老鸟，部分内容请自行略过。</p>
<h2 id="1-安装Xcode"><a href="#1-安装Xcode" class="headerlink" title="1. 安装Xcode"></a>1. 安装Xcode</h2><p>对于iOS体系来说，Xcode是开发iOS应用程序必须的工具之一，因此如果你还未安装Xcode，需要安装Xcode，最为简单的方式是在Mac App Store中搜索并安装。如果你已经安装了Xcode，需要确保Xcode的版本至少在9.0或以上。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>安装好Xcode之后，开启Xcode，选择iOS平台下的单视图应用，命名项目，这里命名为“MNIST-Demo”，选择一个保存项目文件的位置，创建项目即可。</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-78fa75ca-4376-49e8-b194-bde1699f9be3.png"></p>
<h2 id="3-添加CoreML模型文件"><a href="#3-添加CoreML模型文件" class="headerlink" title="3. 添加CoreML模型文件"></a>3. 添加CoreML模型文件</h2><p>现在，你可以将通过coremltools转换得到的CoreML模型加入到项目中了。最简单的方式是直接拖拽模型文件到项目目录中，如果为了之后更新模型而不用去删掉重新添加，你可以在弹出的选项框中选择“add as Reference”。</p>
<p><img src="/images/keras-mnist-for-ios/add-model-98101cf6-8cf8-4d2a-b58e-30d397c98354.png"></p>
<h2 id="4-删除不需要的视图或者故事版"><a href="#4-删除不需要的视图或者故事版" class="headerlink" title="4. 删除不需要的视图或者故事版"></a>4. 删除不需要的视图或者故事版</h2><p>因为我们仅仅使用相机并显示标签，因此这里会删除掉项目中默认的一些用户界面，也就是项目中的视图控制器和故事面板。当然你也可以选择不删除，直接使用现有的视图和故事面板进行开发，不论选择哪种方式都能达到目的。这里要注意的是，如果选择编码的方式构建应用，再删除了主故事面板文件后，需要在项目的TARGETS中同步删除”Main Interface”的默认设置。</p>
<p><img src="/images/keras-mnist-for-ios/ScreenShot2018-11-22at10-9150b677-f351-4732-bfb6-d74019527380.32.46AM.png"></p>
<h2 id="5-程序化创建根视图控制器"><a href="#5-程序化创建根视图控制器" class="headerlink" title="5. 程序化创建根视图控制器"></a>5. 程序化创建根视图控制器</h2><p>接下来我们将使用代码的方式，重新制定应用程序的根视图。具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码的方式指定根视图控制器</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">     <span class="comment">// 创建窗口</span></span><br><span class="line">     window <span class="operator">=</span> <span class="type">UIWindow</span>()</span><br><span class="line">     window<span class="operator">?</span>.makeKeyAndVisible()</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// 指定根视图控制器</span></span><br><span class="line">     <span class="keyword">let</span> vc <span class="operator">=</span> <span class="type">ViewController</span>()</span><br><span class="line">     window<span class="operator">?</span>.rootViewController <span class="operator">=</span> vc</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构建视图控制器细节"><a href="#6-构建视图控制器细节" class="headerlink" title="6. 构建视图控制器细节"></a>6. 构建视图控制器细节</h2><p>接下来就是构建视图控制器的详细内容细节了。我们需要以下可交互的元素组件，例如按钮，也需要作为展示结果或者状态的标签等，另外重要的是，由于需要使用相机，因此AVFoundation类库是必须要添加的，该库用来访问和控制iOS设备上的相机，还需要Vision库，该库是iOS推出的用于计算机视觉相关任务的工具库，能够很好的和CoreML模型之间进行交互等。</p>
<p>具体的代码细节，这里不再累述，完成之后的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义视图控制器</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> AVFoundation</span><br><span class="line"><span class="keyword">import</span> Vision</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于要使用到相机设备进行视频流的输入，因此这里要继承AVCaptureVideoDataOutputSampleBufferDelegate协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">AVCaptureVideoDataOutputSampleBufferDelegate</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个文本标签用来显示识别结果</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">UILabel</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.textColor <span class="operator">=</span> .white</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Label&quot;</span></span><br><span class="line">        label.font <span class="operator">=</span> label.font.withSize(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="comment">// 调用相机设备设置方法、文本标签设置方法</span></span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()       </span><br><span class="line">        setupCaptureSession()</span><br><span class="line">        view.addSubview(label)</span><br><span class="line">        setupLabel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置相机设备session</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupCaptureSession</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的捕获session</span></span><br><span class="line">        <span class="keyword">let</span> captureSession <span class="operator">=</span> <span class="type">AVCaptureSession</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找可用的相机设备</span></span><br><span class="line">        <span class="keyword">let</span> availableDevices <span class="operator">=</span> <span class="type">AVCaptureDevice</span>.<span class="type">DiscoverySession</span>(deviceTypes: [.builtInWideAngleCamera], mediaType: <span class="type">AVMediaType</span>.video, position: .back).devices</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 选择首个设备并设置为输入源</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> captureDevice <span class="operator">=</span> availableDevices.first &#123;</span><br><span class="line">                captureSession.addInput(<span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: captureDevice))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未找到相机设备，则打印错误信息</span></span><br><span class="line">            <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将视频输出设置到屏幕并将输出添加到我们的捕获会话</span></span><br><span class="line">        <span class="keyword">let</span> captureOutput <span class="operator">=</span> <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">        captureSession.addOutput(captureOutput)</span><br><span class="line">        <span class="keyword">let</span> previewLayer <span class="operator">=</span> <span class="type">AVCaptureVideoPreviewLayer</span>(session: captureSession)</span><br><span class="line">        previewLayer.frame <span class="operator">=</span> view.frame</span><br><span class="line">        view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓冲视频并启动捕获会话</span></span><br><span class="line">        captureOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>(label: <span class="string">&quot;videoQueue&quot;</span>))</span><br><span class="line">        captureSession.startRunning()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">captureOutput</span>(<span class="keyword">_</span> <span class="params">output</span>: <span class="type">AVCaptureOutput</span>, <span class="params">didOutput</span> <span class="params">sampleBuffer</span>: <span class="type">CMSampleBuffer</span>, <span class="params">from</span> <span class="params">connection</span>: <span class="type">AVCaptureConnection</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载Core ML 模型</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">VNCoreMLModel</span>(for: <span class="type">SimpleMnist</span>().model) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Core ML运行推理</span></span><br><span class="line">        <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">VNCoreMLRequest</span>(model: model) &#123; (finishedRequest, error) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> results <span class="operator">=</span> finishedRequest.results <span class="keyword">as?</span> [<span class="type">VNClassificationObservation</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 捕获得分最高的推理结果</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> <span class="type">Observation</span> <span class="operator">=</span> results.first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建最终显示的文本格式</span></span><br><span class="line">            <span class="keyword">let</span> predclass <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(Observation.identifier)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 显示在文本标签内</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async(execute: &#123;</span><br><span class="line">                <span class="keyword">self</span>.label.text <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(predclass)</span> &quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建一个核心视频像素缓冲区，它是一个图像缓冲区，用于保存主存储器中的像素生成帧，</span></span><br><span class="line">                <span class="comment">// 压缩或解压缩视频或使用核心图像的应用程序都可以使用核心视频像素缓冲区</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> pixelBuffer: <span class="type">CVPixelBuffer</span> <span class="operator">=</span> <span class="type">CMSampleBufferGetImageBuffer</span>(sampleBuffer) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="keyword">try?</span> <span class="type">VNImageRequestHandler</span>(cvPixelBuffer: pixelBuffer, options: [:]).perform([request])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setupLabel</span>() &#123;</span><br><span class="line">        label.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        label.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: <span class="operator">-</span><span class="number">50</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你直接使用上述代码，请记得修改模型的名称。</p>
</blockquote>
<p><img src="/images/keras-mnist-for-ios/Untitled-503351b4-b11a-4e7b-a7ad-de4017cbac28.png"></p>
<h2 id="6-添加隐私说明信息"><a href="#6-添加隐私说明信息" class="headerlink" title="6. 添加隐私说明信息"></a>6. 添加隐私说明信息</h2><p>由于我们要使用相机设备进行视频数据流的获取，因此需要在Xcode工程项目中的info.plist文件中添加相应的权限申请说明“<em>Privacy - Camera Usage Description</em>”，并附带相应的说明性文字：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-8e6fa826-e368-47d0-8256-588a136119db.png"></p>
<h2 id="7-加入苹果开发者计划"><a href="#7-加入苹果开发者计划" class="headerlink" title="7. 加入苹果开发者计划"></a>7. 加入苹果开发者计划</h2><p>为了能够让该应用程序运行在你的手机设备上，你可能需要注册<a target="_blank" rel="noopener" href="https://developer.apple.com/programs/enroll/">苹果的开发者计划</a>。当然如果你不想为了运行项目而花费金钱，你也可以按照<a target="_blank" rel="noopener" href="https://9to5mac.com/2016/03/27/how-to-create-free-apple-developer-account-sideload-apps/">此教程</a>注册免费的账户。</p>
<h2 id="8-在iPhone设备上发布应用"><a href="#8-在iPhone设备上发布应用" class="headerlink" title="8. 在iPhone设备上发布应用"></a>8. 在iPhone设备上发布应用</h2><p>一切准备好之后，你就可以将该应用程序发布到你的手机设备上了。你可以按照如下图所示的方式发布项目，也可以直接在Xcode中选定目标设备，然后使用快捷键CMD+R的方式构建：</p>
<p><img src="/images/keras-mnist-for-ios/Untitled-1a74e4bf-8c84-4e49-95f2-4b46f8f4102f.png"></p>
<h2 id="9-使用应用程序"><a href="#9-使用应用程序" class="headerlink" title="9. 使用应用程序"></a>9. 使用应用程序</h2><p>经过上述各种设置和编码之后，终于可以在设备上运行我们的应用程序了。如果一切正常，首次应用程序启动的时候，会询问你是否允许应用程序访问设备的相机，这里需要允许，否则我们的应用程序则无法正常工作。</p>
<p>另外，我们这里所训练的模型以及制作的应用程序，没有进行详细的设计和优化，在识别的过程中，可能会遇到识别不出来以及识别错误的情况，如果需要将此功能应用在你的产品中，需要严格重新审查你所拥有的数据，以及模型的训练，app的使用等，以免出现不可预知的错误等问题。</p>
<p><img src="https://liip.rokka.io/www_inarticle/812493/output.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，希望能够让你了解如何使用Keras训练所需要的模型，以及如何将其应用在iOS平台下的应用程序中，虽然介绍的不够深入，但是希望能够带给你继续深入理解Keras、了解Core ML的欲望，早日在你的应用程序中实现AI的能力，为你的应用程序增添色彩。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/6/cover.jpg" alt="\#6\ Linked List 挑战"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.106Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1703个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/">\#6\ Linked List 挑战</a></h1><div class="content"><p>本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。</p>
<h2 id="Challenge-1：创建按照反向顺序打印链表元素的函数。"><a href="#Challenge-1：创建按照反向顺序打印链表元素的函数。" class="headerlink" title="Challenge 1：创建按照反向顺序打印链表元素的函数。"></a>Challenge 1：创建按照反向顺序打印链表元素的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// outut</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 解决此问题最简单直接的方式就是使用<strong>递归</strong>。由于递归允许构建回调堆栈，因此我们可以在递归的回调中调用<strong>print</strong>打印节点元素值。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    printInReverse(node.next)</span><br><span class="line">    <span class="built_in">print</span>(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    printInReverse(list.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;printing in reverse&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverse(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of printing in reverse---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Printing in reverse: </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>该算法的核心在于递归调用的部分，当节点存在的情况下，继续遍历当前节点的下一个节点，否则就是已经到了末尾节点，在递归的过程回调堆栈中打印节点值。该算法时间复杂度为**O(n)**。</p>
<h2 id="Challenge-2：创建返回链表中间节点值的函数。"><a href="#Challenge-2：创建返回链表中间节点值的函数。" class="headerlink" title="Challenge 2：创建返回链表中间节点值的函数。"></a>Challenge 2：创建返回链表中间节点值的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nil</span><br><span class="line">// middle is 3</span><br><span class="line"></span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line">// middle is 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 该问题的解决思路是利用<strong>双指针位移的偏移量</strong>的方式来进行求解，也就是说分别定义两个初始位置相同的指针，然后对链表进行遍历，遍历的过程中，其中一个针对每次位移两个位置，另一个位移一个位置，位移快的那个移动到链表末尾时，慢的那个正好是链表的中间位置。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMiddle</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> fast <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> slow <span class="operator">=</span> list.head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> nextFast <span class="operator">=</span> fast<span class="operator">?</span>.next &#123;</span><br><span class="line">        fast <span class="operator">=</span> nextFast.next</span><br><span class="line">        slow <span class="operator">=</span> slow<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;getting the middle node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> middleNode <span class="operator">=</span> getMiddle(list) &#123;</span><br><span class="line">        <span class="built_in">print</span>(middleNode.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of getting the middle node---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度是**O(n)<strong>。也可以使用另一种解法，先遍历依次整个链表，记录节点总数，然后取链表节点总数的一半，再次进行遍历，获取中间值，但是这样的解法需要遍历两次，时间复杂度为</strong>O(n^2)**。</p>
<h2 id="Challenge-3：创建反转链表的函数。"><a href="#Challenge-3：创建反转链表的函数。" class="headerlink" title="Challenge 3：创建反转链表的函数。"></a>Challenge 3：创建反转链表的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">// Before</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">3 -&gt; 2 -&gt; 1 -&gt; nil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该问题简单的解决方案是，新建一个LinkedList，然后遍历原LinkedList，将节点一个一个的push到新的LinkedList，最后更新原LinkedList的头节点即可。但是这样的方式会有一个性能问题，就是每次调用push方法的时候，都需要分配新的节点，造成了绝大的资源成本。另一种代码较为复杂，但是性能上却相当好的方案是，构建两个变量，分别指向当前节点和上一个节点，然后遍历LinkedList，依次向后交换当前节点和上一个节点的指向，直到当前节点为nil时结束，这样就完全避免了每次新建节点的资源消耗问题。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 1</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionOne</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> tempList <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Value</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        tempList.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> tempList.head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionTwo</span>() &#123;</span><br><span class="line">    tail <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">    prev<span class="operator">?</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> current <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> next <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        current<span class="operator">?</span>.next <span class="operator">=</span> prev</span><br><span class="line">        prev <span class="operator">=</span> current</span><br><span class="line">        current <span class="operator">=</span> next</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然两种解决方案都是完整该挑战，但是在时间复杂度相同的情况下，空间复杂度更好的解决方案2，是应该遵循且掌握的方式。算法2的思路图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/reversed-list.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;reverse the list solution 2&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    list.reverseSolutionTwo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reversed list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of reverse the list solution 2---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Reversed list: 3 -&gt;2 -&gt;1 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"><a href="#Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。" class="headerlink" title="Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"></a>Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list1</span><br><span class="line">1 -&gt; 4 -&gt; 10 -&gt; 11</span><br><span class="line"></span><br><span class="line">// list2</span><br><span class="line">-1 -&gt; 2 -&gt; 3 -&gt; 6</span><br><span class="line"></span><br><span class="line">// merged list</span><br><span class="line">-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 10 -&gt; 11</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此问题的解决方案是不断从两个已排序的列表中摘取节点，并将它们添加到新列表中。由于两个列表已经排序，因此可以比较两个列表的下一个节点，以查看哪个节点应该是要添加到新列表的下一个节点。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> <span class="params">left</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">_</span> <span class="params">right</span>:<span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 检查输入的两个链表是否为空，如果其中一个为空，则直接返回另一个</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>left.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>right.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果链表的head、tail定义</span></span><br><span class="line">    <span class="keyword">var</span> newHead: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> tail: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> currentLeft <span class="operator">=</span> left.head</span><br><span class="line">    <span class="keyword">var</span> currentRight <span class="operator">=</span> right.head</span><br><span class="line">    <span class="comment">// 检查left、right的首个节点，并将小的节点赋值给newHead</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            newHead <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newHead <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="comment">// 遍历left、right，尝试挑选能够加入新链表的节点，直到其中一个链表到达末尾节点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="comment">// 比较节点值大小，并将小的链接到tail.next</span></span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> tail<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上个while循环同时以来currentLeft和currentRight，因此即使链表中还有节点，循坏也可能提前终止。需要将剩余的节点链接到处理单元中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNodes <span class="operator">=</span> currentLeft &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> leftNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> rightNodes <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> rightNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建结果链表，这里不使用push或者append的方式，而是直接指定链表的head、tail</span></span><br><span class="line">    <span class="comment">// head只有一个节点，直接复制，tail包含了很多节点，需要一个一个地进行链接</span></span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    list.head <span class="operator">=</span> newHead</span><br><span class="line">    list.tail <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next <span class="operator">=</span> tail<span class="operator">?</span>.next &#123;</span><br><span class="line">            tail <span class="operator">=</span> next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法求解过程的图示：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/MergeTwolinkedLists.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;merging two sorted list&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> list2 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">2</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;First list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Second list: <span class="subst">\(list2)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> mergedList <span class="operator">=</span> mergeSort(list1, list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merged list: <span class="subst">\(mergedList)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of merging two sorted list---</span></span><br><span class="line"><span class="comment">// First list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Second list: -3 -&gt;-2 -&gt;-1  </span></span><br><span class="line"><span class="comment">// Merged list: -3 -&gt;-2 -&gt;-1 -&gt;1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。"><a href="#Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。" class="headerlink" title="Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。"></a>Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// original list</span><br><span class="line">1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 4</span><br><span class="line"></span><br><span class="line">// list after removing all occurrences of 3</span><br><span class="line">1 -&gt; 4</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">LinkedList</span> <span class="title class_">where</span> <span class="title class_">Value</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeAll</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> head <span class="operator">=</span> <span class="keyword">self</span>.head, head.value <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">self</span>.head <span class="operator">=</span> head.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> currentNode <span class="operator">=</span> current &#123;</span><br><span class="line">            <span class="keyword">guard</span> currentNode.value <span class="operator">!=</span> value <span class="keyword">else</span> &#123;</span><br><span class="line">                prev<span class="operator">?</span>.next <span class="operator">=</span> currentNode.next</span><br><span class="line">                current <span class="operator">=</span> prev<span class="operator">?</span>.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev <span class="operator">=</span> current</span><br><span class="line">            current <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail <span class="operator">=</span> prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/delete-duplicate.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;deleting duplicate nodes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Origin list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    list1.removeAll(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete duplicate list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of deleting duplicate nodes---</span></span><br><span class="line"><span class="comment">// Origin list: 1 -&gt;1 -&gt;2 -&gt;2 -&gt;2 -&gt;3     </span></span><br><span class="line"><span class="comment">// Delete duplicate list: 1 -&gt;1 -&gt;3 </span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">23 分钟读完 (大约3452个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-08-03-ml-normal-methods/">机器学习问题的通用方法</a></h1><div class="content"><p>一位数据科学家平均每天处理大量数据，有人说，超过60-70％的时间花在了数据采集、数据清理、数据整理上，使得机器学习模型可以应用于这些数据。本文重点介绍第二部分，即应用机器学习模型，包括预处理步骤。这篇文章中讨论的流水线是我参与过的一百多次机器学习竞赛的结果。必须指出，这里的讨论虽然普通，但非常有用，也存在非常复杂的方法，可供专业人员练习。</p>
<p>我们将在这里使用python！</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>在应用机器学习模型之前，必须将数据转换为表格形式。整个过程是最耗时且最困难的过程，如下图所示。</p>
<p><img src="/images/ml-normal/1.png"></p>
<p>然后是机器学习模型应用于表格数据，表格数据是在机器学习或数据挖掘中表示数据的最常用方式。我们有一个数据表，包含不同数据样本（或X和标签y）的行。标签可以是单列或多列，具体取决于问题的类型。我们将用X表示数据，用y表示标签。</p>
<h1 id="标签的类型"><a href="#标签的类型" class="headerlink" title="标签的类型"></a>标签的类型</h1><p>标签定义了问题，可以是不同的类型，如：</p>
<ul>
<li>单列，二元值（分类问题，一个样本只属于一个类，只有两个类）</li>
<li>单列，实数值（回归问题，仅预测一个值）</li>
<li>多列，二元值（分类问题，一个样本属于一个类，但有两个以上的类）</li>
<li>多列，实数值（回归问题，多值预测）</li>
<li>多标签（分类问题，一个样本可以属于几个类）</li>
</ul>
<h1 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h1><p>对于任何类型的机器学习问题，我们必须确定将如何评估我们的结果，要评估的指标或目标是什么？例如，如果存在倾斜的二分类问题，我们通常选择受试者工作特征曲线下的面积（ROCAUC或简称AUC）。在多标签或多分类问题的情况下，我们通常选择分类交叉熵或多分类对数损失，在回归问题的情况下选择均方误差。</p>
<p>我不会详细讨论不同的评估指标，我们可以有许多不同的类型，具体取决于问题本身。</p>
<h1 id="机器学习库"><a href="#机器学习库" class="headerlink" title="机器学习库"></a>机器学习库</h1><p>要开始使用机器学习库，首先安装基本的和最重要的库，例如numpy和scipy。</p>
<p>查看和执行数据操作：pandas（<a target="_blank" rel="noopener" href="http://pandas.pydata.org/">http://pandas.pydata.org/</a>）<br>对于各种机器学习模型：scikit-learn（<a target="_blank" rel="noopener" href="http://scikit-learn.org/stable/">http://scikit-learn.org/stable/</a>）<br>最好的梯度提升库：xgboost（<a target="_blank" rel="noopener" href="https://github.com/dmlc/xgboost">https://github.com/dmlc/xgboost</a>）<br>对于神经网络：keras（<a target="_blank" rel="noopener" href="http://keras.io/">http://keras.io/</a>）<br>可视化数据：matplotlib（<a target="_blank" rel="noopener" href="http://matplotlib.org/">http://matplotlib.org/</a>）<br>监视进度：tqdm（<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/tqdm">https://pypi.python.org/pypi/tqdm</a>）</p>
<h1 id="机器学习框架"><a href="#机器学习框架" class="headerlink" title="机器学习框架"></a>机器学习框架</h1><p>2015年，我提出了一个自动机器学习框架，该框架目前仍在开发中，将于近期发布。在这篇文章中，相同的（基础）框架如下图所示：</p>
<p><img src="/images/ml-normal/2.png"></p>
<p>本图来自：A.Thakur和A.Krohn-Grimberghe，AutoCompete：机器学习竞赛框架，AutoMLWorkshop，2015年机器学习国际会议</p>
<p>在上面显示的框架中，粉红色的线代表最常用的路径。在我们提取并将数据缩减为表格格式后，我们可以继续构建机器学习模型。</p>
<p>第一步是确定问题，这可以通过查看标签来完成。必须知道问题是二分类、多分类、多标签分类还是回归问题。在我们确定问题后，我们将数据分成两个不同的部分，一个训练集和一个验证集，如下图所示。</p>
<p><img src="/images/ml-normal/3.png"></p>
<p>数据分解为训练集和验证集“必须”考虑标签类型。如果出现任何类型的分类问题，请使用分层分割。在python中，你可以很容易地使用scikit-learn。</p>
<p><img src="/images/ml-normal/4.png"></p>
<p>在回归任务的情况下，简单的K-Fold分割就足够了。然而，有些复杂的方法往往需要训练集和验证集保持相同的标签分布，这个问题将留给读者作为练习。</p>
<p><img src="/images/ml-normal/5.png"></p>
<p>上述示例中我已经选择全部数据的10％作为eval_size或验证集的大小，此值可以根据它们所具有的数据大小进行选择。</p>
<p>数据拆分完成后，请保留此数据不要动它。必须保存在训练集上应用的任何操作，然后将其应用于验证集。在任何情况下，验证集都不应该与培训集一起使用，这样做会产生非常好的评估分数并让用户感到满意，但是会构建一个严重过拟合的无用模型。</p>
<p>下一步是识别数据中的不同变量。我们处理的变量通常有三种类型，即数字变量、分类变量和包含文本的变量。让我们以流行的泰坦尼克号数据集（<a target="_blank" rel="noopener" href="https://www.kaggle.com/c/titanic/data%EF%BC%89%E4%B8%BA%E4%BE%8B%E3%80%82">https://www.kaggle.com/c/titanic/data）为例。</a></p>
<p><img src="/images/ml-normal/6.png"></p>
<p>在这里，survival就是标签，我们已经将标签从前一步中的训练数据中分离出来了。变量pclass、sex、embarke具有不同的级别，因此它们是分类变量。像age、sibsp、parch等变量是数值变量。name是一个包含文本数据的变量，但我不认为它是预测生存的有用变量。</p>
<p>首先对于数值变量，这些变量不需要任何类型的处理，因此我们可以直接对这些变量应用规范化和机器学习模型。</p>
<p>有两种方法可以处理分类数据：</p>
<ul>
<li>将分类数据转换为标签</li>
</ul>
<p><img src="/images/ml-normal/7.png"></p>
<ul>
<li>将标签转换为二元变量（one-hot编码）</li>
</ul>
<p><img src="/images/ml-normal/8.png"></p>
<p>请记住先使用LabelEncoder将类别转换为数字，然后再应用OneHotEncoder。</p>
<p>因为泰坦尼克号的数据没有文本变量的好例子，所以让我们制定处理文本变量的一般规则。我们可以将所有文本变量合并为一个，然后使用一些对文本数据起作用的算法并将其转换为数字。</p>
<p>文本变量可以如下连接在一起：</p>
<p><img src="/images/ml-normal/9.png"></p>
<p>我们可以在变量上使用CountVectorizer或TfidfVectorizer：</p>
<p><img src="/images/ml-normal/10.png"></p>
<p>或</p>
<p><img src="/images/ml-normal/11.png"></p>
<p>TfidfVectorizer大多数时候比CountVectorizer性能都要好， TfidfVectorizer使用以下参数在很多情况下都有效。</p>
<p><img src="/images/ml-normal/12.png"></p>
<p>如果您只在训练集上应用这些vectorizer，请确保将其转储到磁盘中，以便稍后在验证集上使用它。</p>
<p><img src="/images/ml-normal/13.png"></p>
<p>接下来，我们来到stacker模块，stacker模块不是模型堆垛器，而是特征堆垛器。上述处理步骤之后的不同特征可以使用堆叠器模块进行组合。</p>
<p><img src="/images/ml-normal/14.png"></p>
<p>在通过使用numpy hstack或sparsehstack 进行进一步处理之前，您可以水平堆叠所有特征，具体取决于您是否拥有稠密或稀疏的特征。</p>
<p><img src="/images/ml-normal/15.png"></p>
<p>如果还有其他处理步骤如PCA或特征选择（我们将在本文的稍后部分讲解分解和特征选择），也可以通过FeatureUnion模块实现。</p>
<p><img src="/images/ml-normal/16.png"></p>
<p>一旦将这些特征堆叠在一起，我们可以开始应用机器学习模型。在这个阶段，你应该选择的模型应该集成基于树的模型。这些模型包括：</p>
<ul>
<li>RandomForestClassifier</li>
<li>RandomForestRegressor</li>
<li>ExtraTreesClassifier</li>
<li>ExtraTreesRegressor</li>
<li>XGBClassifier</li>
<li>XGBRegressor</li>
</ul>
<p>我们不能将线性模型应用于上述特征，因为它们没有归一化。要使用线性模型，可以使用scikit-learn中的Normalizer或StandardScaler。</p>
<p>这些归一化方法仅适用于稠密特征，如果应用于稀疏特征则不会给出非常好的结果。但可以在不使用均值的情况下在稀疏矩阵上应用StandardScaler（参数：with_mean&#x3D; False）。</p>
<p>如果上述步骤给出了一个“好”的模型，我们可以去优化超参数，如果没有，我们需要继续下面的步骤并改进我们的模型。</p>
<p><img src="/images/ml-normal/17.png"></p>
<p>为了简单起见，我们将忽略LDA和QDA转换。对于高维数据，通常使用PCA来分解数据。对于图片以10-15个component开始，并且只要结果质量显着提高，就增加此数量。对于其他类型的数据，我们最初选择了50-60个component（只要我们能够处理得了数值数据，我们就倾向于避免PCA）。</p>
<p><img src="/images/ml-normal/18.png"></p>
<p>对于文本数据，在将文本转换为稀疏矩阵后，进行奇异值分解（SVD）。可以在scikit-learn中找到称为TruncatedSVD的SVD变体。</p>
<p><img src="/images/ml-normal/19.png"></p>
<p>通常用于TF-IDF或计数的SVD component的数量在120-200之间。以上任何数字都可能会提高性能，但不会实质性降低计算能力。</p>
<p>在进一步评估模型的性能之后，我们转向数据集的缩放，以便我们也可以评估线性模型。特征被归一化或缩放后可以被发送到机器学习模型或特征选择模块。</p>
<p><img src="/images/ml-normal/20.png"></p>
<p>有多种方法可以实现特征选择。最常见的方式之一是贪婪特征选择（向前或向后）。在贪婪特征选择中，我们选择一个特征，训练一个模型并根据固定评估指标评估模型的性能，我们一个接一个不断添加和删除特征，并在每一步记录模型的性能，最后我们选择评估得分最高的特征。以AUC作为评估指标的贪婪特征选择的一个实现可以在这里找到：https：&#x2F;&#x2F;github.com&#x2F;abhishekkrthakur&#x2F;greedyFeatureSelection。必须指出的是，这种实现并不完美，必须根据要求进行修改。</p>
<p>其他更快的特征选择方法包括从模型中选择最佳特征。我们既可以查看logit模型的系数，也可以训练一个随机森林来选择最佳特征，然后在其他机器学习模型中使用这些特征。</p>
<p><img src="/images/ml-normal/21.png"></p>
<p>请记住，要保持较少的estimator和最少的超参数优化，以免过拟合。</p>
<p>使用梯度提升(GradientBoosting )也可以实现特征选择。我们在scikit-learn中推荐使用xgboost而不是GBM的实现，因为xgboost更快更灵活。</p>
<p><img src="/images/ml-normal/22.png"></p>
<p>我们也可以使用RandomForestClassifier &#x2F; RandomForestRegressor和xgboost来进行稀疏数据集的特征选择。</p>
<p>从正稀疏数据集中选择特征的另一种流行方法是基于chi-2的特征选择，我们在scikit-learn中实现了这一功能。</p>
<p><img src="/images/ml-normal/23.png"></p>
<p>在这里，我们使用chi2和SelectKBest从数据中选择20个特征。这是我们想要优化以提高机器学习模型结果的超参数。</p>
<p>不要忘记导出在所有步骤中使用的任何种类的transformer，它们将被用于在验证集上的评估性能。</p>
<p>下一个（或中间）的主要步骤是模型选择+超参数优化。</p>
<p><img src="/images/ml-normal/24.png"></p>
<p>我们通常在选择机器学习模型的过程中使用以下算法：</p>
<ul>
<li><p><strong>分类</strong></p>
<ul>
<li>Random Forest</li>
<li>GBM</li>
<li>Logistic Regression</li>
<li>Naive Bayes</li>
<li>Support Vector Machines</li>
<li>k-Nearest Neighbors</li>
</ul>
</li>
<li><p><strong>回归</strong></p>
<ul>
<li>Random Forest</li>
<li>GBM</li>
<li>Linear Regression</li>
<li>Ridge</li>
<li>Lasso</li>
<li>SVR</li>
</ul>
</li>
</ul>
<p>我们应该优化哪些参数？如何选择趋近最佳的参数？这些是大多数人想到得到的几个问题。如果没有大量数据集上不同模型+参数的经验，就无法得到这些问题的答案，可能也有有经验的人不愿意分享他们的秘密。幸运的是，我也有相当多的经验，同时我愿意分享一些东西。</p>
<p>让我们分解超参数，使模型更智能：</p>
<p><img src="/images/ml-normal/25.png"></p>
<p>RS* &#x3D;不能说完全适当的值，随机搜索这些超参数。</p>
<p>严格地说我的观点是，上述模型将超越其他模型，我们不需要评估任何其他模型。</p>
<p>再次记住保存transformer：</p>
<p><img src="/images/ml-normal/26.png"></p>
<p>并将它们分别应用于验证集：</p>
<p><img src="/images/ml-normal/27.png"></p>
<p>上述规则和框架在我处理的大多数数据集中都表现得非常好。当然，对于非常复杂的任务也可能是失败的。没有什么是完美的，我们继续改进我们学到的东西，就像机器学习一样。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-09-29-ios-architecture-patterns/"><img class="fill" src="/images/iOSArchitecturePatterns/cover.jpeg" alt="浅谈iOS架构模式"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.104Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">1 小时读完 (大约7869个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-09-29-ios-architecture-patterns/">浅谈iOS架构模式</a></h1><div class="content"><p>每一个软件开发者在开始学习软件开发的时候，可能都不清楚软件的架构设计是什么样的，仅仅是依靠前人的方式进行代码开发的，至少本人是这样的。慢慢熟悉了软件开发后，对于软件代码如何更加合理的进行组织，以前的开发为什么是那样进行组织的便有了有些理解。其实这一切都是软件的架构模式。</p>
<p>对于iOS开发者来说，几乎每个人都熟悉应用程序的测试、代码的重构和通过视图控制器对业务进行支持等，但是如何合理的选用对当前产品业务更加合理的软件架构，往往会被忽略。这里针对当前业界常见的五种架构模式，进行详细的分析和试用，了解每种架构模式。</p>
<blockquote>
<p>架构模式并不是所有问题都适用的解决方案，它们仅仅描述了移动应用程序代码的组织方式和方法，具体的实现细节往往会跟随业务的变化而变化。</p>
</blockquote>
<p>在本文中，将介绍以下五种iOS端的通用架构模式：</p>
<ul>
<li>传统MVC</li>
<li>苹果的MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER</li>
</ul>
<h2 id="传统MVC"><a href="#传统MVC" class="headerlink" title="传统MVC"></a>传统MVC</h2><p>在70年代后期，Model、View、Controller的模式在编程语言Smalltalk-80中出现，随着时间的推移，人们对MVC有了许多不同的理解，尽管最初的想法逐渐被人们遗忘，但是MVC带给软件开发行业的巨大变化是有目共睹的，有必要好好了解一下最初的MVC以及相关的原理等。MVC最初要解决的问题是：<strong>将组件的职责明确划分为模型、视图、控制器。</strong></p>
<p><strong>模型：</strong> 一组封装特定主题领域数据及其验证算法的类。 在传统MVC中，模型还包含处理逻辑（“业务逻辑”）。 有两种类型的模型：主动模型和被动模型。 主动模型能够通知其状态的更改（通常是通过观察者模式）。 传统MVC实现被认为是主动模型，该模型对View和Controller一无所知，并且可以独立运行。 在测试中，此要求起着重要作用。</p>
<p><strong>视图：</strong> 负责（但不一定）显示数据的图形类。 在传统MVC中，仅在只读模式下，视图可以直接访问模型，视图不应直接更改模型的状态，状态的更改应该是控制器的职责。</p>
<p><strong>控制器：</strong> 直接和外部互动的组件，根据不同的外部行为，控制器会执行一些逻辑，包括但不限于改变模型的状态等，但是控制器不会直接对视图做出响应，也不会保持视图的状态，也就是说控制器并不是视图和模型的中间介质，也不负责将数据从模型输出到视图。</p>
<p><img src="/images/iOSArchitecturePatterns/classicMVC.png"></p>
<h3 id="传统MVC原理"><a href="#传统MVC原理" class="headerlink" title="传统MVC原理"></a>传统MVC原理</h3><p>在70年代，MVC模式基本上都是在具有实体按键的设备上应用的。一些外部按键事件，该事件和控制器进行交互，控制器决定如何处理该事件。例如，控制器可以更改模型的状态（一般是调用模型的方法），但是绝不能更改视图的状态，仅仅只有模型会直接影响视图。</p>
<p>如果模型的状态发生了更改，模型将通知视图进行相应的更改，并且视图应该读取新的模型数据，然后在必要时更新并重新绘制视图（视图观察者模型）。虽然MVC在控制台模式下成功完成了任务，但图形界面和鼠标或触摸变得越来越流行，用户现在可以直接与视图进行交互，并且视图会生成事件，从理论上讲，该事件应由Controller处理。 实际上传统的MVC已经发生了变化。</p>
<p>在图像界面时代，界面上将要显示各种样式的图形组件，开发人员的大部分任务演变成了建立各个小组件的层级结构并将事件从组件上重定向到所需的类，因此在现代开发中，可以认为视图是由小部件的不同层级结构构成的。</p>
<p>图形组件通常相对比较复杂。例如，UIKit库中的常用按钮（UIButton）可以为按钮的每种状态包含不同的文本（例如，“highlighted” –“处于突出显示状态”，以及“selected” –“处于选定状态”）。 您还可以设置每种状态的文本颜色，可以直接在可视编辑器中进行配置，也可以通过写代码的方式配置。</p>
<p>因此，按钮本身具有设置功能，并且本身也响应外部事件。 实际上，它包含自己的模型（所谓的View Model）和自己的Controller。 因此，当前程序更像是View，Controllers和Model的复杂层次结构。</p>
<h3 id="传统MVC的缺点"><a href="#传统MVC的缺点" class="headerlink" title="传统MVC的缺点"></a>传统MVC的缺点</h3><p>传统MVC的缺点之一是组件之间的强互连性，这使单元测试变得复杂。 在现代程序中，控制器，视图和视图模型的层次结构愈发复杂，它们被认为是基于MVC的应用程序，因此实际上无法进行单元测试。</p>
<p>另一个问题是业务模型的“增厚”。 为什么会这样呢？ 视图可以具有复杂的状态。 例如，文本输入框的输入字段验证的逻辑及其取决于验证结果的文本颜色的设置，此时视图的状态不能直接保存在视图模型的字段中，也不能在IDE中进行设置。</p>
<p>那么，在哪里“转移”这种状态呢？模型和控制器中可以吗？</p>
<p>在传统的MVC中，控制器不应保存视图的状态，因此这些复杂的状态需要在Model中实现。 因此，除了域模型之外，该模型还包括部分文本输入ViewModel。</p>
<h2 id="苹果MVC"><a href="#苹果MVC" class="headerlink" title="苹果MVC"></a>苹果MVC</h2><p>为了适应传统MVC并解决其缺点，苹果重新构建了MVC架构，实际上是在传统的MVC的基础上构建了<code>Cocoa</code>和<code>CocoaTouch</code>框架。 在苹果的MVC下，模型与传统MVC中的模型相同，并且是主动模型（即在观察者的帮助下通知其状态的变化）。</p>
<p>为此，在Cocoa和CocoaTouch框架中，可以方便地使用<code>NSNotificationCenter</code>和<code>KVO</code>，而不必了解其他组件。 视图也类似于来自MVC的视图（可以是组件的层次结构）。 为了减少类的互连性，View无法直接访问Model。</p>
<p><img src="/images/iOSArchitecturePatterns/appleMVC.png"></p>
<p>用户在视图上进行也写操作，视图既能自行处理一部分视图逻辑，也能够将一部分事件转发到控制器，由控制器决定处理事务并在必要时更改模型的状态。如果模型的状态发生了更改，将通知控制器，并由控制器决定如何处理这些更改。控制器的职责还有从模型中读取数据，必要的时候会对数据进行一些转换（以便于视图使用），并对视图进行新值设定等。</p>
<h3 id="优于传统MVC的优势"><a href="#优于传统MVC的优势" class="headerlink" title="优于传统MVC的优势"></a>优于传统MVC的优势</h3><p>在Apple的MVC模式下，视图和模型之间不再存在直接的连接，视图的状态和数据表示的处理逻辑也在控制器中，在当前情况下，这种职责分工更为合适。</p>
<p>这种模式的缺点是Controller包含View状态的一部分和几乎所有View逻辑，而且由于Controller还充当View和Model之间的中介者，因此它成为应用程序逻辑适应的一个非常着重的地方。 实际上，UIViweController类变得过于庞大。 通常，由于Controller和视图之间的紧密关系，它们被视为<code>表示层</code>的组成部分。</p>
<p><img src="/images/iOSArchitecturePatterns/betterClassicMVC.png"></p>
<blockquote>
<p><strong>查看逻辑</strong> : 一种与小部件层次管理，从一个场景到另一个场景的动画过渡，显示对话等相关的逻辑。</p>
<p><strong>表示逻辑</strong> : 与将域模型转换为可在View上显示的模型以及处理View中需要操纵域模型的事件相关的逻辑。 </p>
<p><strong>域逻辑</strong> : 在具有模型对象的模型级别上运行的基本逻辑。 域逻辑因此可以在另一个应用程序中重用。</p>
<p><strong>应用程序逻辑</strong> :特定应用程序中固有的逻辑。 这与域逻辑不同，它不能重复使用，因为它是特定于特定应用程序的并且是唯一的。</p>
</blockquote>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP（Model、View、Presenter）是MVC模式的进一步发展。 Controller由Presenter代替。 Presenter，与经典MVC中的Controller不同：</p>
<ul>
<li>保存视图的状态；</li>
<li>更改视图的状态；</li>
<li>处理视图的事件；</li>
<li>将域模型转换为ViewModel。</li>
</ul>
<p>Presenter与经典MVC中的Controller也有类似之处：</p>
<ul>
<li>拥有模型；</li>
<li>响应外部事件（通过调用适当的方法）更改模型的状态；</li>
<li>可能包含应用逻辑。</li>
</ul>
<p>MVP诞生于上世纪90年代初期的IBM。 与MVC一样，由于对其模式的不同解释，因此出现了多个版本。 马丁·福勒（Martin Fowler）定义了MVP的以下变化：</p>
<ul>
<li>演示模型</li>
<li>监督控制器</li>
<li>被动视图</li>
</ul>
<p>它们都是相似的，但主要取决于View和Presenter之间的连接以及View的更新顺序。 小部件的层次结构通常扮演视图的角色。 MVP中的模型与MVC中的模型没有什么不同。</p>
<h3 id="监督控制器"><a href="#监督控制器" class="headerlink" title="监督控制器"></a>监督控制器</h3><p>与MVC最接近的模式。 组件之间的相互作用如下图所示。</p>
<p><img src="/images/iOSArchitecturePatterns/mvp.png"></p>
<p>监督控制器视图：</p>
<ul>
<li>实现视图逻辑；</li>
<li>将事件转发给演示者；</li>
<li>与经典MVC中一样，观察模型（在数据绑定的帮助下或实现观察者模式）；</li>
<li>不会直接更改模型的状态；</li>
<li>可能需要从Presenter请求数据或读取模型。</li>
</ul>
<p>Presenter处理View的事件并更改Model的状态（通过调用适当的方法）。 与经典MVC中的Controller不同，如果无法借助数据绑定或Observer在Model与View之间建立连接的话，Presenter会保持并更改View的状态。</p>
<p>监督控制器的好处在于，视图状态现在位于Presenter中（而不是在Model中）。 Presenter处理演示逻辑，因此View和Model变得“更薄”。 缺点是View严重依赖Model和Presenter，这极大地使单元测试复杂化。</p>
<h3 id="展示模型"><a href="#展示模型" class="headerlink" title="展示模型"></a>展示模型</h3><p>移除了监督控制器缺点的MVP，该结构进一步开发了视图与模型之间的连接。 组件之间的交互方案是：</p>
<p><img src="/images/iOSArchitecturePatterns/mvp2.png"></p>
<p><strong>View：</strong></p>
<ul>
<li>负责视图逻辑；</li>
<li>将所有事件重定向到Presenter；</li>
</ul>
<p>与经典的MVC和Supervision Controller不同，View无法直接访问模型。 </p>
<p><strong>Presenter：</strong></p>
<ul>
<li>将视图的状态移动到单独的Presentation Model中，作为Presenter的一部分；</li>
<li>交互并提供与域模型的接口（即，视图的外观）；</li>
<li>观察模型状态的变化；</li>
<li>提供一个公共接口，View可以使用该接口与Presenter进行交互。</li>
</ul>
<h3 id="该方案的工作原理如下："><a href="#该方案的工作原理如下：" class="headerlink" title="该方案的工作原理如下："></a>该方案的工作原理如下：</h3><p>视图中有一个事件，View可以尝试自行处理它，并向Presenter请求数据。 如果View无法处理该事件，它将把该事件委托给Presenter，Presenter决定如何处理该事件。 如有必要，Presenter可以更改模型的状态。 该模型将其状态更改反向通知给Presenter，Presenter读取模型的新值，如有必要，对它们执行附加逻辑并更新视图。</p>
<p>该模型相对于Supervision Controller的优势在于，视图与模型没有任何关系，这有利于单元测试。 缺点包括需要创建其他接口（至少对于View和Presenter而言）以及在View中进行更新的逻辑，这并不能大大简化测试。</p>
<h3 id="Humble-View"><a href="#Humble-View" class="headerlink" title="Humble View"></a>Humble View</h3><p>Humble View和Presentation模型之间的区别在于视图及其状态如何更新。 视图变为被动，MVP的先前版本没有对View施加限制，它可能会向Presenter询​​问一些数据。 在这种情况下，被动视图受到限制，它不再向Presenter询问任何数据。</p>
<p>视图状态的任何更改均由Presenter执行。 视图不知道Presenter或Model的存在。 View的无源性最多可以简化单元测试。 与每种架构模式一样，组件之间的关系也有很多问题。 最常见的：</p>
<ul>
<li>谁拥有MVP中的View和Presenter？</li>
</ul>
<p>视图通常具有对Presenter的强烈引用。 反过来，Presenter对模型有很强的引用，而对View则无能为力。 与经典MVC中一样，该模型对View和Presenter一无所知。</p>
<ul>
<li>谁创建View和Presenter？</li>
</ul>
<p>可以认为，视图是由Presenter创建的。 但是，Presenter需要一个模型，即创建Presenter的视图必须通过模型进行配置，并且在此之后，她知道模型的存在。 此顺序不适合我们，因为我们正在尝试使组件之间的连接性达到最小（以实现更轻松的测试和更大的灵活性）。</p>
<p>因此，如果下一个View Presenter是由另一个Presenter创建的，或者是在单独的Router类中创建的，则更好（后者也可能参与下一个View的配置和创建）。 但是，没有明确的规则。</p>
<h2 id="iOS-MVP"><a href="#iOS-MVP" class="headerlink" title="iOS MVP"></a>iOS MVP</h2><p>经过一些理论，我们可以进行实际的发展。 一个典型的iOS应用程序是围绕一个中央UIViewController类构建的，该类承担着许多责任，因此放置UI逻辑和应用程序逻辑的一部分是最有吸引力的地方。 但是，我们在上面提到，由于View和Controller之间的紧密结合（在iOS UIViewController和UIView的上下文中），将它们视为View很方便。</p>
<p><img src="/images/iOSArchitecturePatterns/iosmvp.png"></p>
<p>例如，让我们考虑一个包含两个场景的简单应用程序。 它允许您使用REST服务 <a target="_blank" rel="noopener" href="http://random.cat/meow">http://random.cat/meow</a> 从Internet上加载猫的随机照片（“加载猫场景”） ，在猫的图片上应用内置照片滤镜，然后保存编辑后的照片（“编辑猫”现场）。</p>
<p>您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVP_Sample</p>
<p>加载照片时，“加载猫场景视图”会显示活动指示器，实际加载的照片和图片的URL。 演示者将借助“最小”界面LoadCatViewProtocol与“加载猫场景视图”进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateLoadingState</span>(<span class="keyword">_</span> <span class="params">loadingState</span>: <span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateTitle</span>(<span class="keyword">_</span> <span class="params">imageTitle</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> view: <span class="type">LoadCatViewProtocol</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isLoading: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> image: <span class="type">Data</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageTitle: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">installView</span>(<span class="keyword">_</span> <span class="params">view</span>: <span class="type">View</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view <span class="operator">=</span> view <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>() &#123;</span><br><span class="line">        view.updateLoadingState(isLoading)</span><br><span class="line">        view.updateTitle(imageTitle)</span><br><span class="line">        view.updateImage(image)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isLoading <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        image <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        imageTitle <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">        updateUI()</span><br><span class="line">        loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载猫场景允许您开始加载和取消它，还可以转到下一个场景进行图像编辑。 这些事件由用户启动，并且View只是将它们重定向到Presenter，调用其方法。 视图通过协议LoadCatPresenterProtocol与Presenter进行交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatPresenterProtocol</span>: <span class="title class_">Presenter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">load</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">updateUI</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> catProvider: <span class="type">CatProvider</span>! &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actCancel</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        presenter.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">setPresenter</span>(<span class="keyword">_</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter <span class="operator">=</span> presenter <span class="keyword">as!</span> <span class="type">LoadCatPresenterProtocol</span></span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的测试项目中，无需Router类即可过渡到下一个场景。</p>
<ul>
<li>要将负载猫场景切换到编辑猫场景，您需要按编辑。</li>
<li>LoadCatViewController将此事件重定向到LoadCatPresenter。</li>
<li>LoadCatViewController不知道此事件会启动转换。</li>
<li>LoadCatPresenter创建EditCatPresenter并使用必要的模型对其进行配置。</li>
<li>要显示下一个场景，LoadCatPresenter调用LoadCatViewController showEditScene的方法并在此处传递EditCatPresenter。</li>
<li>LoadCatViewController创建下一个视图，将其与接收的Presenter连接并显示。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatViewProtocol</span>: <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actEdit</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIBarButtonItem</span>) &#123;</span><br><span class="line">        loadButton.isEnabled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        editCat()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> nextViewController <span class="operator">=</span> storyboard<span class="operator">!</span>.instantiateViewController(withIdentifier: <span class="type">Constants</span>.editCatViewControllerStoryboardId) <span class="keyword">as!</span> <span class="type">View</span></span><br><span class="line">        presenter.installView(nextViewController)</span><br><span class="line">        nextViewController.setPresenter(presenter)</span><br><span class="line">        present(nextViewController <span class="keyword">as!</span> <span class="type">UIViewController</span>, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一个场景，则可以按照Apple的所有原则在UIApplicationDelegate中执行此配置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> window<span class="operator">?</span>.rootViewController <span class="keyword">as!</span> <span class="type">LoadCatViewProtocol</span></span><br><span class="line">        <span class="keyword">let</span> presenter <span class="operator">=</span> <span class="type">LoadCatPresenter</span>()</span><br><span class="line">        presenter.catProvider <span class="operator">=</span> catProvider</span><br><span class="line">        presenter.installView(view)</span><br><span class="line">        view.setPresenter(presenter)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>尽管MVP具有很多优点，但由于IDE开发和框架，它不适合自动化应用程序开发，需要“手动”工作。 下一个模式应该可以解决这些问题。 MVVM（Model、View、ViewModel）由Microsoft Ken Cooper和Ted Peters的工程师开发，并由John Gossman在2005年的博客中宣布。</p>
<p>该模式的目的是将用户界面与开发以及业务逻辑开发分开，并使用WPF和Silverlight平台的主要功能来促进应用程序测试。 尽管专业化模式是针对Microsoft技术构想的，但可以在Cocoa &#x2F; CocoaTouch框架中使用。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvm.png"></p>
<p>MVVM源自MVC模式，由以下3个组件组成：模型，视图，视图模型。 模型与MVP和MVC中的模型不同：</p>
<ul>
<li>它是一个领域模型；</li>
<li>包括数据，业务逻辑和验证逻辑；</li>
<li>不依赖于其他组件（ View 和 ViewModel ）。</li>
</ul>
<p><strong>View：</strong></p>
<ul>
<li>确定用户界面（如MVP，Apple MVC）的结构，位置和外观；</li>
<li>具有View的逻辑：动画、View与子View的操作之间的过渡等；</li>
<li>保持对ViewModel的强烈引用，但对Model一无所知；</li>
<li>监视ViewModel并使用数据绑定或直接引用它进行通信。</li>
</ul>
<p>为了避免View与ViewModel之间的牢固关系，需要创建一个接口，View将通过该接口与ViewModel进行通信。 ViewModel是视图和模型之间的中介者，并负责表示逻辑的处理。</p>
<p><strong>ViewModel：</strong></p>
<ul>
<li>保持View的状态；</li>
<li>了解模型并可以更改其状态（适当类的调用方法）；</li>
<li>将模型中的数据转换为对视图更方便的格式；</li>
<li>验证来自视图的数据；</li>
<li>不了解View，只能通过数据绑定机制与View交互。</li>
</ul>
<p>在Cocoa中有其自己的数据绑定机制，但在CocoaTouch中则没有。 我们只能用KVO来做，但是这个东西不方便使用，只允许您实现单边绑定。 反过来，数据绑定使实现MVVM固有的全部潜力成为可能，并总体上促进了开发。 因此，应该使用一些提供与CocoaTouch的数据绑定或响应式编程的第三方库。</p>
<p>MVVM和MVP中的UIViewController被视为View的一部分。</p>
<p><img src="/images/iOSArchitecturePatterns/mvvmcocoa.png"></p>
<p>从苹果的MVC到MVVM的过渡过程中出现了一个重要的问题：如何实现导航？ 如上所述，视图直接执行到其他视图的过渡。 因此，有两种方法可以进行过渡：</p>
<ul>
<li>最简单的一种是从View启动过渡时。 在这种情况下，当前场景的ViewModel会创建下一个场景的ViewModel（如果需要，可以通过模型对其进行配置）。 然后，View创建下一个场景的View，将新的ViewModel传递给它，然后执行过渡。 </li>
<li>过渡从ViewModel启动。 由于ViewModel对View一无所知，因此无法进行过渡。 在这种情况下，需要一个特殊的组件-路由器-它知道视图的层次结构以及如何进行转换。 ViewModel可以将下一场景的ViewModel或模型传递给路由器。 路由器处理其他所有事务。</li>
</ul>
<p>因此，MVVM和MVP（低视角）在Presentation层（在MVP中由Presenter呈现，在MVVM中由ViewModel呈现）差异很大。 MVVM优于MVP（Humble View）的优点是Presentation层完全独立于View（意味着更容易测试）和DataBinding的使用。 总之，它成为在现代IDE中使用的更具吸引力的候选者，并减少了将View与ViewModel同步的代码量。</p>
<p>MVVM的缺点主要在于数据绑定机制，因为在某些情况下，它可能需要大量的内存资源，并且也是内存泄漏出现的薄弱环节。 接下来，我们将考虑上一节中描述的应用程序示例，但使用MVVM模式。 您可以在此处下载示例应用程序： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_MVVM_Sample</p>
<p>应用程序和模型（Cat，CatProvider）的用户界面相同。 它们仅在表示逻辑上有所不同，这将是主要重点。 View组件由LoadCatViewController和EditCatViewController呈现。 LoadCatViewController通过以下接口与LoadCatViewModel进行交互：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">CatViewModelProtocol</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> isLoading: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isEditable: <span class="type">Observable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">Observable</span>&lt;<span class="type">String</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> imageData: <span class="type">Observable</span>&lt;<span class="type">Data</span>?&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> editCatViewModel: <span class="type">EditCatViewModelProtocol</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadNextCat</span>()</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelCurrentDownloading</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCatViewModel包含一组用于定义LoadCatViewController的状态的功能，以及一组与用户可以执行的操作相对应的方法。 对于数据绑定机制，我们使用 Bond 。 由于Load Cat是初始场景，因此很明显，它的配置是在AppDelegate中执行的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AppDelegate</span>: <span class="title class_">UIResponder</span>, <span class="title class_">UIApplicationDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> catProvider <span class="operator">=</span> <span class="type">CatProvider</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">didFinishLaunchingWithOptions</span> <span class="params">launchOptions</span>: [<span class="params">UIApplicationLaunchOptionsKey</span>: <span class="keyword">Any</span>]<span class="operator">?</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> catViewModel <span class="operator">=</span> <span class="type">CatViewModel</span>(catProvider: catProvider)</span><br><span class="line">        (window<span class="operator">?</span>.rootViewController <span class="keyword">as?</span> <span class="type">CatViewController</span>)<span class="operator">?</span>.viewModel <span class="operator">=</span> catViewModel</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与MVP一样，配置Edit Cat场景分别在View和ViewModel中进行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">prepare</span>(<span class="params">for</span> <span class="params">segue</span>: <span class="type">UIStoryboardSegue</span>, <span class="params">sender</span>: <span class="keyword">Any</span><span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> editCatViewController <span class="operator">=</span> segue.destination <span class="keyword">as?</span> <span class="type">EditCatViewController</span> &#123;</span><br><span class="line">            editCatViewController.viewModel <span class="operator">=</span> viewModel.editCatViewModel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用Segue机制的LoadCatViewController创建EditCatViewController。</li>
<li>然后，在prepareForSegue方法中，LoadCatViewController询问LoadCatViewModel下一个场景的已配置ViewModel，即包含当前Cat模型的EditCatViewModel。</li>
<li>此外，我们将此EditCatViewModel传递给EditCatViewController。</li>
<li>单元测试是ViewModel和Model中的应用程序测试。 在测试项目中，您将找到单元测试的示例。</li>
</ul>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>在上面描述的架构中，如果尝试将体系结构划分为多个层，则使用Presenter或View Model可能会遇到困难。 它们属于哪一层？ 这个问题没有明确的答案：您可以为Presenter引入一个单独的Presentation层，或者它可以属于Application Logic。 MVVM也一样。 这种歧义造成了另一个问题。</p>
<p>将应用逻辑与域模型逻辑分开是非常困难的。 因此，通常没有分隔并且位于同一层。 此外，Presenter中存在应用程序逻辑有时会使很难测试不同的用例。 以前的体系结构中的另一个问题是组装和导航。 在数十个场景的大型项目中，很明显，这是由单独的模块路由器负责的。</p>
<p>2012年 发表 了一篇非凡的文章 。 清洁建筑以及有关该主题的几篇演讲。 后来，在Mutual Mobile中，我们为iOS做了一些修改，并进入了VIPER的新模式。 它 是View，Interactor，Presenter，Entity，Router的缩写，它们是构成应用程序的基本组件。 在下面查看他们如何互动。</p>
<p><img src="/images/iOSArchitecturePatterns/VIPER.png"></p>
<p><strong>View：</strong></p>
<p>与MVP（被动视图）一样，它是来自Presenter的数据的可视化。 View通过高于UI类级别的协议与Presenter通信。 演示者不知道构成视图层次结构的特定类。 要在View和Presenter之间共享数据，可以使用单独的结构（即，没有方法可以更改其状态的类）。 只有View和Presenter知道这些类。</p>
<p><strong>Presenter：</strong> 与MVP中的功能相同，不同之处在于它不应包含应用程序逻辑。 我们主要让Presenter参与数据转换。</p>
<p><strong>Interactor：</strong> 这些对象封装了应用程序的单独用例（我们将其称为应用逻辑）。 交互器与演示者和模型一起使用。 Interactor永远不会将属于模型层的对象类传递给Presenter。 因此，演示者不依赖于模型。 而且，他不知道该模型的存在。</p>
<p><strong>Model：</strong> 与以前的模式相同。 对于方向模型，只有交互器起作用。 该模型不知道其他组件的存在。 模型层可能包含各种管理器（用于创建或保留实体）和封装数据处理算法的对象。</p>
<p><strong>Entity：</strong> 实体是仅包含数据且不包含其处理方法的PONSO（普通的NSObject）对象（例如，其所有属性均为只读，并且NSManagerObject类的对象不能脱离模型层的边界）。</p>
<p><strong>Routing：</strong> 线框和演示者负责VIPER中的导航。</p>
<p>演示者接收视图的事件并知道如何响应它们。 但是Presenter对View的层次结构一无所知，并且包含View Logic（场景之间的动画切换– View Logic示例），并且无法在场景之间切换。</p>
<p>在这里，它将需要Wireframe（一个包含对UIWindow的引用的对象），可以创建View &#x2F; UIViewController并知道如何将它们放入View层次结构中。 同样，线框是诸如场景之间的自定义过渡之类的事务处理的理想位置。 例如，让我们考虑一个测试项目的VIPER版本，上面已针对MVP进行了描述。</p>
<p>您可以在此处下载示例代码： https : &#x2F;&#x2F;github.com&#x2F;thinkmobiles&#x2F;CatApp_VIPER_Sample</p>
<p>在项目的MVP和VIPER版本中比较LoadCatView的协议。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> imageTitle: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">Data</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> showEditScene(withPresenter presenter: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishedEdit()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatViewProtocol: </span><span style="font-weight: 400;">View</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateLoadingState(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> loadingState: </span><span style="font-weight: 400;">Bool</span><span style="font-weight: 400;">)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateTitle(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> title: </span><span style="font-weight: 400;">String</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateImage(</span><span style="font-weight: 400;">_</span><span style="font-weight: 400;"> image: </span><span style="font-weight: 400;">UIImage</span><span style="font-weight: 400;">?)</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> finishEditing()</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>



<p>它们仅在方法上有所不同</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">showEditScene</span>(<span class="params">withPresenter</span> <span class="params">presenter</span>: <span class="type">Presenter</span>) </span><br></pre></td></tr></table></figure>

<p>因为就VIPER而言，新场景或对话显示是线框的职责。 因此，两个项目的LoadCatViewProtocol实现几乎相同。 比较MVP和VIPER项目的LoadCatPresenter。</p>
<table>
<tbody>
<tr>
<td><strong>MVP</strong></td>
<td><strong>VIPER</strong></td>
</tr>
<tr>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">ar</span><span style="font-weight: 400;"> catProvider: </span><span style="font-weight: 400;">CatProvider</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
<td><span style="font-weight: 400;">protocol</span><span style="font-weight: 400;"> LoadCatPresenterProtocol: </span><span style="font-weight: 400;">Presenter</span><span style="font-weight: 400;"> {</span><p></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> load()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> cancel()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> updateUI()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">func</span><span style="font-weight: 400;"> edit()</span></p>
<p><span style="font-weight: 400;"> &nbsp;&nbsp;&nbsp;</span><span style="font-weight: 400;">var</span><span style="font-weight: 400;"> loadCatInteractor: </span><span style="font-weight: 400;">LocadCatInteractor</span><span style="font-weight: 400;">! { </span><span style="font-weight: 400;">get</span> <span style="font-weight: 400;">set</span><span style="font-weight: 400;"> }</span></p>
<p><span style="font-weight: 400;">}</span></p></td>
</tr>
</tbody>
</table>

<p>它们之间的区别不是很大。 该项目的MVP版本包含一个变量catProvider，该变量引用了Model层。 在项目的VIPER版本中，Presenter不必依赖于Model层。</p>
<p>由于通过按下按钮加载图片是一个用例（或应用程序逻辑），因此要实现功能，需要一个Interactor（可变loadCatInteractor）。 通常，交互器具有输入（演示者可以通过其与之交互的接口）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorInput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loadCat</span>() </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancelLoad</span>() </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>和与演示者交互的输出</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">LoadCatInteractorOutput</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>因此，通过按下按钮加载猫图片处理如下所示</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatViewController</span>: <span class="title class_">UIViewController</span>, <span class="title class_">LoadCatViewProtocol</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">LoadCatPresenterProtocol</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@IBAction</span> <span class="keyword">func</span> <span class="title function_">actLoad</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">UIButton</span>) &#123;</span><br><span class="line">        presenter.load()</span><br><span class="line">    &#125;</span><br><span class="line">. . . </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">LoadCatInteractorOutput</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> loadCatInteractor: <span class="type">LocadCatInteractor</span>!</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">load</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Some code to prepare UI</span></span><br><span class="line">        loadCatInteractor.loadCat()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MARK: LoadCatInteractorOutput</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatURL</span>(<span class="keyword">_</span> <span class="params">catURL</span>: <span class="type">NSURL</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the URL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didLoadCatImage</span>(<span class="keyword">_</span> <span class="params">image</span>: <span class="type">Data</span>?, <span class="params">success</span>: <span class="type">Bool</span>, <span class="params">cancelled</span>: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="comment">// Show the image</span></span><br><span class="line">    &#125;</span><br><span class="line">    . . . </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交互器和模型层之间的交互。 模型层由CatProvider和Cat类表示。 由于它很原始，因此对于交互器和模型之间的数据交换，我们没有创建实体类。</p>
<p>让我们考虑在场景之间切换。 正如我们上面提到的，在VIPER项目中，这是线框的责任。 如果下一个场景需要上一个场景的某些数据，则可以将它们传递到线框中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoadCatPresenter</span>: <span class="title class_">LoadCatPresenterProtocol</span>, <span class="title class_">EditCatPresenterDelegate</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">edit</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: <span class="keyword">self</span>.image<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">let</span> editCatPresenter <span class="operator">=</span> <span class="type">EditCatPresenter</span>()</span><br><span class="line">        editCatPresenter.delegate <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        editCatPresenter.image <span class="operator">=</span> image<span class="operator">!</span></span><br><span class="line">        </span><br><span class="line">        view.showEditScene(withPresenter: editCatPresenter)</span><br><span class="line">    &#125;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，不再将Seguey机制用于场景之间的过渡是不方便的，但是也不是拒绝使用UIStoryboard这样的便捷机制处理场景的理由。 这里的场景将没有Seguey。</p>
<p>一个普通的VIPER项目包含许多您需要配置的模块。 对于我们的简单示例，在应用程序启动时使用单独的Dependencies类就足够了。 但是，在复杂的项目中，更容易使用其他解决方案或库。</p>
<p><strong>测试:</strong> VIPER项目的测试与MVP相似，不同之处在于将应用逻辑交付到单独的类–交互器中。 一方面，您必须编写更多用于单元测试的代码，另一方面，还需要针对单个功能测试（用户案例）使用更简单的算法。 在我们的测试项目中，您将找到所有VIPER项目的单元测试示例。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们研究了可用于开发iOS应用程序的体系结构模式的演变。 进化链中的每个模式都改进了前一个模式。 明确了组件之间的界限及其职责（如有必要，引入了新的层或组件），这有助于开发和支持。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://thinkmobiles.com/blog/ios-architecture-patterns/">iOS architecture patterns: A guide for developers</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/ios-architecture-patterns">iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/61a656431685">iOS的MVP设计模式</a></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/"><img class="fill" src="/images/lightweight-api/cover.jpg" alt="Swift语言中的轻量级API设计"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span><span class="level-item">22 分钟读完 (大约3270个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-11-28-lightweight-api-design-in-swift/">Swift语言中的轻量级API设计</a></h1><div class="content"><p>Swift语言自诞生以来，总是或多或少受到人们的非议，新生的编程语言难免有些不够尽善尽美，但是哪种编程语言是尽善尽美的呢？OC语言算得上是一种古老的面向对象语言了，发展至今，其版本仍处于2.0，但是Apple为了让其看起来强大一点，增加了很多特性，例如Block、instancetype等等，但是其核心的语法变化并不大。</p>
<p>截止目前，Swift的版本已经迭代到5.*，整个ABI也已经稳定，每一次迭代更新，总是会带来一些漂亮的设计模式实践，例如在如何设计API方面，给开发者带来了舒适而强大的枚举、扩展和协议等，不仅让开发者对于函数的定义有了更清晰的认识，而且对于构建API而言，第一印象往往是轻量的，同时，仍会根据需要逐步显现出更多的功能，以及底层的复杂性。</p>
<p>在本篇文章里，将尝试创建一些轻量级的API，以及如何使用API组合的力量使得功能或者系统更加强大等。</p>
<h2 id="功能和易用性之间的较量"><a href="#功能和易用性之间的较量" class="headerlink" title="功能和易用性之间的较量"></a>功能和易用性之间的较量</h2><p>通常，当我们设计API时，会在数据结构和函数功能的相互交互上，寻找一个相对平衡的方式，最终构建出在功能上满足需求，数据结构尽量简单的API。但是，让API过于简单，可能它们又不够灵活，无法使功能有不断发展的潜力，然而，太过复杂的设计又难免导致开发工作复杂而无章法，容易造成开发者挫败，逻辑混乱而且API也难以使用，最终可能会导致延期甚至失败。</p>
<p>例如，一款应用程序的主要功能是对用户选择的图像应用不同的滤镜效果。每一种滤镜的核心其实都是一组图像变换的组合，不同的变换组合形成不同的滤镜效果。假设使用<code>ImageFilter</code> 结构体作为图像滤镜的定义，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">Icon</span></span><br><span class="line">    <span class="keyword">var</span> transforms: [<span class="type">ImageTransform</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageTransform</code>是图像变换的统一入口，因为可能会由多种不同的变换，因此可以将其定义为一个<code>protocol</code>，然后由实现单独变换操作的各种变换类型所遵循：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortraitImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> zoomMultiplier: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GrayScaleImageTransform</span>: <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> brightnessLevel: <span class="type">BrightnessLevel</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述设计方式的优势在于，由于每种转换都是按照自己的类型实现的，因此在使用时可以自由地让每种变换类型定义自己所需的属性和参数。例如<code>GrayScaleImageTransform</code> 接受 <code>BrightnessLevel</code>参数，以将图像转换为灰度图像。</p>
<p>然后，可以根据需要组合任意数量的图像变换类型，以形成不同类型的滤镜效果。例如，通过一系列的转换使得图像具有某种“戏剧性”外观的滤镜：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>, icon: .drama, transforms: [</span><br><span class="line">        <span class="type">PortraitImageTransform</span>(zoomMultiplier: <span class="number">2.1</span>),</span><br><span class="line">        <span class="type">ContrastBoostImageTransform</span>(),</span><br><span class="line">        <span class="type">GrayScaleImageTransform</span>(brightnessLevel: .dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So far so Good.  但是回头重新审视上述API的实现，可以肯定的说，上述实现仅仅是为了功能的实现，在API的易用性方面并没有优势，那么该如何进行优化，来保证功能的同时，提高API的灵活性和易用性呢？在上述实现中，每个图像的变换都是作为单独的类型实现的，因此没有一个可以对所有变换类型一目了然的地方，使用者难以清楚该代码库都包含哪些图像变换的类型。</p>
<p>为了解决外部使用者无法得知软件库所支持的变换类型，假设使用<strong>枚举</strong>的方式代替上述方式，来观察哪种方式更能够体现API的简洁明了以及使用上的清晰易用？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> protrait(<span class="keyword">_</span> zoomMultiplier: <span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> grayScale(<span class="keyword">_</span> brightnessLevel: <span class="type">BrightnessLevel</span>)</span><br><span class="line">    <span class="keyword">case</span> contrastBoost</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举的好处既能够提高代码的整洁程度和可读性，也使得API更加的灵活易用，因为在枚举的使用上，开发者可以直接使用点语法构造任意数量的转换，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .protrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>截止目前，枚举都是很漂亮的一个工具，在很多情况下Swift的枚举类型都能够提供良好的解决方式，但是枚举也有其明显的弊端。</p>
<p>就上述例子来说，由于每个转换都需要执行截然不同的图像操作，因此在这种情况下使用枚举将迫使我们编写一个庞大的<em>switch</em>语句来处理这些操作中的每一项, 这可能会造成代码的冗长繁琐等。</p>
<h2 id="枚举虽轻，结构体更优"><a href="#枚举虽轻，结构体更优" class="headerlink" title="枚举虽轻，结构体更优"></a>枚举虽轻，结构体更优</h2><p>幸运的事，针对上述问题，我们还有第三种选择 — 一种目前算是两全其美的方案。相较于协议或者枚举，结构体是一个既能够定义操作类型，还能够封装给定各种操作的闭包的数据结构。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> closure: (<span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>(<span class="params">to</span> <span class="params">image</span>: <span class="type">Image</span>) <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure(image)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>apply(to:)</code> 方法在这里并不应该被外部调用，这里写出来是为了代码的美观性以及代码的向前兼容。在实际项目开发中，这里可以使用宏定义区分。</p>
</blockquote>
<p>完成上述操作后，我们现在可以使用<strong>静态工厂方法</strong>和属性来创建我们的转换 — 每个转换仍可以单独定义并具有自己的一组参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageTransform</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> contrastBoost: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">portrait</span>(<span class="keyword">_</span> <span class="params">multiplier</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">grayScale</span>(<span class="keyword">_</span> <span class="params">brightness</span>: <span class="type">BrightnessLevel</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageTransform</span> &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>在 Swift 5.1 中，可以将<strong>Self</strong>用作静态工厂方法的返回类型。</p>
</blockquote>
<p>上面方法的优点在于，我们回到了将ImageTransform定义为协议时所具有的灵活性和功能性，同时仍保持了与定义为枚举时的调用方式 — 点语法一致，保证了易用性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dramaticFilter <span class="operator">=</span> <span class="type">ImageFilter</span>(</span><br><span class="line">    name: <span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">    icon: .drama,</span><br><span class="line">    transforms: [</span><br><span class="line">        .portrait(<span class="number">2.1</span>),</span><br><span class="line">        .contrastBoost,</span><br><span class="line">        .grayScale(.dark)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>点语法本身与枚举无关，但是其可以与任何静态API一起使用，这点对于开发者而言非常友好。使用点语法可以将上述的几个滤镜的创建和建模构造成静态属性，使得我们能够进一步的封装特性等。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ImageFilter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> dramatic: <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">ImageFilter</span>(</span><br><span class="line">            name:<span class="string">&quot;Dramatic&quot;</span>,</span><br><span class="line">            icon: .drama,</span><br><span class="line">            transforms: [</span><br><span class="line">                .portrait(<span class="number">2.1</span>),</span><br><span class="line">                .contrastBoost,</span><br><span class="line">                .grayScale(.dark)</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述改造，一系列复杂的任务 — 包括图像滤镜和图像转换 – 封装到一个API中，在使用上，可以像传值给函数一样轻松。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> image.withFilter(.dramatic)</span><br></pre></td></tr></table></figure>

<p>上述一系列的改造可以成为为类型构造<strong>语法糖</strong>。不仅改善了API读取的方式，还改善了API的组织方式，由于所有的转换和滤镜现在只需要进行传单一的值即可，因此在可扩展性方面来说，能够组织多种方式，不仅使得API轻巧灵活，对于使用者来说也简洁明了。</p>
<h2 id="可变参数与API设计"><a href="#可变参数与API设计" class="headerlink" title="可变参数与API设计"></a>可变参数与API设计</h2><p>接下来我们一起看看Swift语言的另一个特性 — 可变参数，以及可变参数如何影响API设计中的代码构建的。</p>
<p>假设正在开发一个使用基于形状的绘图来创建其用户界面的应用程序，并且我们已经使用了与上述类似的基于结构的方法来对每种形状进行建模，并最终将结果绘制到了<code>DrawingContext</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> drawing: (<span class="keyword">inout</span> <span class="type">DrawingContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面使用<strong>inout</strong>关键字来启用值类型（DrawingContext）的传递。</p>
</blockquote>
<p>类似我们在上面例子中使用静态工厂方法轻松创建<code>ImageTransform</code>一样，在这里也能够将每个形状的绘图代码封装在一个完全独立的方法中，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">at</span> <span class="params">point</span>: <span class="type">Point</span>, <span class="params">sideLength</span>: <span class="type">Double</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> origin <span class="operator">=</span> point.movedBy(</span><br><span class="line">                x: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span>,</span><br><span class="line">                y: <span class="operator">-</span>sideLength <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            context.move(to: origin)</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(x: sideLength, y: sideLength))</span><br><span class="line">            context.drawLine(to: origin.movedBy(y: sideLength))</span><br><span class="line">            context.drawLine(to: origin)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于将每个形状简单地建模为一个属性值，因此绘制它们的数组变得非常容易-我们要做的就是创建一个<strong>DrawingContext</strong>实例，然后将其传递到每个形状的闭包中以构建最终图像：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context <span class="operator">=</span> <span class="type">DrawingContext</span>()</span><br><span class="line">    </span><br><span class="line">    shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">        context.move(to: .zero)</span><br><span class="line">        shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> context.makeImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上面的函数看起来也很优雅，因为我们再次可以使用点语法来大大减少执行工作所需的语法量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw([</span><br><span class="line">    .circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">    .square(at: point, sideLength: <span class="number">5</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>但是，让我们看看是否可以使用可变参数来使事情更进一步。虽然不是Swift独有的功能，但结合Swift真正灵活的参数命名功能后，使用可变参数可以产生一些非常有趣的结果。</p>
<p>当参数被标记为可变参数时（通过在其类型中添加<code>...</code>后缀），我们基本上可以将任意数量的值传递给该参数 — 编译器会自动为我们将这些值组织到一个数组中，例如这个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">shapes</span>: <span class="type">Shape</span>...) -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="comment">// Within our function, &#x27;shapes&#x27; is still an array:</span></span><br><span class="line">    shapes.forEach &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述更改后，我们现在可以从对draw函数的调用中删除所有数组文字，而使它们看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.circle(at: point, radius: <span class="number">10</span>),</span><br><span class="line">                 .square(at: point, sideLength: <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>这看起来似乎不是很大的变化，但是尤其是在设计旨在用于创建更多更高级别值（例如我们的draw函数）的更低级别的API时，使用可变参数可以使这类API感觉更轻巧和方便。</p>
<p>但是，使用可变参数的一个缺点是，预先计算的值数组不能再作为单个参数传递。值得庆幸的是，在这种情况下，可以通过创建一个特殊的组形状（就像draw函数本身一样），在一组基础形状上进行迭代并绘制它们来轻松解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">group</span>(<span class="keyword">_</span> <span class="params">shapes</span>: [<span class="type">Shape</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            shapes.forEach &#123; shape <span class="keyword">in</span></span><br><span class="line">                context.move(to: .zero)</span><br><span class="line">                shape.drawing(<span class="operator">&amp;</span>context)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述操作后，我们现在可以再次轻松地将一组预先计算的Shape值传递给我们的draw函数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shapes: [<span class="type">Shape</span>] <span class="operator">=</span> loadShapes()</span><br><span class="line"><span class="keyword">let</span> image <span class="operator">=</span> draw(.group(shapes))</span><br></pre></td></tr></table></figure>

<p>不过，真正酷的是，上述组API不仅使我们能够构造形状数组，而且还使我们能够更轻松地将多个形状组合到更高级的组件中。例如，这是我们如何使用一组组合形状来表示整个图形（例如徽标）的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">logo</span>(<span class="params">withSize</span> <span class="params">size</span>: <span class="type">Size</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        .group([</span><br><span class="line">            .rectangle(at: size.centerPoint, size: size),</span><br><span class="line">            .text(<span class="string">&quot;The Drawing Company&quot;</span>, fittingInto: size),</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上述徽标与其他徽标一样都是Shape，因此只需调用一次draw方法就可以轻松绘制它，并使用与之前相同的优雅点语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo <span class="operator">=</span> draw(.logo(withSize: size))</span><br></pre></td></tr></table></figure>

<p>有趣的是，尽管我们最初的目标可能是使我们的API更轻量级，但这样做也使它的可组合性和灵活性也得到了提高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们向“ API设计者的工具箱”添加的工具越多，我们越有可能能够设计出在功能，灵活性和易用性之间达到适当平衡的API。 使API尽可能轻巧可能不是我们的最终目标，但是通过尽可能减少API的数量，我们也经常发现如何使它们变得更强大-通过使我们创建类型的方式更灵活，以及使他们组成。所有这些都可以帮助我们在简单性与功能之间实现完美的平衡。</p>
<blockquote>
<p>原文： Lightweight API design in Swift<br>链接：<a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift">https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift</a></p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/16/cover.png" alt="\#16\ 优先级队列"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1146个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/">\#16\ 优先级队列</a></h1><div class="content"><p>队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是：</p>
<ol>
<li><strong>最大优先级队列：</strong>队列中最前面的元素具有最高优先级；</li>
<li><strong>最小优先级队列：</strong>队列中最前面的元素具有最低优先级。</li>
</ol>
<p>当需要在给定的元素列表中取标定最大元素和最小元素时，优先级队列将是非常合适的一种数据结构。</p>
<h2 id="优先级队列的典型应用"><a href="#优先级队列的典型应用" class="headerlink" title="优先级队列的典型应用"></a>优先级队列的典型应用</h2><ul>
<li><strong>迪克斯特拉的算法（Dijkstra’s algorithm）</strong>，使用优先级队列计算最小代价。</li>
<li><strong>A*路径寻找算法</strong>，使用优先级队列跟踪对位置路径进行探索的最短路径。</li>
<li><strong>堆排序</strong>，可以使用优先级队列实现。</li>
<li><strong>哈夫曼编码</strong>会构建一个压缩树。最小优先级队列用于重复查找两个频率最小的节点，这些节点未具有父节点。</li>
</ul>
<p>优先级队列的应用范围很广，远不止上述列举的部分。</p>
<h2 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h2><p>在 <a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-08/">#8\ 队列的Swift实现与操作定义</a>中我们为队列定义了如下的一个协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span>  <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级队列和普通队列同样有着相同的操作，只是具体的实现会有所不同。</p>
<p>对于优先级队列而言，同样对遵循协议<strong>Queue</strong>，并实现一些一般性的操作如下：</p>
<ul>
<li><strong>enqueue：</strong>插入一个元素到队列，如果操作成功，则返回<em>true</em>；</li>
<li><strong>dequeue：</strong>移除具有最高优先级的元素，并返回它，如果队列为空，则返回<em>nil</em>；</li>
<li><strong>isEmpty：</strong>检查队列是否为空；</li>
<li><strong>peek：</strong>返回具有最高优先级的队列，但并不进行删除，如果队列为空，则返回<em>nil</em>。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>构建优先级队列的方式有以下几种：</p>
<ol>
<li><strong>已排序数组</strong>：在获取最大值或最小值的时间复杂度均为O(1)，使用此数据构建优先级队列非常有效，但是其插入算法却比较慢，会达到O(n)的时间复杂度。</li>
<li><strong>平衡二叉搜索树</strong>：在创建双端优先级队列时，使用平衡二叉搜索树最为有利，此时获取最小值和最大值的时间复杂度均在_O(log n)，插入算法比排序的数组会更好，在O(log n)。</li>
<li><strong>堆</strong>：优先级队列最佳的选择，堆结构比排序的数组更为有效，因为堆只需要部分排序，除了从最小堆中获取最小值和从最大堆中获取最大值为O(1)的快速外，其他的操作均为O(log n)的时间复杂度。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Equatable</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> heap: <span class="type">Heap</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>, <span class="params">elements</span>: [<span class="type">Element</span>] <span class="operator">=</span> []) &#123;</span><br><span class="line">        heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><em>PriorityQueue</em> 遵循队列协议<em>Queue</em>。泛型参数元素必须遵循<em>Equatable</em>，因为在元素的操作中需要能够进行元素间的比较。</li>
<li>使用堆数据结构实现优先级队列；</li>
<li>传递合适的参数到初始化构造函数，<em>PriorityQueue</em>可根据参数构建最小和最大优先级队列。</li>
</ol>
<p>为了遵循<em>Queue</em>协议，需要增加如下的协议方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    heap.insert(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中优先级队列上，堆是最为完美的选择，只需要调用堆的各种方法即可实现优先级队列的各种操作。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;priorityQueue&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> priorityQueue <span class="operator">=</span> <span class="type">PriorityQueue</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>priorityQueue.isEmpty &#123;</span><br><span class="line">        <span class="built_in">print</span>(priorityQueue.dequeue()<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of priorityQueue---</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>一个优先级队列通常使用<strong>优先级顺序</strong>进行元素的查找；</li>
<li>能够通过关注队列的关键操作而排除堆数据结构提供的其他功能，从而创建抽象层。</li>
<li>使得优先级队列的意图清晰而简洁。唯一的工作是排队和取消排队元素。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/20/cover.jpg" alt="\#20\ 堆排序（Heap Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1206个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/">\#20\ 堆排序（Heap Sort）</a></h1><div class="content"><p>**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看<a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-15/">\#15\ 堆数据结构（The Heap Data Structure）</a>中的介绍。</p>
<p>堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质：</p>
<ol>
<li>在最大堆中，所有的父节点均大于其孩子节点；</li>
<li>在最小堆中，所有的父节点均小于其孩子节点。</li>
</ol>
<p>最大堆和最小堆的图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/max-min-heap.png"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对于给定的未排序的数组，从小到大进行排序，堆排序都必须首先将该数组转换为最大堆结构。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-1.png"></p>
<p>对上述数组通过筛选所有父节点进行转换，此时使用sift-down方式，最终转换后的结果如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-2.png"></p>
<p>对应的数组为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-3.png"></p>
<p>由于单次sift-down操作的时间复杂度为O(log n)，因此构建一个堆的整体时间复杂度为O(n log n)。</p>
<p>堆排序是将数组元素进行升序排序。因为在最大堆中，最大的元素通常位于根节点，因此可以<strong>使用索引0的元素和索引n-1的元素进行直接交换</strong>。这样交换后，数组最后的元素便位于正确地位置，但是此时堆已经不符合堆的规则了。下一步对新的根节点元素进行sift-down操作，使得堆成立。（此时进行sift-down的时候，需要将排除部分已排序好的元素）</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-4.png"></p>
<p>对元素5进行sift-down之后，新的根节点为原始堆中第二大的元素21，此时同样和末尾元素6进行交换，交换后继续对新的根节点6进行sift-down操作，再次使得堆成立。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-5.png"></p>
<p>上述过程其实形成了一种模式，堆排序简单直接，每次交换首末两个元素，较大的元素依次被交换到数组的后面，多次交换完成后，数组变成了从小到大的顺序，也完成了堆排序。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-6.png"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>堆排序的实现是基于堆的数据结构基础上的，是对堆结构的一种功能扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftSown</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>, <span class="params">upTo</span> <span class="params">size</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> parent <span class="operator">=</span> index</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">               <span class="keyword">let</span> left <span class="operator">=</span> leftChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">let</span> right <span class="operator">=</span> rightChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">var</span> candidate <span class="operator">=</span> parent</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> left <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[left], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> left</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> right <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[right], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> right</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> candidate <span class="operator">==</span> parent &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               elements.swapAt(parent, candidate)</span><br><span class="line">               parent <span class="operator">=</span> candidate</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sorted</span>() -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> heap.elements.indices.reversed() &#123;</span><br><span class="line">            heap.elements.swapAt(<span class="number">0</span>, index)</span><br><span class="line">            heap.siftSown(from: <span class="number">0</span>, upTo: index)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要对原来Heap结构的sift-down方法进行改造，增加参数size以标记当前集合的大小。</p>
</blockquote>
<p>堆排序算法工作流程如下：</p>
<ol>
<li>首先对原有堆进行一个拷贝。因为在堆排序堆元素集合进行排序后，原有的堆结构将不再成立，为了保持堆结构成立，这里使用其拷贝进行排序；</li>
<li>从集合末尾元素开始，对集合进行遍历；</li>
<li>交换首末位置的元素，此次交换后，最大的元素将位于集合的末尾；</li>
<li>交换元素位置后，堆结构已经不成立了，因此需要使用sift-down方法对集合重新调整，已重生合法的堆结构，完成后，新的根节点将是原集合中第二大的元素。重复第三步即可。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;heap sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">6</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(heap.sorted())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of heap sort---</span></span><br><span class="line"><span class="comment">[2, 5, 6, 8, 9, 12, 18, 21, 26]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>堆排序的最佳、最差和平均性能都是O(n log n)。因为必须遍历整个列表一次，并且每次交换元素时，都必须执行向下筛选sift-down操作，这是一个O(log n)操作。</p>
<p>堆排序也不是一种稳定的排序，因为它取决于元素如何布局和放入堆中。例如，如果您正在根据一副纸牌的等级对其进行堆排序，您可能会看到它们的套件相对于原始纸牌的顺序发生了变化。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>堆排序利用最大堆数据结构对数组中的元素进行排序。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2018-07-24-speech-recognation-mfcc/"><img class="fill" src="/images/speech-recognition/audio_draw.png" alt="基于MFCC的语音数据特征提取概述"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.101Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="level-item">39 分钟读完 (大约5786个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2018-07-24-speech-recognation-mfcc/">基于MFCC的语音数据特征提取概述</a></h1><div class="content"><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>语音是人类之间沟通交流的最直接也是最快捷方便的一种手段，而实现人类与计算机之间畅通无阻的语音交流，一直是人类追求的一个梦想。</p>
<p>伴随着移动智能设备的普及，各家移动设备的厂家也开始在自家的设备上集成了语音识别系统，像Apple Siri、Microsoft Cortana、Google Now等语音助手的出现，使得人们在使用移动设备的同时，也能够进行语音交流，极大的方便了人们的生活。但是此类助手也存在一些尴尬的瞬间，例如在一些工作场合或者聚会的场合，某人的一句“Hey Siri”就可能唤醒多台苹果设备，使用者难免尴尬困惑。</p>
<p>而此类予语音助手背后，均是一种被称作“闻声识人”的计算机技术，称为<strong>语音识别</strong>。语音识别技术属于生物认证技术，而其中的说话人识别（speaker recognize，SR）是其中的一种，该技术通常也被称为<strong>声纹识别</strong>技术，该技术是一项通过语音波形中反映说话人生理特征和行为特征的一组语音参数，自动识别说话人身份的技术。其核心是通过预先录入说话人的声音样本，提取出说话人独一无二的语音特征并存入数据库，应用的时候将待验证的语音进行特征提取并与数据库中的特征进行匹配，以确定说话人的身份。</p>
<h2 id="1-1-什么是声纹？"><a href="#1-1-什么是声纹？" class="headerlink" title="1.1 什么是声纹？"></a>1.1 什么是声纹？</h2><p>声纹（voiceprint）是用电声学仪器显示的携带者言语信息的声波频谱，是由波长、频率以及强度等百余种特征维度组成的生物特征，具有稳定性、可测量性以及唯一性等特点。</p>
<ul>
<li>人类语言的产生是由人体语言中枢与发生器官之间进行的一个复杂的生物物理反应过程。发声器官如舌头、牙齿、喉咙、肺、鼻子在尺寸和形态上因人而异，所有任何两个人的声波图谱都有一定的差异性。</li>
<li>每个人的语音声学特征既有相对稳定性，又有个体差异性。这种差异可能来自生理、病理、心理、模拟、伪装等，也可能会周围环境的干扰相关。</li>
<li>由于每个人的发生器官都有其独特性，因此在一般情况下，人们仍然能区别不同的人的声音或者判断是否是同一个人的声音。</li>
</ul>
<p>声纹不像图像那样的直观，在实际的分析中，可以通过波形图和语谱图进行绘制展现，例如下图是一段从1到10的读数语音文件对应的波形图和语谱图（上部分为声音波形图，下部分为声音语谱图）：</p>
<p><img src="/images/speech-recognition/audio_draw.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fw = wave.<span class="built_in">open</span>(<span class="string">&#x27;test.wav&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">soundInfo = fw.readframes(-<span class="number">1</span>)</span><br><span class="line">soundInfo = np.fromstring(soundInfo,np.int16)</span><br><span class="line">f = fw.getframerate()</span><br><span class="line">fw.close()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(soundInfo)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Wave from and spectrogram of test.wav&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.specgram(soundInfo,Fs = f, scale_by_freq = <span class="literal">True</span>, sides = <span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time(seconds)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>语谱图更简单的绘制方法，可参考 <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.signal.spectrogram.html">scipy.signal.spectrogram</a>。</li>
<li>语谱图绘制的原理，可参考 <a target="_blank" rel="noopener" href="http://www.frank-zalkow.de/en/code-snippets/create-audio-spectrograms-with-python.html?i=1">Create audio spectrograms with Python</a>。</li>
</ul>
<p>与其他的生物认证技术如指纹识别、人脸识别、虹膜识别等相同，声纹识别具有不会遗忘、无需记忆和使用方便等优点。在生物认证技术领域，说话人识别技术以其独特的方便性、经济性和准确性收到人们的广泛关注，并日益成为人们日常生活和工作中重要且普及的安全认证方式。</p>
<p>但是，说话人识别有着其他生物认证技术所不具有的优势：</p>
<ul>
<li>用户接受度高：以声音作为识别特征，因其非接触性和自然醒，用户易接受。用户不用刻意的用手指触摸相应的传感器上，也不用将眼睛凑向摄像头，只需要简单的说一两句话即可完成识别认证。</li>
<li>设备成本低：对输入设备如麦克风，摄像头等没有特别的要求，特征提取，模型训练和匹配只需要普通的计算机即可完成。</li>
<li>其他生物认证特征技术各有其劣势：指纹识别需要特殊的传感器芯片，虹膜识别精确度较高，但是设备较为昂贵。</li>
<li>在远程应用和移动互联网环境下优势明显：通过电话、移动设备进行身份认证，声音是最具优势的生物特征，语音控制也逐渐成为流行的交互形式，以声音为特征的身份鉴别技术也越发重要。</li>
</ul>
<h2 id="1-2-声纹识别技术的历史"><a href="#1-2-声纹识别技术的历史" class="headerlink" title="1.2 声纹识别技术的历史"></a>1.2 声纹识别技术的历史</h2><p>声纹识别技术的研究始于20世纪30年代，早期的工作主要集中于人耳听辨实验和探讨听音识别的可能性方面。随着研究手段和计算机技术的发展，研究工作逐渐脱离了单纯的人耳听辨，使得通过机器自动识别人的声音称为可能。在这个过程中也出现了很多不同的计算机技术，从早期的模板匹配到最新的深度学习技术，均在不断的刷新着语音识别技术手段。整体来看，声纹识别技术的发展经历了七个技术演进之路，详见下图（下图来自speakin）：</p>
<p><img src="/images/speech-recognition/voiceprint_history.jpg"></p>
<h2 id="1-3-声纹识别的种类"><a href="#1-3-声纹识别的种类" class="headerlink" title="1.3 声纹识别的种类"></a>1.3 声纹识别的种类</h2><p>声纹识别根据实际应用的范畴可以分为 1:1识别 和 1:N识别两种：</p>
<ul>
<li><p>1:1识别：指确定待识别的一段语音是否来自其所声明的目标说话人，即确认目标说话人是目标说话人的过程。通常应用于电子支付、智能硬件、银行证券交易等。1:1识别有两个系统的性能评价参量，分别为</p>
<ul>
<li>错误接受率(False Acceptation Rate, FAR)：将非目标说话人判别为目标说话人造成的错误率</li>
<li>错误拒绝率(False Rejection Rate, FRR)：将目标说话人误识成非目标说话人造成的错误率</li>
</ul>
<p>  对安全性要求越高，则设定阈值越高，此时接受目标说话人的条件越严格，即FRR越高，FAR越低；对用户体验要求越高，则设定阈值越低，此时接受目标说话人的条件越宽松，即FAR越高，FRR越低。在声纹系统中，可以通过设定不同的阈值来平衡FAR和FRR。</p>
</li>
<li><p>1:N识别：指判定待识别语音属于目标说话人模型集合中的哪一个人，即在N个人中找到目标说话人的过程。通常应用于公安司法、军队国防等。</p>
</li>
</ul>
<h1 id="2-语音的特征提取方法概述"><a href="#2-语音的特征提取方法概述" class="headerlink" title="2. 语音的特征提取方法概述"></a>2. 语音的特征提取方法概述</h1><p>语音是一种数字信号，其数字⾳频的采样率为44100Hz（根据乃奎斯特取样定理得出的结果，在模拟讯号数字化的过程中，如果保证取样频率大于模拟讯号最高频率的2倍，就能100%精确地再还原出原始的模拟讯息。音频的最高频率为20kHz，所以取样率至少应该大于40kHz，为了留一点安全系数，再考虑到工程上的习惯，最终选择了44.1kHz这个数值）。通常情况下使用傅里叶变换将信号在时域与频域之间进行转换，而频谱图可以显示傅里叶变换后的振幅与时间和频率的对应关系。</p>
<h2 id="2-1-特征提取方法"><a href="#2-1-特征提取方法" class="headerlink" title="2.1 特征提取方法"></a>2.1 特征提取方法</h2><p>对于语音识别系统而言，所提取的特征参数需要能够反映特定发信的信息，在说话人无关的系统中，更要求参数能够反映不同说话人相同发音的信息，要求说话人的特征参数要能够代表特定的说话人，能够区分不同说话人相同语音之间的差异，最好能够做到与具体的发音内容无关，也称为文本无关。</p>
<p>在语音特征参数提取技术的发展历程中，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qingkongyeyue/article/details/52149839">线性预测编码（Linear Predictive Coding, LPC）</a>被广泛应用于语音特征参数的提取，其中包括LPC系数、反射LPC系数、面积函数和LPC倒谱系数，能够很好的反映语音的声道特征，但是却对语音的其他特征无能为力。</p>
<p> 不同于LPC等通过对人的发声机理进行研究而得到的声学特征，Mel倒谱系数MFCC是受人的听觉系统研究成果推出而导出的声学特征。根据人耳听觉机理的研究发现，人耳对不同频率的声波有不同的听觉灵敏度。从200Hz到5000Hz的语音信号对语音的清晰度影响最大。人们从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。由于这种特征不依赖于信号的性质，对输入信号不做任何的假设和限制，又利用了听觉模型的研究成果。因此，这种参数比基于声道模型的LPC相比具有更好的鲁棒性，更符合人耳的听觉特性，而且当信噪比降低时仍然具有较好的识别性能。</p>
<p> MFCC（MeI-Freguency CeptraI Coefficients）是需要语音特征参数提取方法之一，因其独特的基于倒谱的提取方式，更加的符合人类的听觉原理，因而也是最为普遍、最有效的语音特征提取算法。MFCC是在Mel标度频率域提取出来的倒谱系数，Mel标度描述了人耳对频率感知的非线性特性。</p>
<h2 id="2-2-MFCC语音特征提取"><a href="#2-2-MFCC语音特征提取" class="headerlink" title="2.2 MFCC语音特征提取"></a>2.2 MFCC语音特征提取</h2><p>MFCC 语音特征的提取过程，如下图：</p>
<p><img src="/images/speech-recognition/mfcc-process.png"></p>
<p>需要对语音信号进行预加重、分帧、加窗等等处理，而这些处理的方式均是为了能够最大化语音信号的某些信息，以达到最好特征参数的提取。</p>
<h3 id="2-2-1-预加重"><a href="#2-2-1-预加重" class="headerlink" title="2.2.1 预加重"></a>2.2.1 预加重</h3><p>预加重其实就是将语音信号通过一个高通滤波器，来增强语音信号中的高频部分，并保持在低频到高频的整个频段中，能够使用同样的信噪比求频谱。在本实验中，选取的高通滤波器传递函数为：</p>
<p><img src="/images/speech-recognition/high_pass_filter.png"></p>
<p>式中a的值介于0.9-1.0之间，我们通常取0.97。同时，预加重也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre_emphasis</span>(<span class="params">signal, coefficient=<span class="number">0.97</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;对信号进行预加重&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> numpy.append(signal[<span class="number">0</span>], signal[<span class="number">1</span>:] - coefficient * signal[:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-分帧"><a href="#2-2-2-分帧" class="headerlink" title="2.2.2 分帧"></a>2.2.2 分帧</h3><p>分帧是指在跟定的音频样本文件中，按照某一个固定的时间长度分割，分割后的每一片样本，称之为一帧，这里需要区分时域波形中的帧，分割后的一帧是分析提取MFCC的样本，而时域波形中的帧是时域尺度上对音频的采样而取到的样本。</p>
<p>分帧是先将N个采样点集合成一个观测单位，也就是分割后的帧。通常情况下N的取值为512或256，涵盖的时间约为20-30ms。也可以根据特定的需要进行N值和窗口间隔的调整。为了避免相邻两帧的变化过大，会让两相邻帧之间有一段重叠区域，此重叠区域包含了M个取样点，一般M的值约为N的1&#x2F;2或1&#x2F;3。</p>
<p>语音识别中所采用的信号采样频率一般为8kHz或16kHz。以8kHz来说，若帧长度为256个采样点，则对应的时间长度是256&#x2F;8000×1000&#x3D;32ms。本次实验中所使用的采样率(Frames Per Second)16kHz，窗长25ms（400个采样点），窗间隔为10ms（160个采样点）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">audio2frame</span>(<span class="params">signal, frame_length, frame_step, winfunc=<span class="keyword">lambda</span> x: numpy.ones(<span class="params">(<span class="params">x,</span>)</span>)</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;分帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    signal_length = <span class="built_in">len</span>(signal)</span><br><span class="line">    frame_length = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_length))</span><br><span class="line">    frame_step = <span class="built_in">int</span>(<span class="built_in">round</span>(frame_step))</span><br><span class="line">    <span class="keyword">if</span> signal_length &lt;= frame_length:</span><br><span class="line">        frames_num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        frames_num = <span class="number">1</span> + <span class="built_in">int</span>(math.ceil((<span class="number">1.0</span> * signal_length - frame_length) / frame_step))</span><br><span class="line">    pad_length = <span class="built_in">int</span>((frames_num - <span class="number">1</span>) * frame_step + frame_length)</span><br><span class="line">    zeros = numpy.zeros((pad_length - signal_length,))</span><br><span class="line">    pad_signal = numpy.concatenate((signal, zeros))</span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_length), (frames_num, <span class="number">1</span>)) + numpy.tile(numpy.arange(<span class="number">0</span>, frames_num * frame_step, frame_step),(frame_length, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    frames = pad_signal[indices]</span><br><span class="line">    win = numpy.tile(winfunc(frame_length), (frames_num, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> frames * win</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-加窗"><a href="#2-2-3-加窗" class="headerlink" title="2.2.3 加窗"></a>2.2.3 加窗</h3><p>在对音频进行分帧之后，需要对每一帧进行加窗，以增加帧左端和右端的连续性，减少频谱泄漏。在提取MFCC的时候，比较常用的窗口函数为Hamming窗。</p>
<p>假设分帧后的信号为 <em>S(n),n&#x3D;0,1,2…,N-1</em>，其中N为帧的大小，那么进行加窗的处理则为：</p>
<p><img src="/images/speech-recognition/fps_hamming1.jpg"></p>
<p>W(n)的形式如下：</p>
<p><img src="/images/speech-recognition/fps_hamming2.jpg"></p>
<p>不同的a值会产生不同的汉明窗，一般情况下a取值0.46。进行值替换后，W(n)则为：</p>
<p><img src="/images/speech-recognition/fps_hamming3.png"></p>
<p>对应的汉明窗时域波形类似下图：</p>
<p><img src="/images/speech-recognition/fps_hamming4.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deframesignal</span>(<span class="params">frames, signal_length, frame_length, frame_step, winfunc=<span class="keyword">lambda</span> x: numpy.ones(<span class="params">(<span class="params">x,</span>)</span>)</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;加窗&#x27;&#x27;&#x27;</span></span><br><span class="line">    signal_length = <span class="built_in">round</span>(signal_length)</span><br><span class="line">    frame_length = <span class="built_in">round</span>(frame_length)</span><br><span class="line">    frames_num = numpy.shape(frames)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> numpy.shape(frames)[<span class="number">1</span>] == frame_length, <span class="string">&#x27;&quot;frames&quot;矩阵大小不正确，它的列数应该等于一帧长度&#x27;</span></span><br><span class="line">    indices = numpy.tile(numpy.arange(<span class="number">0</span>, frame_length), (frames_num, <span class="number">1</span>)) + numpy.tile(numpy.arange(<span class="number">0</span>, frames_num * frame_step, frame_step),(frame_length, <span class="number">1</span>)).T</span><br><span class="line">    indices = numpy.array(indices, dtype=numpy.int32)</span><br><span class="line">    pad_length = (frames_num - <span class="number">1</span>) * frame_step + frame_length</span><br><span class="line">    <span class="keyword">if</span> signal_length &lt;= <span class="number">0</span>:</span><br><span class="line">        signal_length = pad_length</span><br><span class="line">    recalc_signal = numpy.zeros((pad_length,))</span><br><span class="line">    window_correction = numpy.zeros((pad_length, <span class="number">1</span>))</span><br><span class="line">    win = winfunc(frame_length)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, frames_num):</span><br><span class="line">        window_correction[indices[i, :]] = window_correction[indices[i, :]] + win + <span class="number">1e-15</span></span><br><span class="line">        recalc_signal[indices[i, :]] = recalc_signal[indices[i, :]] + frames[i, :]</span><br><span class="line">    recalc_signal = recalc_signal / window_correction</span><br><span class="line">    <span class="keyword">return</span> recalc_signal[<span class="number">0</span>:signal_length]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-对信号进行离散傅立叶变换-DFT"><a href="#2-2-4-对信号进行离散傅立叶变换-DFT" class="headerlink" title="2.2.4 对信号进行离散傅立叶变换 (DFT)"></a>2.2.4 对信号进行离散傅立叶变换 (DFT)</h3><p>由于信号在时域上的变换通常很难看出信号的特性，所有通常将它转换为频域上的能量分布来观察，不同的能量分布，代表不同语音的特性。所以在进行了加窗处理后，还需要再经过离散傅里叶变换以得到频谱上的能量分布。对分帧加窗后的各帧信号进行快速傅里叶变换得到各帧的频谱。并对语音信号的频谱取模平方得到语音信号的功率谱。设语音信号的DFT为：</p>
<p><img src="/images/speech-recognition/dft1.png"></p>
<p>能量的分布为：</p>
<p><img src="/images/speech-recognition/dft2.png"></p>
<p>在本次实验中，采用DFT长度 N&#x3D;512，结果值保留前257个系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spectrum_magnitude</span>(<span class="params">frames, NFFT = <span class="number">512</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算每一帧经过FFT变幻以后的频谱的幅度，若frames的大小为N*L,则返回矩阵的大小为N*NFFT&#x27;&#x27;&#x27;</span></span><br><span class="line">    complex_spectrum = numpy.fft.rfft(frames, NFFT)</span><br><span class="line">    <span class="keyword">return</span> numpy.absolute(complex_spectrum)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spectrum_power</span>(<span class="params">frames, NFFT</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算每一帧傅立叶变换以后的功率谱&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / NFFT * numpy.square(spectrum_magnitude(frames, NFFT))</span><br></pre></td></tr></table></figure>

<p>下图是有频谱到功率谱的转换结果示意图：</p>
<p><img src="/images/speech-recognition/dft3.png"></p>
<h3 id="2-2-5-应用梅尔滤波器-Mel-Filterbank"><a href="#2-2-5-应用梅尔滤波器-Mel-Filterbank" class="headerlink" title="2.2.5 应用梅尔滤波器 (Mel Filterbank)"></a>2.2.5 应用梅尔滤波器 (Mel Filterbank)</h3><p>MFCC考虑到了人类的听觉特征，先将线性频谱映射到基于听觉感知的Mel非线性频谱中，然后转换到倒谱上。 在Mel频域内，人对音调的感知度为线性关系。举例来说，如果两段语音的Mel频率相差两倍，则人耳听起来两者的音调也相差两倍。Mel滤波器的本质其实是一个尺度规则，通常是将能量通过一组Mel尺度的三角形滤波器组，如定义有M个滤波器的滤波器组，采用的滤波器为三角滤波器，中心频率为 <em>f(m),m&#x3D;1,2…M</em>，M通常取22-26。f(m)之间的间隔随着m值的减小而缩小，随着m值的增大而增宽，如图所示：</p>
<p><img src="/images/speech-recognition/mel1.jpg"></p>
<p>从频率到Mel频率的转换公式为： </p>
<p> <img src="/images/speech-recognition/mel_hz.jpg"></p>
<p> 其中 f 为语音信号的频率，单位赫兹（Hz）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hz2mel</span>(<span class="params">hz</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;把频率hz转化为梅尔频率&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2595</span> * numpy.log10(<span class="number">1</span> + hz / <span class="number">700.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mel2hz</span>(<span class="params">mel</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;把梅尔频率转化为hz&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">700</span> * (<span class="number">10</span> ** (mel / <span class="number">2595.0</span>) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>假如有10个Mel滤波器（在实际应用中通常一组Mel滤波器组有26个滤波器。），首先要选择一个最高频率和最低频率，通常最高频率为8000Hz，最低频率为300Hz。使用从频率转换为Mel频率的公式将300Hz转换为401.25Mels，8000Hz转换为2834.99Mels，由于有10个滤波器，每个滤波器针对两个频率的样点，样点之间会进行重叠处理，因此需要12个点，意味着需要在401.25和2834.99之间再线性间隔出10个附加点，如：</p>
<p><em>m(i) &#x3D; 401.25,622.50,843.75,1065.00,1286.25,1507.50, 1728.74,1949.99,2171.24,2392.49,2613.74,2834.99</em></p>
<p>现在使用从Mel频率转换为频率的公式将它们转换回赫兹：</p>
<p><em>h(i) &#x3D; 300,517.33,781.90,1103.97,1496.04,1973.32,2554.33, 3261.62,4122.63,5170.76,6446.70,8000</em></p>
<p>将频率映射到最接近的DFT频率：</p>
<p><img src="/images/speech-recognition/mel2.png"></p>
<p><em>f(i) &#x3D; 9,16,25,35,47,63,81,104,132,165,206,256</em></p>
<p>于是，我们得到了一个由10个Mel滤波器构成的Mel滤波器组。</p>
<p><img src="/images/speech-recognition/mel3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_filter_banks</span>(<span class="params">filters_num=<span class="number">20</span>, NFFT=<span class="number">512</span>, samplerate=<span class="number">16000</span>, low_freq=<span class="number">0</span>, high_freq=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算梅尔三角间距滤波器，该滤波器在第一个频率和第三个频率处为0，在第二个频率处为1&#x27;&#x27;&#x27;</span></span><br><span class="line">    low_mel = hz2mel(low_freq)</span><br><span class="line">    high_mel = hz2mel(high_freq)</span><br><span class="line">    mel_points = numpy.linspace(low_mel, high_mel, filters_num + <span class="number">2</span>)</span><br><span class="line">    hz_points = mel2hz(mel_points)</span><br><span class="line">    <span class="built_in">bin</span> = numpy.floor((NFFT + <span class="number">1</span>) * hz_points / samplerate)</span><br><span class="line">    fbank = numpy.zeros([filters_num, NFFT / <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">0</span>, filters_num):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">int</span>(<span class="built_in">bin</span>[j]), <span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">1</span>])):</span><br><span class="line">            fbank[j, i] = (i - <span class="built_in">bin</span>[j]) / (<span class="built_in">bin</span>[j + <span class="number">1</span>] - <span class="built_in">bin</span>[j])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">1</span>]), <span class="built_in">int</span>(<span class="built_in">bin</span>[j + <span class="number">2</span>])):</span><br><span class="line">            fbank[j, i] = (<span class="built_in">bin</span>[j + <span class="number">2</span>] - i) / (<span class="built_in">bin</span>[j + <span class="number">2</span>] - <span class="built_in">bin</span>[j + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> fbank</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-对频谱进行离散余弦变换-DCT"><a href="#2-2-6-对频谱进行离散余弦变换-DCT" class="headerlink" title="2.2.6 对频谱进行离散余弦变换 (DCT)"></a>2.2.6 对频谱进行离散余弦变换 (DCT)</h3><p>在上一步的基础上使⽤离散余弦变换，即进⾏了⼀个傅⽴叶变换的逆变换，得到倒谱系数。</p>
<p><img src="/images/speech-recognition/dct.png"></p>
<p>由此可以得到26个倒谱系数。只取其[2:13]个系数，第1个用能量的对数替代，这13个值即为所需的13个MFCC倒谱系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lifter</span>(<span class="params">cepstra, L=<span class="number">22</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;升倒谱函数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> L &gt; <span class="number">0</span>:</span><br><span class="line">        nframes, ncoeff = numpy.shape(cepstra)</span><br><span class="line">        n = numpy.arange(ncoeff)</span><br><span class="line">        lift = <span class="number">1</span> + (L / <span class="number">2</span>) * numpy.sin(numpy.pi * n / L)</span><br><span class="line">        <span class="keyword">return</span> lift * cepstra</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cepstra</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7-动态差分参数的提取（包括一阶微分系数和加速系数）"><a href="#2-2-7-动态差分参数的提取（包括一阶微分系数和加速系数）" class="headerlink" title="2.2.7 动态差分参数的提取（包括一阶微分系数和加速系数）"></a>2.2.7 动态差分参数的提取（包括一阶微分系数和加速系数）</h3><p>标准的倒谱参数MFCC只反映了语音参数的静态特性，语音的动态特性可以用这些静态特征的差分谱来描述。通常会把动、静态特征结合起来以有效提高系统的识别性能。差分参数的计算可以采用下面的公式：</p>
<p><img src="/images/speech-recognition/dlog.png"></p>
<p>上式中，d(t)表示第t个一阶微分，c(t)表示第t个倒谱系数，Q表示倒谱系数的阶数，K表示一阶导数的时间差，可取1或2。将上式的结果再代入就可以得到加速系数。</p>
<p>⾄此，我们计算到了了⾳频⽂件每⼀帧的39个Mel频率倒谱系数（13个MFCC+13个一阶微分系数+13个加速系数），这些即为一个语音文件的特征数据，这些特征数据可以运用在之后的分类中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">derivate</span>(<span class="params">feat, big_theta=<span class="number">2</span>, cep_num=<span class="number">13</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算一阶系数或者加速系数的一般变换公式&#x27;&#x27;&#x27;</span></span><br><span class="line">    result = numpy.zeros(feat.shape)</span><br><span class="line">    denominator = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> theta <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, big_theta, big_theta):</span><br><span class="line">        denominator = denominator + theta ** <span class="number">2</span></span><br><span class="line">    denominator = denominator * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> numpy.linspace(<span class="number">0</span>, feat.shape[<span class="number">0</span>] - <span class="number">1</span>, feat.shape[<span class="number">0</span>]):</span><br><span class="line">        tmp = numpy.zeros((cep_num,))</span><br><span class="line">        numerator = numpy.zeros((cep_num,))</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, cep_num, cep_num):</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> theta <span class="keyword">in</span> numpy.linspace(<span class="number">1</span>, big_theta, big_theta):</span><br><span class="line">                <span class="keyword">if</span> (t + theta) &gt; cep_num:</span><br><span class="line">                    a = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a = feat[row][t + theta - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> (t - theta) &lt; <span class="number">1</span>:</span><br><span class="line">                    b = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    b = feat[row][t - theta - <span class="number">1</span>]</span><br><span class="line">                s += theta * (a - b)</span><br><span class="line">            numerator[t - <span class="number">1</span>] = s</span><br><span class="line">        tmp = numerator * <span class="number">1.0</span> / denominator</span><br><span class="line">        result[row] = tmp</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本文针对语音数据的特征提取方法—MFCC进行了简单的概述和实践，MFCC是音频特征处理中比较常用而且很有效的方法。当特征数据提取出来之后，就可以进一步的进行数据的归一化、标准化，然后应用于机器学习、神经网络等等模型训练算法中，以得到能够识别语音类别的模型。在实际的应用中，可能还需要考虑很多的其他因素，例如源语音数据的采集方法、采集时长、模型的构建方式、模型的部署方式等等因素，因此需要根据业务的具体场景，来进行平衡取舍，以达到识别的时效性、准确性等。</p>
<p>目前关于语音识别相关的研究还在持续中，目标是能够最小化成本的在移动端部署语音识别相关的功能，提高SDK在人工智能方便的能力等。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel-frequency cepstrum</a></li>
<li><a target="_blank" rel="noopener" href="http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/">Mel Frequency Cepstral Coefficient (MFCC) tutorial
</a></li>
<li><a target="_blank" rel="noopener" href="https://musicinformationretrieval.com/">Notes on Music Information Retrieval</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/daniel-D/p/3244718.html">机器学习中距离和相似性度量方法</a></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/14/cover.jpg" alt="\#14\ 二分查找（Binary Search）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/">\#14\ 二分查找（Binary Search）</a></h1><div class="content"><p>二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足：</p>
<ul>
<li>集合必须是在恒定的时间内执行索引操作，意味着集合必须是<strong>RandomAccessCollection</strong>类型的；</li>
<li>集合必须是<strong>sorted</strong>的。</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>在Swift标准库中的Array结构中，通过*index(of:)*来实现线性的元素搜索，也就是意味着Array中的元素搜索需要遍历整个数组。</p>
<blockquote>
<p>在Swift 5中<em>index(of:)</em> 已经废弃，取而代之的为*firstIndex(of:)*。</p>
</blockquote>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/array-linear-search.png"></p>
<p>而二分查找则是在已排序的数组上，以不同的处理方式进行元素的搜索。例如下图所示，在已排序的数组中搜索元素31：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-31.png"></p>
<p>和一般的数组元素查找不同的是，二分查找按照如下的步骤进行元素的搜索：</p>
<p><strong>Step 1：找到中间位置的索引</strong></p>
<p>二分查找第一步，便是找到集合中间位置，这一步非常直接，通过集合的元素总数进行计算获得：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/step-1-find-middle-index.png"></p>
<p><strong>Step 2：检查中间索引位置的元素</strong></p>
<p>下一步则是检查中间位置的元素，如果和预检索的元素匹配，则直接返回索引，如果不相符，则继续第三步，继续检索元素。</p>
<p><strong>Step 3：递归进行二分查找</strong></p>
<p>最后一步是递归调用二分查找，但是这时，仅仅需要检索的是集合中间索引左侧或者右侧，而非整个集合。当中间位置的元素小于预检索的元素时，则检索中间位置右侧，反之，检索中间位置左侧。</p>
<p>二分查找每一步的检索之后，都会减少一半的检索范围，这样大大的减小了检索的时间耗时，提高检索效率。</p>
<p>在上述例子中，为了检索元素31，由于中间位置的元素为22，小于预检索的元素31，因此将继续检索中间位置元素22的右侧元素：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-22-right.png"></p>
<p>二分查找从大的方面来说，每一次的元素检索只需要三步，直到无法将集合再次进行左右划分或者找到元素为止。</p>
<p>二分查找的时间复杂度为O(log n)。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>首先定义二分查找使用范围，以及集合元素的可比较性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>? &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>由于二分查找仅仅适用于集合类型<strong>RandomAccessCollection</strong>，并且其中的元素需要可比较的特性，因此针对该类型进行扩展并设定元素可比较性，并添加二分查找方法的定义；</li>
<li>二分查找在运行过程中需要递归调用，因此在函数定义中要执行每一次递归的范围，参数<strong>range</strong>是可选类型，在首次进行二分查找的时候，不需要传入<strong>range</strong>，故其默认值为<strong>nil</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>?&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> range <span class="operator">=</span> range <span class="operator">??</span> startIndex <span class="operator">..&lt;</span> endIndex</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> range.lowerBound <span class="operator">&lt;</span> range.upperBound <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> size <span class="operator">=</span> distance(from: range.lowerBound, to: range.upperBound)</span><br><span class="line">        <span class="keyword">let</span> middle <span class="operator">=</span> index(range.lowerBound, offsetBy: size <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">&gt;</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: range.lowerBound <span class="operator">..&lt;</span> middle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: middle <span class="operator">..&lt;</span> range.upperBound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查<em>range</em>是否为<em>nil</em>，如果为<em>nil</em>，则获取集合完整的索引范围<em>startIndex ..&lt; endIndex</em>；</li>
<li>检查集合是否为空，这里的检查方式是通过集合的最小边界和最大边界进行判断集合是否至少有一个元素，否则直接返回<em>nil</em>；</li>
<li>通过集合的最小边界和最大边界，获取集合的长度，之后使用*index(offsetBy:)*方法获取集合中间位置的索引；</li>
<li>如果中间位置的元素就是我们要查找的元素，则直接返回中间位置索引；</li>
<li>如果中间位置的元素大于预查找的元素，则说明预查找元素在集合中间位置的左侧，递归调用*binarySearch(for:range:)*方法，继续查找；</li>
<li>如果中间位置的元素小于预查找的元素，则说明预查找的元素在集合中间位置的右侧，递归调用*binarySearch(for:range:)*方法，继续查找。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;binary search&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">105</span>, <span class="number">150</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> search31 <span class="operator">=</span> array.firstIndex(of: <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">let</span> binarySearch31 <span class="operator">=</span> array.binarySearch(for: <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index(of:): <span class="subst">\(String(describing: search31))</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;binarySearch(of:): <span class="subst">\(String(describing: binarySearch31))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of binary search---</span></span><br><span class="line"><span class="comment">index(of:): Optional(7)</span></span><br><span class="line"><span class="comment">binarySearch(of:): Optional(7)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>二分查找是一种强大的算法，每当某些场景下，集合的元素时已排序的情况下，都可以考虑使用二分查找的方法。另外，如果遇到的问题似乎进行元素搜索需要O(n^2)的时间复杂度，可以考虑先对集合进行前期的排序，然后采用二分查找的方法将时间复杂度降低到O(n log n)的程度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>二分查找仅仅对已排序的集合有效；</li>
<li>有时候，对集合进行排序后，再使用二分查找是有益的；</li>
<li>对于集合本身，其<em>sorted</em>方法的时间复杂度为O(n)，而二分查找的时间复杂度为O(log n)，对于大型数据集合来说，二分查找的可伸缩性更好。</li>
</ul>
<blockquote>
<p>二分查找思想典型的应用场景就是在Bug原因的追查上面，当面对一个无从知晓其最终的引发点的时候，可以尝试使用二分查找的思想，分段校验代码的执行结果，逐步缩小Bug追查的范围，提高Bug原因的追查效率等。</p>
</blockquote>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/Logs/"><span class="level-start"><span class="level-item">Logs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>