<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: Swift中的数据结构与算法 - Robin&#039;s Wo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Robin&#039;s Wo"><meta name="msapplication-TileImage" content="/img/avatar.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Robin&#039;s Wo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:type" content="blog"><meta property="og:title" content="Robin&#039;s Wo"><meta property="og:url" content="https://zycslog.github.io/"><meta property="og:site_name" content="Robin&#039;s Wo"><meta property="og:description" content="Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zycslog.github.io/img/og_image.png"><meta property="article:author" content="Robin"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zycslog.github.io"},"headline":"Robin's Wo","image":["https://zycslog.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Robin"},"publisher":{"@type":"Organization","name":"Robin's Wo","logo":{"@type":"ImageObject","url":"https://zycslog.github.io/img/avatar.jpg"}},"description":"Robin，80后，主业iOS开发，移动开发者，热爱技术，学习中。很高兴能够在这里与你分享对技术对生活的思考与记录。"}</script><link rel="alternate" href="/atom.xml" title="Robin&#039;s Wo" type="application/atom+xml"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/">Log</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Swift中的数据结构与算法</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/1/cover.jpg" alt="\#1\ 为什么要学习数据结构与算法"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.800Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:27.134Z" title="4/30/2022, 3:45:27 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">15 分钟读完 (大约2188个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/">\#1\ 为什么要学习数据结构与算法</a></h1><div class="content"><p>随机网络上有大量的程序员应该学习<strong>数据结构和算法</strong>的文章。还记得实在大学时代的时候，系统的学习过数据结构、算法相关的课程，而后几乎没有系统学习过了。工作后从一开始的各种业务逻辑的开发，慢慢深入了解到系统底层，了解了代码的执行效率以及对硬件设备资源的消耗基本上都是由数据结构和算法决定的，才开始慢慢关心起来良好的数据结构设计和良好的算法设计，才能够在数据量越来越多的时候，所设计的软件才能良好地执行等。</p>
<p>那么对于程序员来说，到底为什么要学习数据结构和算法呢？首先要了解的是什么是<strong>数据结构</strong>？</p>
<h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>具体的定义这里摘录了维基百科的定义，具体如下：</p>
<blockquote>
<p>在计算机科学中，数据结构（英语：data structure）是计算机中存储、组织数据的方式。</p>
<p>数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>
<p>大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可为空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。</p>
<p>数据结构可透过编程语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支持各种程序运行。</p>
<p>不同种类的数据结构适合不同种类的应用，部分数据结构甚至是为了解决特定问题而设计出来的。例如B树即为加快树状结构访问速度而设计的数据结构，常被应用在数据库和文件系统上。</p>
<p>正确的数据结构选择可以提高算法的效率（请参考算法效率）。在计算机程序设计的过程中，选择适当的数据结构是一项重要工作。许多大型系统的编写经验显示，程序设计的困难程度与最终成果的质量与表现，取决于是否选择了最适合的数据结构。</p>
<p>系统架构的关键因素是数据结构而非算法的见解，导致了多种形式化的设计方法与编程语言的出现。绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于用户界面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类 (计算机科学)来达到这个目的。</p>
<p>摘录自维基百科: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></p>
</blockquote></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-12-01-Data-Structures-&amp;-Algorithms-in-Swift-01/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/5/cover.jpg" alt="\#5\ Linked List &amp;&amp; Swift Collection Protocol"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:35:13.800Z" title="4/30/2022, 2:35:13 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T07:45:33.512Z" title="4/30/2022, 3:45:33 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">18 分钟读完 (大约2751个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/">\#5\ Linked List &amp;&amp; Swift Collection Protocol</a></h1><div class="content"><p>在Swift标准库（<strong>Swift standard library</strong>）中定义了很多协议或协议的集合，这些协议分别对应了特定的数据类型，每个协议都对所定义的数据类型有一些特性和性能方面的保证，而对于开发者而言，这些协议也是自定义数据结构和对现有数据类型进行扩展的基础准则。在这些协议的集合中，有四种关于<strong>集合的协议（collection protocols）</strong>，分别是：</p>
<ul>
<li><strong>Tier 1, Sequence：</strong>序列类型是Swift中最为朴素的协议,仅仅定义了一系列类型相同的元素，而不对这一系列元素的性质有任何额外的约定。它唯一约定了的动作，就是从序列当前位置读取下一个元素。</li>
<li><strong>Tier 2, Collection：</strong>集合类型是一种提供额外保证的序列类型。集合类型是有限的，允许重复的非破坏性顺序访问。</li>
<li><strong>Tier 3, BidirectionalColllection：</strong>集合类型可以是双向集合类型，可以允许在序列中上下双向移动。 这对于链表是不可能的，因为你只能从头到尾，而不是相反。</li>
<li><strong>Tier 4, RandomAccessCollection：</strong>如果它可以保证访问特定索引处的元素将花费与访问任何其他索引处的元素一样长的时间。该双向集合类型就是随机访问集合类型， 这对于链表来说是不可能的，因为访问列表前面附近的节点比列表下方的节点快得多。</li>
</ul>
<p>因此对于链表数据结构来说，<strong>Sequence</strong>和<strong>Collection</strong>两种协议是适用的。首先链表是一个序列型数据结构，适用<strong>Sequence</strong>协议，另外链表是有限序列，适用<strong>Collection</strong>协议。</p></div><a class="article-more button is-small is-size-7" href="/2022/04/30/2019-12-04-Data-Structures-&amp;-Algorithms-in-Swift-05/#more">阅读更多</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/9/cover.png" alt="\#9\ 一般树与树节点遍历"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">12 分钟读完 (大约1775个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-23-Data-Structures-&amp;-Algorithms-in-Swift-09/">\#9\ 一般树与树节点遍历</a></h1><div class="content"><p>在计算机编程的世界中，<strong>树</strong>是一种非常重要的数据结构。树用于解决很多计算机编程世界的挑战，例如：</p>
<ul>
<li>等级关系的描述</li>
<li>分类数据的管理</li>
<li>分类查找操作</li>
</ul>
<p>在计算机算法中，树有很多种，每一种都有其特有的形状和大小。在本文中将学习关于树的基础知识，以及使用Swfit编程语言实现树结构等。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>关于树的术语有很多，只有将各个术语的含义弄清楚之后，才能够实现树，并利用树来解决问题。</p>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>类似链表，树也是由节点构成的。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/node.png"></p>
<p>每一个节点会封装一些数据，并链接着其<em>孩子</em>。</p>
<h3 id="父节点和子节点"><a href="#父节点和子节点" class="headerlink" title="父节点和子节点"></a>父节点和子节点</h3><p>树的结构是从顶部延伸到底部的，看起来像一颗反过来的真实的树。</p>
<p>在树的结构中，除了最上方的节点之外，每一个节点都链接着它上面的节点，这个节点称之为<strong>父节点</strong>。除了最下方的节点之外，每一个节点都连接着它下面的节点，这个节点称之为<strong>子节点</strong>。在树中，每一个子节点只有一个父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree.png"></p>
<h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>树结构中，最顶端的节点称为<strong>根节点</strong>。根节点再无父节点，并且一颗树中有且仅有一个根节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/root.png"></p>
<h3 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h3><p>没有子节点的节点，称之为<strong>叶子节点</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/leaf.png"></p>
<h2 id="Swift树结构实现"><a href="#Swift树结构实现" class="headerlink" title="Swift树结构实现"></a>Swift树结构实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">TreeNode</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一棵树来说，最为重要的便是树的节点，每一个节点都有两个主要功能，封装数据和链接其他节点。在上述实现中，创建类TreeNode来对节点的结构进行封装，并且在节点的结构中，其所有的子节点使用了数组进行封装，数组中依然是节点结构。</p>
<p>对于一棵树来说，树中的节点可以进行添加，即为某个节点添加新的节点，因此添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节点添加新的子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="keyword">_</span> <span class="params">child</span>: <span class="type">TreeNode</span>) &#123;</span><br><span class="line">    children.append(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time to give it a whirl.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;Create a tree&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> beverages <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    beverages.add(hot)</span><br><span class="line">    beverages.add(cold)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(beverages.value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">0</span>].value)</span><br><span class="line">    <span class="built_in">print</span>(beverages.children[<span class="number">1</span>].value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of Create a tree---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">Hot</span></span><br><span class="line"><span class="comment">Cold</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>树的结构属于层级结构，上述Demo中为根节点Beverages增加了两个子节点Hot和Cold。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/create-tree.png"></p>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>线性集合（如数组、链表）的遍历相对简单，因为他们都有清晰的起点和终点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/linear-collection.png"></p>
<p>然而遍历一颗树相对较为复杂一点，对于一颗树来说，其起点和终点并不明晰。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/tree2.png"></p>
<p>由于在树种，是优先遍历左边的节点还是右边的节点，并不明确，只因面对的问题不同而策略不同。对于不同的树有着不同的遍历策略。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>这是一种从根节点开始，直到回溯之前尽可能的遍历到树的叶子节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachDepthFirst</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.forEachDepthFirst(visit: visit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的是递归的方式进行节点的遍历，如果不想使用递归，可以将children变量设置为栈类型。为了测试，首先我们构建一颗比较大的树：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeBeverageTree</span>() -&gt; <span class="type">TreeNode</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;Beverages&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> hot <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;hot&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cold <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cold&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;tea&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> coffee <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chocolate <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;cocoa&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> blackTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> greenTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> chaiTea <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;chai&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> soda <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;sida&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> milk <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> gingerAle <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;ginger ale&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bitterLemon <span class="operator">=</span> <span class="type">TreeNode</span>(<span class="string">&quot;bitter lemon&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    tree.add(hot)</span><br><span class="line">    tree.add(cold)</span><br><span class="line">    </span><br><span class="line">    hot.add(tea)</span><br><span class="line">    hot.add(coffee)</span><br><span class="line">    hot.add(chocolate)</span><br><span class="line">    </span><br><span class="line">    cold.add(soda)</span><br><span class="line">    cold.add(milk)</span><br><span class="line">    </span><br><span class="line">    tea.add(blackTea)</span><br><span class="line">    tea.add(greenTea)</span><br><span class="line">    tea.add(chaiTea)</span><br><span class="line">    </span><br><span class="line">    soda.add(gingerAle)</span><br><span class="line">    soda.add(bitterLemon)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该树的形态如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/demo-large-tree.png"></p>
<p>接下来在这棵树上测试深度优先遍历。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;depth-first traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachDepthFirst &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of depth-first traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>从上述测试打印的结果和树的形态图可以看出，深度优先遵循从左至右的原则。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历又称为水平顺序遍历，其算法如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">forEachLevelOrder</span>(<span class="params">visit</span>: (<span class="type">TreeNode</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        visit(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&gt;()</span><br><span class="line">        children.forEach &#123;</span><br><span class="line">            queue.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst() &#123;</span><br><span class="line">            visit(node)</span><br><span class="line">            node.children.forEach &#123;</span><br><span class="line">                queue.append(<span class="variable">$0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现采用了数组作为临时变量，存储元素，也可以直接使用队列。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/level-order.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;level-order traversal&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    tree.forEachLevelOrder &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable">$0</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of level-order traversal---</span></span><br><span class="line"><span class="comment">Beverages</span></span><br><span class="line"><span class="comment">hot</span></span><br><span class="line"><span class="comment">cold</span></span><br><span class="line"><span class="comment">tea</span></span><br><span class="line"><span class="comment">coffee</span></span><br><span class="line"><span class="comment">cocoa</span></span><br><span class="line"><span class="comment">sida</span></span><br><span class="line"><span class="comment">milk</span></span><br><span class="line"><span class="comment">black</span></span><br><span class="line"><span class="comment">green</span></span><br><span class="line"><span class="comment">chai</span></span><br><span class="line"><span class="comment">ginger ale</span></span><br><span class="line"><span class="comment">bitter lemon</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="节点搜索"><a href="#节点搜索" class="headerlink" title="节点搜索"></a>节点搜索</h3><p>上面实现了树的两种遍历算法 — 深度优先和广度优先，分别针对了不同的特定问题。有了遍历的算法之后，针对节点的搜索而言，便无需太过复杂的算法了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">TreeNode</span> <span class="title class_">where</span> <span class="title class_">T</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">search</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) -&gt; <span class="type">TreeNode</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">TreeNode</span>?</span><br><span class="line">        forEachLevelOrder &#123; node <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> node.value <span class="operator">==</span> value &#123;</span><br><span class="line">                result <span class="operator">=</span> node</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个搜索算法中，使用了广度优先的遍历算法，也可使用深度优先的遍历算法。但是如果在树种有多个相匹配的节点，搜索算法最终保存的是最后一个节点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;searching for a node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tree <span class="operator">=</span> makeBeverageTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult1 <span class="operator">=</span> tree.search(<span class="string">&quot;ginger ale&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found node: <span class="subst">\(searchResult1.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> searchResult2 <span class="operator">=</span> tree.search(<span class="string">&quot;WKD Blue&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(searchResult2.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t find WKD Blue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of searching for a node---</span></span><br><span class="line"><span class="comment">Found node: ginger ale</span></span><br><span class="line"><span class="comment">Couldn&#x27;t find WKD Blue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>树结构和链表类似，但是链表的每一个节点只能链接到另一个节点，而树的一个节点可以链接多个节点；</li>
<li>针对树来说，有一些特定的术语，如根节点、子节点、叶子节点等；</li>
<li>节点的遍历 — 深度优先和广度优先并只是应用在一般的树中，其他树的结构也可使用，只不过会根据树的不同而策略不同。</li>
</ul>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>打印树中同一层级的元素，每个相同层级的元素打印在一行中。例如：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/9/challenge.png"></p>
<p>打印的结果应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 </span><br><span class="line">1 17 20 </span><br><span class="line">1 5 0 2 5 7</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printEachLevel</span>&lt;<span class="type">T</span>&gt;(<span class="params">for</span> <span class="params">tree</span>: <span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">var</span> queue <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">TreeNode</span>&lt;<span class="type">T</span>&gt;&gt;()</span><br><span class="line">    <span class="keyword">var</span> nodesLeftInCurrentLevel <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    queue.append(tree)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>queue.isEmpty &#123;</span><br><span class="line">        nodesLeftInCurrentLevel <span class="operator">=</span> queue.count</span><br><span class="line">        <span class="keyword">while</span> nodesLeftInCurrentLevel <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> queue.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : queue.removeFirst()  <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(node.value)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>)</span><br><span class="line">            node.children.forEach &#123; queue.append(<span class="variable">$0</span>) &#125;</span><br><span class="line">            nodesLeftInCurrentLevel <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/13/cover.jpg" alt="\#13\ 字典树（Tries Tree）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.166Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">19 分钟读完 (大约2865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-06-Data-Structures-&amp;-Algorithms-in-Swift-13/">\#13\ 字典树（Tries Tree）</a></h1><div class="content"><p><strong>Tries</strong> 是一颗用于存储可以表示为集合的数据的树，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>例如利用Tries表示一个英语单词，可以表示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/tries-word-eg.png"></p>
<p>字符串中的每一个字符被表示为一个节点，字符串中最后的节点会使用带有点号标识来标记为终止节点。通过在前缀匹配的上下文中查看字典树，会发现字典树的众多优点。</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>假设有一个字符串的集合，该如何构建每一个字符串的前缀匹配逻辑呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> words: [<span class="type">String</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">words</span>(<span class="params">matching</span> <span class="params">prefix</span>: <span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> words.filter &#123; <span class="variable">$0</span>.hasPrefix(<span class="keyword">prefix</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*words(matching:)*方法将会遍历字符串集合并返回与预设前缀匹配的字符串。</p>
<p>当<em>words</em>数组中的字符串个数比较少的时候，上述方法是可行且高效的，但是当字符串集合中的字符串数量到达几千，上述方法仅仅在数组的遍历上就会形成性能瓶颈。上述方法的时间复杂度为O(k * n)，其中k为字符串集合中最长的字符串，n 为字符串集合中需要检查的字符串数量。</p>
<p>对于此类问题，Tries数据结构有着出色的性能表现，作为具有支持多个子节点的节点的树，每个节点可以代表一个字符。通过跟踪从根节点到用点号标识的特殊终止节点的集合，形成一系列的单词组合。Tries的特点也是多个预表示的结果会共享节点集合。</p>
<p>为了进一步的了解和说明Tries的性能，假设已有如下的Tries结构，从中找出前缀CU代表的单词。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-1.png"></p>
<p>首先，从根节点出发，找到包含字符C的节点，找到后，就可以排除一些其他的子树，例如上图中根节点的两个子树。</p>
<p>然后，需要以C节点开始，在其子节点中寻找包含字符U的节点，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-2.png"></p>
<p>既然匹配的是前缀，因此在上图中以CU为前缀的节点将会被返回，上例中将返回CUT或CUTE。想象如果有上百上千的字符串，需要匹配前缀CU，Tries的数据结构可以避免多次的数据比较，提高匹配性能等。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/13/eg-cu-3.png"></p>
<h2 id="结构实现"><a href="#结构实现" class="headerlink" title="结构实现"></a>结构实现</h2><p>Tries本质上也是树型数据结构，因此会有节点，首先实现其节点的数据结构。</p>
<h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Key</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> parent: <span class="type">TrieNode</span>?</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> children: [<span class="type">Key</span>: <span class="type">TrieNode</span>] <span class="operator">=</span> [:]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">key</span>: <span class="type">Key</span>?, <span class="params">parent</span>: <span class="type">TrieNode</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tries的节点结构和其他树型数据结构有明显的不同。</p>
<ul>
<li><strong>key：</strong> 存储节点的数据。由于根节点不存储数据，因此该属性为optional类型；</li>
<li><strong>parent：</strong>当前节点父节点的弱引用，在节点的删除中将会利用此属性高效完成节点删除操作；</li>
<li><strong>children：</strong>在BST中，一个节点拥有左节点和右节点，在Tries中，一个节点会持有多个不同的元素，因此<strong>children</strong>被定义为字典类型；</li>
<li><strong>isTerminating：</strong>标记当前节点是否是集合的终止节点。</li>
</ul>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span>&lt;<span class="title class_">CollectionType</span>: <span class="title class_">Collection</span>&gt; <span class="title class_">where</span> <span class="title class_">CollectionType</span>.<span class="title class_">Element</span>: <span class="title class_">Hashable</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> <span class="operator">=</span> <span class="type">TrieNode</span>&lt;<span class="type">CollectionType</span>.<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> root <span class="operator">=</span> <span class="type">Node</span>(key: <span class="literal">nil</span>, parent: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <em>Trie</em>类是为所有采用Collection协议的类型构建的，包括<em>String</em>。除此之外，集合中的每一个元素都是可哈希的，因为集合中的每一个元素都会作为<em>TrieNode</em>中<em>children</em>的<em>key</em>。</p>
<p> 基本的结构完成了，接下来就是为Trie实现基本的节点操作方法，包括<em>insert</em>、<em>contains</em>、<em>remove</em>以及前缀匹配算法。</p>
<h2 id="操作算法实现"><a href="#操作算法实现" class="headerlink" title="操作算法实现"></a>操作算法实现</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Trie结构可以适用于任何Collection的类型，Trie采用集合并将集合中的每一个元素表示为一个节点，节点和元素之间形成映射的关系。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">        <span class="keyword">if</span> current.children[element] <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">            current.children[element] <span class="operator">=</span> <span class="type">Node</span>(key: element, parent: current)</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> current.children[element]<span class="operator">!</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    current.isTerminating <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>current</strong> 变量保持着对遍历进度的追踪，开始于Trie树的根节点;</li>
<li>Trie树的每一个节点与集合中的每一个元素相对应。对于集合中的每一个元素，首先要检查子节点字典中是否存在当前元素，如果不存在，则创建一个新节点，之后将循环移至下一个分支节点；</li>
<li><strong>for</strong>循环迭代完成之后，<strong>current</strong>指向集合中最后一个元素，也就是current节点已经是终止节点了，此时设置其终止标志<strong>isTerminating</strong>为<strong>true</strong>。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k 是待插入元素的集合中元素的个数。因为在插入算法中，需要遍历集合中的每一个元素，并可能为每一个元素创建新的节点。</p>
<h3 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h3><p><strong>contains</strong> 非常类似于 <strong>insert</strong> 算法，其目标是检查集合中的元素在Trie中是否存在。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">contains</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current.isTerminating</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对集合的遍历类似于insert，如果集合中的元素在Trie中不存在，则直接返回，否则依次移动current至子节点，继续遍历检查，直到元素遍历完成，此时current节点是否为终止节点，即为返回结果。如果最终所有的元素都没有在Trie树中找到，则该集合并没有添加到Trie树中，可能其只是更大集合的一个子集而已。</p>
<p>该操作的时间复杂度为O(k)，同样的 k 是待查找的集合中元素的个数。因为需要对集合中的每一个元素进行遍历，以检查其是否处于Trie树中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;insert and contains&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> trie.contains(<span class="string">&quot;cute&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cute is in the trie&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of insert and contains---</span></span><br><span class="line"><span class="comment">cute is in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h3><p>移除Trie树中的一个节点相对复杂一点，尤其当一个节点被两个不同的集合所共享的时候，需要更加的小心。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">collection</span>: <span class="type">CollectionType</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> collection &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            current <span class="operator">=</span> child</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> current.isTerminating <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        current.isTerminating <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> parent <span class="operator">=</span> current.parent, current.children.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>current.isTerminating &#123;</span><br><span class="line">            parent.children[current.key<span class="operator">!</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            current <span class="operator">=</span> parent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>准备移除之前的检查工作，类似于contains操作。在这里是为了检查集合是否存在于Trie树中，以及将current指向集合的最后一个节点；</li>
<li>设置current节点的<em>isTerminating</em>为false，目的是为了在下一次的循环中，节点能够被移除掉；</li>
<li>最后的while循环是相对棘手的部分。因为节点是可以被共享的，因此不希望在删除节点时误删掉另一个集合中的节点，如果当前节点再无子节点，则说明其他集合不依赖当前节点。同时还需检查当前节点是否为终止节点，如果是终止节点，则说明当前节点属于另一个集合，不能进行删除，如果不是终止节点，就可以不断的使用回溯父节点属性，并进行对应元素的删除。</li>
</ul>
<p>该操作的时间复杂度为O(k)，其中 k  是待删除集合中元素的个数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cute&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** Before removeing ***&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cut<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is in the trie&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>*** After removing cut ***&quot;</span>)</span><br><span class="line">    trie.remove(<span class="string">&quot;cut&quot;</span>)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="operator">!</span>trie.contains(<span class="string">&quot;cut&quot;</span>))</span><br><span class="line">    <span class="built_in">assert</span>(trie.contains(<span class="string">&quot;cute&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span>cute<span class="subst">\&quot;</span> is still in the trie&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of remove---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Before removeing ***</span></span><br><span class="line"><span class="comment">&quot;cut&quot; is in the trie</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is in the trie</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** After removing cut ***</span></span><br><span class="line"><span class="comment">&quot;cute&quot; is still in the trie</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Prefix-matching"><a href="#Prefix-matching" class="headerlink" title="Prefix matching"></a>Prefix matching</h3><p>Trie树最具标志性的算法是<strong>前缀匹配</strong>算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Trie</span> <span class="title class_">where</span> <span class="title class_">CollectionType</span>: <span class="title class_">RangeReplaceableCollection</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对<strong>CollectionType</strong>进行<strong>RangeReplaceableCollection</strong>限制，因为在实际的操作中，需要使用<strong>RangeReplaceableCollection</strong>中的<strong>append</strong>方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> root</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">prefix</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child <span class="operator">=</span> current.children[element] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        current <span class="operator">=</span> child</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> collections(startingWith: <span class="keyword">prefix</span>, after: current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查Trie树中是否包含预检索的前缀，如果不包含则返回空数组；</li>
<li>当检查得到预检索的前缀后，将其所在的节点传递给辅助方法*collections(startingWith:after:)*，递归查找所有顺序。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">collections</span>(<span class="params">startingWith</span> <span class="params">prefix</span>: <span class="type">CollectionType</span>, <span class="params">after</span> <span class="params">node</span>: <span class="type">Node</span>) -&gt; [<span class="type">CollectionType</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> results: [<span class="type">CollectionType</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.isTerminating &#123;</span><br><span class="line">        results.append(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> node.children.values &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> <span class="operator">=</span> <span class="keyword">prefix</span></span><br><span class="line">        <span class="keyword">prefix</span>.append(child.key<span class="operator">!</span>)</span><br><span class="line">        results.append(contentsOf: collections(startingWith: <span class="keyword">prefix</span>, after: child))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先构建一个空的数组变量，以保存输出结果。如果当前节点是终止节点，则直接添加当前节点到结果数组中，因为预检索前缀所在的节点此时也是一个结果；</li>
<li>接下来，需要检查当前节点的子节点，针对每一个子节点，递归调用*collections(startingWith:after:)*方法，寻找其他终止节点。</li>
</ul>
<p>*collections(startingWith:)*方法的时间复杂度为O(k * m)，其中 k 表示与前缀匹配最长的集合，m 表示与前缀匹配的集合数。数组的时间复杂度为O（k *n），其中n是集合中元素的数量。</p>
<p>对于每个集合中均匀分布的大量数据，与使用数组进行前缀匹配相比，Trie的性能要好得多。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;prefix matching&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> trie <span class="operator">=</span> <span class="type">Trie</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    trie.insert(<span class="string">&quot;car&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;card&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;care&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cared&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cars&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carbs&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;carapace&quot;</span>)</span><br><span class="line">    trie.insert(<span class="string">&quot;cargo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>car<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCar <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;car&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCar)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\n</span>Collections starting with <span class="subst">\&quot;</span>care<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> prefixedWithCare <span class="operator">=</span> trie.collections(startingWith: <span class="string">&quot;care&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(prefixedWithCare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of prefix matching---</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;car&quot;</span></span><br><span class="line"><span class="comment">[&quot;car&quot;, &quot;cars&quot;, &quot;card&quot;, &quot;carbs&quot;, &quot;cargo&quot;, &quot;care&quot;, &quot;cared&quot;, &quot;carapace&quot;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Collections starting with &quot;care&quot;</span></span><br><span class="line"><span class="comment">[&quot;care&quot;, &quot;cared&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>Trie树在前缀匹配上有着卓越的性能表现；</li>
<li>Tries具有相对较高的内存效率，因为各个节点可以在许多不同的值之间共享。例如，“car”，“carbs”和“care”可以共享单词的前三个字母。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/19/cover.jpg" alt="\#19\ 基数排序（Radix Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:34:32.165Z" title="4/30/2022, 2:34:32 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">9 分钟读完 (大约1354个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-01-Data-Structures-&amp;-Algorithms-in-Swift-19/">\#19\ 基数排序（Radix Sort）</a></h1><div class="content"><p>**基数排序[Radix Sort]**是一种在线性时间内对整数进行排序的非比较算法。</p>
<p>为了简单起见，在本文中将关注以10为基数的整数排序，以及基数排序中的*最小有效位[LSD]*的变体等。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了进行基数排序的工作方式，假设需要对如下的集合进行排序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>基数排序依赖于整数的位置表示法，如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/integer-base.png"></p>
<p>首先，按照最小有效位—个位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-1.png"></p>
<p>然后按照个位数从小至大的顺序对上图元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">410</span>, <span class="number">20</span>, <span class="number">1772</span>, <span class="number">88</span>]</span><br></pre></td></tr></table></figure>

<p>接下来，重复上述步骤，按照十位对集合中的元素进行拆分：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-2.png"></p>
<p>此时按照十位拆分后再进行排序后，和按照个位排序的结果相同，因此此时不进行重排。</p>
<p>继续按照百位堆集合中的元素进行拆解，拆解后如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-3.png"></p>
<p>有一些元素可能没有百位数，或者其他位也可能没有数，此时拆解时将其赋值为0即可。按照百位重新对集合元素进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>最后，在堆集合中的元素进行千位拆解：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/19/eg-4.png"></p>
<p>重新按照千位拆解结果进行排序，结果如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array <span class="operator">=</span> [<span class="number">20</span>, <span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>]</span><br></pre></td></tr></table></figure>

<p>当多个数组出现在拆解后的结果中时，则其排序不需要更改。例如在百位拆解中，20在88之前，因为在十位拆解时，20的拆解结果2和88的拆解结果8已经决定了20在88之前。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">radixSort</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> base <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> digits <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>done &#123;</span><br><span class="line">            <span class="comment">// more to come</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基数排序针对的是整数集合，因此在算法实现中直接对集合类型Array进行扩展，并制定元素类型为Int。上述函数定义和相关变量和逻辑相对简单，具体如下：</p>
<ol>
<li>使用10为基数堆整数进行拆解和排序。因为在算法执行过程中需要多次使用这个基数，因此使用变量<em>base</em>进行存储；</li>
<li>使用两个变量是否结束done和数字digit变量对执行过程进行追踪。基数排序在执行过程中有多次的遍历，done变量以标识整个遍历过程是否结束，digit变量用来标识当前所处理的数字。</li>
</ol>
<p>接下来需要编写的是针对每一步进行排序的逻辑算法，可称之为**桶排序[Bucket Sort]**。</p>
<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>此排序算法主要是在<em>while</em>循环体中执行，具体如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buckets: [[<span class="type">Int</span>]] <span class="operator">=</span> .<span class="keyword">init</span>(repeating: [], count: base)</span><br><span class="line">            </span><br><span class="line">forEach &#123;</span><br><span class="line">    number <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> remainingPart <span class="operator">=</span> number <span class="operator">/</span> digits</span><br><span class="line">    <span class="keyword">let</span> digit <span class="operator">=</span> remainingPart <span class="operator">%</span> base</span><br><span class="line">    buckets[digit].append(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digits <span class="operator">*=</span> base</span><br><span class="line"><span class="keyword">self</span> <span class="operator">=</span> buckets.flatMap &#123; <span class="variable">$0</span> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用二维数组的方式初始化buckets。因为使用的基数是10，因此拆解后会有10个buckets；</li>
<li>对集合中的每一个元素进行拆分，并放置在对应的bucket中；</li>
<li>使用digit的内容更新为希望检查和更新数组的的下一个数字。<em>flatMap</em>方法将二维数组变成一维数组，即将每一部分bucket排序装进数组。</li>
</ol>
<p><strong>循环何时结束？</strong></p>
<p>上述实现虽然逻辑上能够很好的拆解元素，并进行排序，但是对于<em>while</em>循环并没有机会符合退出条件，因此会进入无限循环状态。要符合退出条件，添加如下条件：</p>
<ol>
<li>在<em>while</em>循环的开始，添加<em>done &#x3D; true</em>；</li>
<li>在forEach闭包结构中，增加如下语句：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remainingPart <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">    done <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要还有未排序的数字，<em>forEach</em>就会一直迭代，直到再无未排序的部分，<em>forEach</em>执行完毕。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;radix sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array <span class="operator">=</span> [<span class="number">88</span>, <span class="number">410</span>, <span class="number">1772</span>, <span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">    array.radixSort()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Radix sorted: <span class="subst">\(array)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of radix sort---</span></span><br><span class="line"><span class="comment">Original: [88, 410, 1772, 20]</span></span><br><span class="line"><span class="comment">Radix sorted: [20, 88, 410, 1772]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>基数排序</strong>是最快速的排序算法之一，其平均时间复杂度为O(k<em>n)，其中</em>k<em>为最大数字的有效位数，</em>n*为数组中整数的个数。</p>
<p>基数排序在<em>k</em>为常数时最有效，当数组中所有数字的有效位数都相同时，基数排序最有效。它的时间复杂度变成了O(n)，基数排序也会带来O(n)空间复杂度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li><p>不像之前的排序算法，基数排序是一种非比较性排序，它不依赖于两个值之间的比较。基数排序利用桶排序，桶排序类似于筛选值的筛子；</p>
</li>
<li><p>基数排序是最快速的排序算法之一，利用了数字的位置等；</p>
</li>
<li><p>本文讨论了最小有效数字基数排序。另一种实现基数排序的方法是最有效的数字形式。这种形式通过优先排列最有效的数字而不是最不重要的数字进行排序。</p>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/6/cover.jpg" alt="\#6\ Linked List 挑战"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.105Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.106Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1703个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2019-12-05-Data-Structures-&amp;-Algorithms-in-Swift-06/">\#6\ Linked List 挑战</a></h1><div class="content"><p>本文内容将针对LinkedList的五大通用性场景问题，进行求解。这些问题相比多数挑战来说相对简单，主要是为了巩固关于LinkedList的知识。</p>
<h2 id="Challenge-1：创建按照反向顺序打印链表元素的函数。"><a href="#Challenge-1：创建按照反向顺序打印链表元素的函数。" class="headerlink" title="Challenge 1：创建按照反向顺序打印链表元素的函数。"></a>Challenge 1：创建按照反向顺序打印链表元素的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// outut</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 解决此问题最简单直接的方式就是使用<strong>递归</strong>。由于递归允许构建回调堆栈，因此我们可以在递归的回调中调用<strong>print</strong>打印节点元素值。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">node</span>: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> node <span class="operator">=</span> node <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    printInReverse(node.next)</span><br><span class="line">    <span class="built_in">print</span>(node.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">printInReverse</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    printInReverse(list.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;printing in reverse&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printing in reverse: &quot;</span>)</span><br><span class="line">    printInReverse(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of printing in reverse---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Printing in reverse: </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>该算法的核心在于递归调用的部分，当节点存在的情况下，继续遍历当前节点的下一个节点，否则就是已经到了末尾节点，在递归的过程回调堆栈中打印节点值。该算法时间复杂度为**O(n)**。</p>
<h2 id="Challenge-2：创建返回链表中间节点值的函数。"><a href="#Challenge-2：创建返回链表中间节点值的函数。" class="headerlink" title="Challenge 2：创建返回链表中间节点值的函数。"></a>Challenge 2：创建返回链表中间节点值的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nil</span><br><span class="line">// middle is 3</span><br><span class="line"></span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line">// middle is 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 该问题的解决思路是利用<strong>双指针位移的偏移量</strong>的方式来进行求解，也就是说分别定义两个初始位置相同的指针，然后对链表进行遍历，遍历的过程中，其中一个针对每次位移两个位置，另一个位移一个位置，位移快的那个移动到链表末尾时，慢的那个正好是链表的中间位置。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getMiddle</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Node</span>&lt;<span class="type">T</span>&gt;? &#123;</span><br><span class="line">    <span class="keyword">var</span> fast <span class="operator">=</span> list.head</span><br><span class="line">    <span class="keyword">var</span> slow <span class="operator">=</span> list.head</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> nextFast <span class="operator">=</span> fast<span class="operator">?</span>.next &#123;</span><br><span class="line">        fast <span class="operator">=</span> nextFast.next</span><br><span class="line">        slow <span class="operator">=</span> slow<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>测试和结果检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;getting the middle node&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> middleNode <span class="operator">=</span> getMiddle(list) &#123;</span><br><span class="line">        <span class="built_in">print</span>(middleNode.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of getting the middle node---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度是**O(n)<strong>。也可以使用另一种解法，先遍历依次整个链表，记录节点总数，然后取链表节点总数的一半，再次进行遍历，获取中间值，但是这样的解法需要遍历两次，时间复杂度为</strong>O(n^2)**。</p>
<h2 id="Challenge-3：创建反转链表的函数。"><a href="#Challenge-3：创建反转链表的函数。" class="headerlink" title="Challenge 3：创建反转链表的函数。"></a>Challenge 3：创建反转链表的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// LinkedList</span><br><span class="line">// Before</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; nil</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">3 -&gt; 2 -&gt; 1 -&gt; nil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该问题简单的解决方案是，新建一个LinkedList，然后遍历原LinkedList，将节点一个一个的push到新的LinkedList，最后更新原LinkedList的头节点即可。但是这样的方式会有一个性能问题，就是每次调用push方法的时候，都需要分配新的节点，造成了绝大的资源成本。另一种代码较为复杂，但是性能上却相当好的方案是，构建两个变量，分别指向当前节点和上一个节点，然后遍历LinkedList，依次向后交换当前节点和上一个节点的指向，直到当前节点为nil时结束，这样就完全避免了每次新建节点的资源消耗问题。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 1</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionOne</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> tempList <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Value</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        tempList.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> tempList.head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse solution 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">reverseSolutionTwo</span>() &#123;</span><br><span class="line">    tail <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">    <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">    prev<span class="operator">?</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> current <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> next <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        current<span class="operator">?</span>.next <span class="operator">=</span> prev</span><br><span class="line">        prev <span class="operator">=</span> current</span><br><span class="line">        current <span class="operator">=</span> next</span><br><span class="line">    &#125;</span><br><span class="line">    head <span class="operator">=</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然两种解决方案都是完整该挑战，但是在时间复杂度相同的情况下，空间复杂度更好的解决方案2，是应该遵循且掌握的方式。算法2的思路图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/reversed-list.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;reverse the list solution 2&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list.push(<span class="number">3</span>)</span><br><span class="line">    list.push(<span class="number">2</span>)</span><br><span class="line">    list.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Original list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">    list.reverseSolutionTwo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Reversed list: <span class="subst">\(list)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of reverse the list solution 2---</span></span><br><span class="line"><span class="comment">// Original list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Reversed list: 3 -&gt;2 -&gt;1 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"><a href="#Challenge-4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。" class="headerlink" title="Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。"></a>Challenge 4：创建一个函数，该函数接收两个已排序的链表，并合并到单个排序的链表中。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// list1</span><br><span class="line">1 -&gt; 4 -&gt; 10 -&gt; 11</span><br><span class="line"></span><br><span class="line">// list2</span><br><span class="line">-1 -&gt; 2 -&gt; 3 -&gt; 6</span><br><span class="line"></span><br><span class="line">// merged list</span><br><span class="line">-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6 -&gt; 10 -&gt; 11</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此问题的解决方案是不断从两个已排序的列表中摘取节点，并将它们添加到新列表中。由于两个列表已经排序，因此可以比较两个列表的下一个节点，以查看哪个节点应该是要添加到新列表的下一个节点。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">mergeSort</span>&lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> <span class="params">left</span>: <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">_</span> <span class="params">right</span>:<span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 检查输入的两个链表是否为空，如果其中一个为空，则直接返回另一个</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>left.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>right.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果链表的head、tail定义</span></span><br><span class="line">    <span class="keyword">var</span> newHead: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> tail: <span class="type">Node</span>&lt;<span class="type">T</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> currentLeft <span class="operator">=</span> left.head</span><br><span class="line">    <span class="keyword">var</span> currentRight <span class="operator">=</span> right.head</span><br><span class="line">    <span class="comment">// 检查left、right的首个节点，并将小的节点赋值给newHead</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            newHead <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newHead <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> newHead</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="comment">// 遍历left、right，尝试挑选能够加入新链表的节点，直到其中一个链表到达末尾节点</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> leftNode <span class="operator">=</span> currentLeft, <span class="keyword">let</span> rightNode <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        <span class="comment">// 比较节点值大小，并将小的链接到tail.next</span></span><br><span class="line">        <span class="keyword">if</span> leftNode.value <span class="operator">&lt;</span> rightNode.value &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> leftNode</span><br><span class="line">            currentLeft <span class="operator">=</span> leftNode.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail<span class="operator">?</span>.next <span class="operator">=</span> rightNode</span><br><span class="line">            currentRight <span class="operator">=</span> rightNode.next</span><br><span class="line">        &#125;</span><br><span class="line">        tail <span class="operator">=</span> tail<span class="operator">?</span>.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上个while循环同时以来currentLeft和currentRight，因此即使链表中还有节点，循坏也可能提前终止。需要将剩余的节点链接到处理单元中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> leftNodes <span class="operator">=</span> currentLeft &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> leftNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> rightNodes <span class="operator">=</span> currentRight &#123;</span><br><span class="line">        tail<span class="operator">?</span>.next <span class="operator">=</span> rightNodes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建结果链表，这里不使用push或者append的方式，而是直接指定链表的head、tail</span></span><br><span class="line">    <span class="comment">// head只有一个节点，直接复制，tail包含了很多节点，需要一个一个地进行链接</span></span><br><span class="line">    <span class="keyword">var</span> list <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    list.head <span class="operator">=</span> newHead</span><br><span class="line">    list.tail <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next <span class="operator">=</span> tail<span class="operator">?</span>.next &#123;</span><br><span class="line">            tail <span class="operator">=</span> next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法求解过程的图示：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/MergeTwolinkedLists.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;merging two sorted list&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> list2 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">2</span>)</span><br><span class="line">    list2.push(<span class="operator">-</span><span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;First list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Second list: <span class="subst">\(list2)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> mergedList <span class="operator">=</span> mergeSort(list1, list2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merged list: <span class="subst">\(mergedList)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of merging two sorted list---</span></span><br><span class="line"><span class="comment">// First list: 1 -&gt;2 -&gt;3  </span></span><br><span class="line"><span class="comment">// Second list: -3 -&gt;-2 -&gt;-1  </span></span><br><span class="line"><span class="comment">// Merged list: -3 -&gt;-2 -&gt;-1 -&gt;1 -&gt;2 -&gt;3 </span></span><br></pre></td></tr></table></figure>

<h2 id="Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。"><a href="#Challenge-5：创建从链表中删除特定元素的所有匹配项的函数。" class="headerlink" title="Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。"></a>Challenge 5：创建从链表中删除特定元素的所有匹配项的函数。</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// original list</span><br><span class="line">1 -&gt; 3 -&gt; 3 -&gt; 3 -&gt; 4</span><br><span class="line"></span><br><span class="line">// list after removing all occurrences of 3</span><br><span class="line">1 -&gt; 4</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">LinkedList</span> <span class="title class_">where</span> <span class="title class_">Value</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeAll</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Value</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> head <span class="operator">=</span> <span class="keyword">self</span>.head, head.value <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">self</span>.head <span class="operator">=</span> head.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> head</span><br><span class="line">        <span class="keyword">var</span> current <span class="operator">=</span> head<span class="operator">?</span>.next</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> currentNode <span class="operator">=</span> current &#123;</span><br><span class="line">            <span class="keyword">guard</span> currentNode.value <span class="operator">!=</span> value <span class="keyword">else</span> &#123;</span><br><span class="line">                prev<span class="operator">?</span>.next <span class="operator">=</span> currentNode.next</span><br><span class="line">                current <span class="operator">=</span> prev<span class="operator">?</span>.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev <span class="operator">=</span> current</span><br><span class="line">            current <span class="operator">=</span> current<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail <span class="operator">=</span> prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/6/delete-duplicate.png"></p>
<p>测试算法及检验结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;deleting duplicate nodes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list1 <span class="operator">=</span> <span class="type">LinkedList</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">    list1.push(<span class="number">3</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">2</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    list1.push(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Origin list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">    list1.removeAll(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Delete duplicate list: <span class="subst">\(list1)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---Example of deleting duplicate nodes---</span></span><br><span class="line"><span class="comment">// Origin list: 1 -&gt;1 -&gt;2 -&gt;2 -&gt;2 -&gt;3     </span></span><br><span class="line"><span class="comment">// Delete duplicate list: 1 -&gt;1 -&gt;3 </span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/16/cover.png" alt="\#16\ 优先级队列"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.103Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1146个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-12-Data-Structures-&amp;-Algorithms-in-Swift-16/">\#16\ 优先级队列</a></h1><div class="content"><p>队列是一种先进先出（FIFO）的数据结构，而优先级队列是另一种队列结构，其可替代队列的先进先出顺序，该队列中的元素有着优先级的顺序。一个优先级队列也可以是：</p>
<ol>
<li><strong>最大优先级队列：</strong>队列中最前面的元素具有最高优先级；</li>
<li><strong>最小优先级队列：</strong>队列中最前面的元素具有最低优先级。</li>
</ol>
<p>当需要在给定的元素列表中取标定最大元素和最小元素时，优先级队列将是非常合适的一种数据结构。</p>
<h2 id="优先级队列的典型应用"><a href="#优先级队列的典型应用" class="headerlink" title="优先级队列的典型应用"></a>优先级队列的典型应用</h2><ul>
<li><strong>迪克斯特拉的算法（Dijkstra’s algorithm）</strong>，使用优先级队列计算最小代价。</li>
<li><strong>A*路径寻找算法</strong>，使用优先级队列跟踪对位置路径进行探索的最短路径。</li>
<li><strong>堆排序</strong>，可以使用优先级队列实现。</li>
<li><strong>哈夫曼编码</strong>会构建一个压缩树。最小优先级队列用于重复查找两个频率最小的节点，这些节点未具有父节点。</li>
</ul>
<p>优先级队列的应用范围很广，远不止上述列举的部分。</p>
<h2 id="一般操作"><a href="#一般操作" class="headerlink" title="一般操作"></a>一般操作</h2><p>在 <a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-08/">#8\ 队列的Swift实现与操作定义</a>中我们为队列定义了如下的一个协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span>  <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>?</span><br><span class="line">    <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级队列和普通队列同样有着相同的操作，只是具体的实现会有所不同。</p>
<p>对于优先级队列而言，同样对遵循协议<strong>Queue</strong>，并实现一些一般性的操作如下：</p>
<ul>
<li><strong>enqueue：</strong>插入一个元素到队列，如果操作成功，则返回<em>true</em>；</li>
<li><strong>dequeue：</strong>移除具有最高优先级的元素，并返回它，如果队列为空，则返回<em>nil</em>；</li>
<li><strong>isEmpty：</strong>检查队列是否为空；</li>
<li><strong>peek：</strong>返回具有最高优先级的队列，但并不进行删除，如果队列为空，则返回<em>nil</em>。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>构建优先级队列的方式有以下几种：</p>
<ol>
<li><strong>已排序数组</strong>：在获取最大值或最小值的时间复杂度均为O(1)，使用此数据构建优先级队列非常有效，但是其插入算法却比较慢，会达到O(n)的时间复杂度。</li>
<li><strong>平衡二叉搜索树</strong>：在创建双端优先级队列时，使用平衡二叉搜索树最为有利，此时获取最小值和最大值的时间复杂度均在_O(log n)，插入算法比排序的数组会更好，在O(log n)。</li>
<li><strong>堆</strong>：优先级队列最佳的选择，堆结构比排序的数组更为有效，因为堆只需要部分排序，除了从最小堆中获取最小值和从最大堆中获取最大值为O(1)的快速外，其他的操作均为O(log n)的时间复杂度。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Equatable</span>&gt;: <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> heap: <span class="type">Heap</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>, <span class="params">elements</span>: [<span class="type">Element</span>] <span class="operator">=</span> []) &#123;</span><br><span class="line">        heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><em>PriorityQueue</em> 遵循队列协议<em>Queue</em>。泛型参数元素必须遵循<em>Equatable</em>，因为在元素的操作中需要能够进行元素间的比较。</li>
<li>使用堆数据结构实现优先级队列；</li>
<li>传递合适的参数到初始化构造函数，<em>PriorityQueue</em>可根据参数构建最小和最大优先级队列。</li>
</ol>
<p>为了遵循<em>Queue</em>协议，需要增加如下的协议方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> peek: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.peek()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    heap.insert(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> heap.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中优先级队列上，堆是最为完美的选择，只需要调用堆的各种方法即可实现优先级队列的各种操作。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;priorityQueue&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> priorityQueue <span class="operator">=</span> <span class="type">PriorityQueue</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>priorityQueue.isEmpty &#123;</span><br><span class="line">        <span class="built_in">print</span>(priorityQueue.dequeue()<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of priorityQueue---</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>一个优先级队列通常使用<strong>优先级顺序</strong>进行元素的查找；</li>
<li>能够通过关注队列的关键操作而排除堆数据结构提供的其他功能，从而创建抽象层。</li>
<li>使得优先级队列的意图清晰而简洁。唯一的工作是排队和取消排队元素。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/20/cover.jpg" alt="\#20\ 堆排序（Heap Sort）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.102Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">8 分钟读完 (大约1206个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-02-03-Data-Structures-&amp;-Algorithms-in-Swift-20/">\#20\ 堆排序（Heap Sort）</a></h1><div class="content"><p>**堆排序[Heap Sort]**是另一种基于比较的排序算法，其利用堆对数组进行升序排序。关于堆数据结构，可以查看<a target="_blank" rel="noopener" href="https://robinchao.github.io/Data-Structures-&-Algorithms-in-Swift-15/">\#15\ 堆数据结构（The Heap Data Structure）</a>中的介绍。</p>
<p>堆排序使用的是堆的优势，根据堆的定义，一个部分排序的二叉树具有如下的特质：</p>
<ol>
<li>在最大堆中，所有的父节点均大于其孩子节点；</li>
<li>在最小堆中，所有的父节点均小于其孩子节点。</li>
</ol>
<p>最大堆和最小堆的图示如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/max-min-heap.png"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对于给定的未排序的数组，从小到大进行排序，堆排序都必须首先将该数组转换为最大堆结构。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-1.png"></p>
<p>对上述数组通过筛选所有父节点进行转换，此时使用sift-down方式，最终转换后的结果如下：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-2.png"></p>
<p>对应的数组为：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-3.png"></p>
<p>由于单次sift-down操作的时间复杂度为O(log n)，因此构建一个堆的整体时间复杂度为O(n log n)。</p>
<p>堆排序是将数组元素进行升序排序。因为在最大堆中，最大的元素通常位于根节点，因此可以<strong>使用索引0的元素和索引n-1的元素进行直接交换</strong>。这样交换后，数组最后的元素便位于正确地位置，但是此时堆已经不符合堆的规则了。下一步对新的根节点元素进行sift-down操作，使得堆成立。（此时进行sift-down的时候，需要将排除部分已排序好的元素）</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-4.png"></p>
<p>对元素5进行sift-down之后，新的根节点为原始堆中第二大的元素21，此时同样和末尾元素6进行交换，交换后继续对新的根节点6进行sift-down操作，再次使得堆成立。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-5.png"></p>
<p>上述过程其实形成了一种模式，堆排序简单直接，每次交换首末两个元素，较大的元素依次被交换到数组的后面，多次交换完成后，数组变成了从小到大的顺序，也完成了堆排序。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/20/eg-6.png"></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>堆排序的实现是基于堆的数据结构基础上的，是对堆结构的一种功能扩展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftSown</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>, <span class="params">upTo</span> <span class="params">size</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> parent <span class="operator">=</span> index</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">               <span class="keyword">let</span> left <span class="operator">=</span> leftChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">let</span> right <span class="operator">=</span> rightChildIndex(ofParentAt: parent)</span><br><span class="line">               <span class="keyword">var</span> candidate <span class="operator">=</span> parent</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> left <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[left], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> left</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> right <span class="operator">&lt;</span> size <span class="operator">&amp;&amp;</span> sort(elements[right], elements[candidate]) &#123;</span><br><span class="line">                   candidate <span class="operator">=</span> right</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> candidate <span class="operator">==</span> parent &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               elements.swapAt(parent, candidate)</span><br><span class="line">               parent <span class="operator">=</span> candidate</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sorted</span>() -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: sort, elements: elements)</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> heap.elements.indices.reversed() &#123;</span><br><span class="line">            heap.elements.swapAt(<span class="number">0</span>, index)</span><br><span class="line">            heap.siftSown(from: <span class="number">0</span>, upTo: index)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要对原来Heap结构的sift-down方法进行改造，增加参数size以标记当前集合的大小。</p>
</blockquote>
<p>堆排序算法工作流程如下：</p>
<ol>
<li>首先对原有堆进行一个拷贝。因为在堆排序堆元素集合进行排序后，原有的堆结构将不再成立，为了保持堆结构成立，这里使用其拷贝进行排序；</li>
<li>从集合末尾元素开始，对集合进行遍历；</li>
<li>交换首末位置的元素，此次交换后，最大的元素将位于集合的末尾；</li>
<li>交换元素位置后，堆结构已经不成立了，因此需要使用sift-down方法对集合重新调整，已重生合法的堆结构，完成后，新的根节点将是原集合中第二大的元素。重复第三步即可。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;heap sort&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">6</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">9</span>, <span class="number">5</span>])</span><br><span class="line">    <span class="built_in">print</span>(heap.sorted())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of heap sort---</span></span><br><span class="line"><span class="comment">[2, 5, 6, 8, 9, 12, 18, 21, 26]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>堆排序的最佳、最差和平均性能都是O(n log n)。因为必须遍历整个列表一次，并且每次交换元素时，都必须执行向下筛选sift-down操作，这是一个O(log n)操作。</p>
<p>堆排序也不是一种稳定的排序，因为它取决于元素如何布局和放入堆中。例如，如果您正在根据一副纸牌的等级对其进行堆排序，您可能会看到它们的套件相对于原始纸牌的顺序发生了变化。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>堆排序利用最大堆数据结构对数组中的元素进行排序。</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/14/cover.jpg" alt="\#14\ 二分查找（Binary Search）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">11 分钟读完 (大约1587个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-07-Data-Structures-&amp;-Algorithms-in-Swift-14/">\#14\ 二分查找（Binary Search）</a></h1><div class="content"><p>二分查找是时间复杂度为O(log n)的搜索算法中较为高效的算法之一，这一点和在平衡的二叉搜索树中搜索元素的时间复杂度相当。在使用二分查找之前，有两个条件需要预先满足：</p>
<ul>
<li>集合必须是在恒定的时间内执行索引操作，意味着集合必须是<strong>RandomAccessCollection</strong>类型的；</li>
<li>集合必须是<strong>sorted</strong>的。</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>在Swift标准库中的Array结构中，通过*index(of:)*来实现线性的元素搜索，也就是意味着Array中的元素搜索需要遍历整个数组。</p>
<blockquote>
<p>在Swift 5中<em>index(of:)</em> 已经废弃，取而代之的为*firstIndex(of:)*。</p>
</blockquote>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/array-linear-search.png"></p>
<p>而二分查找则是在已排序的数组上，以不同的处理方式进行元素的搜索。例如下图所示，在已排序的数组中搜索元素31：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-31.png"></p>
<p>和一般的数组元素查找不同的是，二分查找按照如下的步骤进行元素的搜索：</p>
<p><strong>Step 1：找到中间位置的索引</strong></p>
<p>二分查找第一步，便是找到集合中间位置，这一步非常直接，通过集合的元素总数进行计算获得：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/step-1-find-middle-index.png"></p>
<p><strong>Step 2：检查中间索引位置的元素</strong></p>
<p>下一步则是检查中间位置的元素，如果和预检索的元素匹配，则直接返回索引，如果不相符，则继续第三步，继续检索元素。</p>
<p><strong>Step 3：递归进行二分查找</strong></p>
<p>最后一步是递归调用二分查找，但是这时，仅仅需要检索的是集合中间索引左侧或者右侧，而非整个集合。当中间位置的元素小于预检索的元素时，则检索中间位置右侧，反之，检索中间位置左侧。</p>
<p>二分查找每一步的检索之后，都会减少一半的检索范围，这样大大的减小了检索的时间耗时，提高检索效率。</p>
<p>在上述例子中，为了检索元素31，由于中间位置的元素为22，小于预检索的元素31，因此将继续检索中间位置元素22的右侧元素：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/14/binary-search-22-right.png"></p>
<p>二分查找从大的方面来说，每一次的元素检索只需要三步，直到无法将集合再次进行左右划分或者找到元素为止。</p>
<p>二分查找的时间复杂度为O(log n)。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>首先定义二分查找使用范围，以及集合元素的可比较性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>? &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>由于二分查找仅仅适用于集合类型<strong>RandomAccessCollection</strong>，并且其中的元素需要可比较的特性，因此针对该类型进行扩展并设定元素可比较性，并添加二分查找方法的定义；</li>
<li>二分查找在运行过程中需要递归调用，因此在函数定义中要执行每一次递归的范围，参数<strong>range</strong>是可选类型，在首次进行二分查找的时候，不需要传入<strong>range</strong>，故其默认值为<strong>nil</strong>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">RandomAccessCollection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">binarySearch</span>(<span class="params">for</span> <span class="params">value</span>: <span class="type">Element</span>, <span class="params">in</span> <span class="params">range</span>: <span class="type">Range</span>&lt;<span class="type">Index</span>&gt;? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Index</span>?&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> range <span class="operator">=</span> range <span class="operator">??</span> startIndex <span class="operator">..&lt;</span> endIndex</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> range.lowerBound <span class="operator">&lt;</span> range.upperBound <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> size <span class="operator">=</span> distance(from: range.lowerBound, to: range.upperBound)</span><br><span class="line">        <span class="keyword">let</span> middle <span class="operator">=</span> index(range.lowerBound, offsetBy: size <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">==</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span>[middle] <span class="operator">&gt;</span> value &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: range.lowerBound <span class="operator">..&lt;</span> middle)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(for: value, in: middle <span class="operator">..&lt;</span> range.upperBound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查<em>range</em>是否为<em>nil</em>，如果为<em>nil</em>，则获取集合完整的索引范围<em>startIndex ..&lt; endIndex</em>；</li>
<li>检查集合是否为空，这里的检查方式是通过集合的最小边界和最大边界进行判断集合是否至少有一个元素，否则直接返回<em>nil</em>；</li>
<li>通过集合的最小边界和最大边界，获取集合的长度，之后使用*index(offsetBy:)*方法获取集合中间位置的索引；</li>
<li>如果中间位置的元素就是我们要查找的元素，则直接返回中间位置索引；</li>
<li>如果中间位置的元素大于预查找的元素，则说明预查找元素在集合中间位置的左侧，递归调用*binarySearch(for:range:)*方法，继续查找；</li>
<li>如果中间位置的元素小于预查找的元素，则说明预查找的元素在集合中间位置的右侧，递归调用*binarySearch(for:range:)*方法，继续查找。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;binary search&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array <span class="operator">=</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">31</span>, <span class="number">105</span>, <span class="number">150</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> search31 <span class="operator">=</span> array.firstIndex(of: <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">let</span> binarySearch31 <span class="operator">=</span> array.binarySearch(for: <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index(of:): <span class="subst">\(String(describing: search31))</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;binarySearch(of:): <span class="subst">\(String(describing: binarySearch31))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of binary search---</span></span><br><span class="line"><span class="comment">index(of:): Optional(7)</span></span><br><span class="line"><span class="comment">binarySearch(of:): Optional(7)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>二分查找是一种强大的算法，每当某些场景下，集合的元素时已排序的情况下，都可以考虑使用二分查找的方法。另外，如果遇到的问题似乎进行元素搜索需要O(n^2)的时间复杂度，可以考虑先对集合进行前期的排序，然后采用二分查找的方法将时间复杂度降低到O(n log n)的程度。</p>
<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>二分查找仅仅对已排序的集合有效；</li>
<li>有时候，对集合进行排序后，再使用二分查找是有益的；</li>
<li>对于集合本身，其<em>sorted</em>方法的时间复杂度为O(n)，而二分查找的时间复杂度为O(log n)，对于大型数据集合来说，二分查找的可伸缩性更好。</li>
</ul>
<blockquote>
<p>二分查找思想典型的应用场景就是在Bug原因的追查上面，当面对一个无从知晓其最终的引发点的时候，可以尝试使用二分查找的思想，分段校验代码的执行结果，逐步缩小Bug追查的范围，提高Bug原因的追查效率等。</p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/30/2020-01-10-Data-Structures-&amp;-Algorithms-in-Swift-15/"><img class="fill" src="/images/Data-Structures-&amp;-Algorithms-in-Swift/15/cover.jpg" alt="\#15\ 堆数据结构（The Heap Data Structure）"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-04-30T06:33:12.100Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>发表</span><span class="level-item"><time dateTime="2022-04-30T06:33:12.101Z" title="4/30/2022, 2:33:12 PM">2022-04-30</time>更新</span><span class="level-item"> Robin </span><span class="level-item"><a class="link-muted" href="/categories/Data-Structures-Algorithms-in-Swift/">Data Structures &amp; Algorithms in Swift</a></span><span class="level-item">23 分钟读完 (大约3469个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/2020-01-10-Data-Structures-&amp;-Algorithms-in-Swift-15/">\#15\ 堆数据结构（The Heap Data Structure）</a></h1><div class="content"><p>想必抓娃娃机如今没有人不知道其实什么了，抓娃娃机的爪子总是那么的难以控制，总是看起来容易的机会却难以如愿。抓抓机的爪子其实就工作在一个堆数据结构之上，爪子每次抓的几乎都是那边一堆玩具最上面的那一个，只有这样机会才会更大一些。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/zhuawawa.png"></p>
<p>在本文中将学习关于堆（Heap）的基础知识，包含如何创建一个堆数据结构，如果从堆数据结构中获取最大和最小元素等。</p>
<h2 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h2><p>堆是一个使用数组构建的完整二叉树，也称为二叉堆。</p>
<blockquote>
<p>这里的堆和内存堆是完全不同的一个概念，需要区分。在计算机科学中，经常有一些术语被重复使用，但是涵义却有所不同，本文不会对内存堆进行阐述。</p>
</blockquote>
<p>堆有两种类型：</p>
<ol>
<li><strong>最大堆：</strong>堆中元素越大，其优先级越高；</li>
<li><strong>最小堆：</strong>堆中元素越小，其优先级越高。</li>
</ol>
<h2 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h2><p>一个堆结构，有着必须始终满足的重要特征，称之为<strong>堆不变式</strong>或<strong>堆属性</strong>。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/max-min-heap.png"></p>
<p>在最大堆中，父节点必须包含一个大于等于其子节点的值，根节点包含最大的值。</p>
<p>在最小堆中，父节点必须包含一个小于等于其子节点的值，根节点包含最小的值。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/level-heap.png"></p>
<p>另一个堆的必须属性是<strong>堆是一个完全二叉树</strong>。意味着树除了叶子节点层之外，其他每一层都必须被填充，有点类似某些闯关类游戏，本关没有完成，则下一关无法开始。</p>
<h2 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h2><p>堆在很多场景下都被广泛的应用，例如：</p>
<ul>
<li>计算集合中最小元素和最大元素；</li>
<li>堆排序</li>
<li>优先级队列构造</li>
<li>构造图算法，例如普林演算法 (Prim’s algorithm)或狄克斯特拉算法（Dijkstra’s algorithm）等。</li>
</ul>
<h2 id="常用的堆操作"><a href="#常用的堆操作" class="headerlink" title="常用的堆操作"></a>常用的堆操作</h2><p>首先定义Heap的数据结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&lt;<span class="title class_">Element</span>: <span class="title class_">Equatable</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">let</span> sort: (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sort <span class="operator">=</span> sort</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Heap的数据结构中，包含一个数组<em>elemtns</em>用来保存堆元素，一个<em>sort</em>函数定义堆中集合如何排序的排序函数。构造器接收一个适当的参数，后续用来构建最大和最小堆。</p>
<h2 id="如何表示堆？"><a href="#如何表示堆？" class="headerlink" title="如何表示堆？"></a>如何表示堆？</h2><p>树型结构中的节点能够保存值和其子节点的索引，二叉树同时保存左子树和右子树的引用。堆本质上是一颗二叉树，但是可以使用简单的数组进行表示。利用数组表示堆的好处是良好的时间复杂度和空间复杂度，因为这样堆中的元素保存在内存里，堆元素的交换等能够有良好的的性能表现，与使用二叉树来表示堆，使用数组更加的容易。接下来了解使用数组如何表示一个堆。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/array-heap-tree.png"></p>
<p>为了使用数组表示堆，只需要从左至右一层一层迭代元素即可。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/traversal-eg.png"></p>
<p>当遍历进入高层级的时候，所需要遍历节点数可能会成倍的增加。</p>
<p>现在可以轻松访问堆中的任何节点。您可以将这一点与访问数组中元素的方式进行比较：无需向下遍历左分支或右分支，只需使用简单公式访问数组中的节点即可。</p>
<p>例如给定一个以零为开始索引的 <em>i</em> 对应的节点：</p>
<ul>
<li>当前节点的左子树能够使用 <em>2i + 1</em> 进行访问；</li>
<li>当前节点的右子树能够使用 <em>2i + 2</em> 进行访问；</li>
</ul>
<p>如下图：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/index-math.png"></p>
<p>如果需要访问节点的父节点，依然可以使用索引值 <em>i</em> 求解，例如在索引为 <em>i</em> 的节点上，其父节点索引可通过 *floor( (i - 1) &#x2F; 2)*求得。</p>
<blockquote>
<p>在二叉树中，左子树和右子树的节点搜索需要O(log n)时间复杂度，但是通过数组的方式获取的时候，时间复杂度仅为O(1)。</p>
</blockquote>
<p>了解了堆的知识后，即可继续完善堆的数据结构，并为其添加一些方便的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">peek</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.first</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">leftChildIndex</span>(<span class="params">ofParentAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> <span class="operator">*</span> index) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">rightChildIndex</span>(<span class="params">ofParentAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> <span class="operator">*</span> index) <span class="operator">+</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">parentIndex</span>(<span class="params">ofChildAt</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (index <span class="operator">-</span> <span class="number">1</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从堆中移除元素"><a href="#从堆中移除元素" class="headerlink" title="从堆中移除元素"></a>从堆中移除元素</h2><p>最基本的元素节点移除操作是移除根节点，例如下图所示的移除最大堆中的根节点10：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/remove-max-heap.png"></p>
<p>此时，移除操作将移除位于根节点的集合最大值。首先要使用堆中最末尾的元素和根节点进行交换，一旦交换了元素，就可以删除位于叶子节点上的需要删除的元素了。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/delete-leaf-node.png"></p>
<p>但是，删除后的堆还是最大堆结构么？需要注意的是，最大堆的原则或者规则是每一个子节点的值都小于或等于父节点的值，一旦不符合这个规则，则需要进行节点的<strong>sift down</strong>调整。（最大堆调整算法称为<strong>sift down</strong>，最小堆调整算法称为** sift up**）</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down.png"></p>
<p>针对上图所示，<strong>sift down</strong>调整的方法是，获取根节点元素3，判断和其左子节点和右子节点的大小，如果左子节点的值大于当前节点，则进行节点的交换，如果左子节点和右子节点均大于该值，则使用子节点中大的那个值和当前节点进行交换。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down-2.png"></p>
<p>继续使用<strong>sift down</strong>调整法，调整节点，直到所有的节点满足最大堆的规则。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-down-done.png"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>() -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    elements.swapAt(<span class="number">0</span>, count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        siftSown(from: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先检查堆是否为空，如果为空，则返回<em>nil</em>；</li>
<li>交换根节点和堆中最后的元素位置；</li>
<li>移除集合中最后一个元素并返回该元素（最后一个元素不是最大值就是最小值）；</li>
<li>移除后，堆可能不符合最大堆或最小堆的原则，需要继续采用siftDown或者siftUp方法进行调整，直到符合堆的规则。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftSown</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parent <span class="operator">=</span> index</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> left <span class="operator">=</span> leftChildIndex(ofParentAt: parent)</span><br><span class="line">        <span class="keyword">let</span> right <span class="operator">=</span> rightChildIndex(ofParentAt: parent)</span><br><span class="line">        <span class="keyword">var</span> candidate <span class="operator">=</span> parent</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="operator">&lt;</span> count <span class="operator">&amp;&amp;</span> sort(elements[left], elements[candidate]) &#123;</span><br><span class="line">            candidate <span class="operator">=</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right <span class="operator">&lt;</span> count <span class="operator">&amp;&amp;</span> sort(elements[right], elements[candidate]) &#123;</span><br><span class="line">            candidate <span class="operator">=</span> right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> candidate <span class="operator">==</span> parent &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements.swapAt(parent, candidate)</span><br><span class="line">        parent <span class="operator">=</span> candidate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**siftDown(from:)**接受任意的索引，并将其视为根节点，该方法的工作原理是：</p>
<ol>
<li>临时保存索引到变量<em>parent</em>；</li>
<li>一直进行sifting操作，直到return（while true）；</li>
<li>获取<em>parent</em>索引所在节点的左节点和右节点对应的索引；</li>
<li>使用临时变量<em>candidate</em>追踪和父节点进行交换的节点索引；</li>
<li>如果是左节点，并且左节点相比父节点有更高的优先级，则<em>candidate</em>为左节点；</li>
<li>如果是右节点，并且右节点相比父节点有更高的优先级，则<em>candidate</em>为右节点；</li>
<li>如果<em>candidate</em>依然是<em>parent</em>，说明已经调整到末尾，再无sifting的必要了；</li>
<li>一轮sifting结束时，重新设定parent为候选的<em>candidate</em>，进行下一轮的sifting。</li>
</ol>
<h2 id="向堆中插入元素"><a href="#向堆中插入元素" class="headerlink" title="向堆中插入元素"></a>向堆中插入元素</h2><p>假设需要向如下的堆中插入元素7：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/insert-origin.png"></p>
<p>首先将待插入的元素添加到堆的末端：</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/insert-end.png"></p>
<p>之后，检查最大堆的堆属性。和<em>siftdown</em>不同的是，此时使用<em>siftup</em>方法，工作原理类似于<em>siftdown</em>，通过比较当前节点和其父节点进行节点的交换。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/siftup.png"></p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/siftup-done.png"></p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">insert</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        elements.append(element)</span><br><span class="line">        siftUp(from: elements.count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">siftUp</span>(<span class="params">from</span> <span class="params">index</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> child <span class="operator">=</span> index</span><br><span class="line">        <span class="keyword">var</span> parent <span class="operator">=</span> parentIndex(ofChildAt: child)</span><br><span class="line">        <span class="keyword">while</span> child <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> sort(elements[child], elements[parent]) &#123;</span><br><span class="line">            elements.swapAt(child, parent)</span><br><span class="line">            child <span class="operator">=</span> parent</span><br><span class="line">            parent <span class="operator">=</span> parentIndex(ofChildAt: child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入算法相较于移除算法，更为直接：</p>
<ul>
<li>首先直接向数组中追加待插入的元素，之后进行 <strong>sift up</strong> 调整；</li>
<li><em>siftUp</em>比较当前节点和其父节点，并进行条件进行交换，直到该节点有一个比其父节点更高的优先级为止。</li>
</ul>
<p>在从堆中移除元素的时候，删除算法只是移除了堆的根节点，但是非根节点的元素移除可能更加的符合实际的场景。</p>
<h2 id="从任意索引中删除"><a href="#从任意索引中删除" class="headerlink" title="从任意索引中删除"></a>从任意索引中删除</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">at</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> index <span class="operator">&lt;</span> elements.count <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index <span class="operator">==</span> elements.count <span class="operator">-</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elements.swapAt(index, elements.count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">defer</span> &#123;</span><br><span class="line">                siftSown(from: index)</span><br><span class="line">                siftUp(from: index)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> elements.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查待删除的索引是否在集合的边界之内，如果不在，返回<em>nil</em>；</li>
<li>如果删除的是堆中最末尾的元素，则直接进行删除，类似<em>remove</em>；</li>
<li>如果是非末尾的元素，首先交换待删除索引和末尾索引；<ul>
<li>之后删除末尾的元素，并返回该元素</li>
<li>最后，调用<em>siftDown</em>和<em>siftUp</em>进行堆节点调整</li>
</ul>
</li>
</ul>
<p>但是为什么要同时调用<em>siftDown</em>和<em>siftUp</em>呢？</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-both.png"></p>
<p>例如上图所示的堆中，想要删除元素5，首先交换5和最末尾的元素8，之后删除元素5。此时需要使用<em>sift up</em>对最大堆属性进行调整。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/sift-swap.png"></p>
<p>例如上图，想要删除元素7，需要和末尾元素1进行交换后删除，删除后，需要使用<em>sift down</em>进行调整。</p>
<h2 id="在堆中搜索元素"><a href="#在堆中搜索元素" class="headerlink" title="在堆中搜索元素"></a>在堆中搜索元素</h2><p>在删除元素之前，首先要通过索引查找对应的元素，此时需要进行堆元素的搜索。不过，堆本身并没有设计快速的搜索，对于一颗二叉搜索树来说，搜索元素有O(log n)的时间复杂度，但是对于使用数组构建的堆，数组中的元素进行排序确实不同于二叉搜索树的，此时并不能使用二分查找。</p>
<blockquote>
<p>在堆中搜索元素最差的情况下有O(n)的时间复杂度，因此在搜索的时候，可能要检查数组中的每一个元素。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">index</span>(<span class="params">of</span> <span class="params">element</span>: <span class="type">Element</span>, <span class="params">startingAt</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> i <span class="operator">&gt;=</span> count &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sort(element, elements[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> element <span class="operator">==</span> elements[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> j <span class="operator">=</span> index(of: element, startingAt: leftChildIndex(ofParentAt: i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> j <span class="operator">=</span> index(of: element, startingAt: rightChildIndex(ofParentAt: i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果索引i大于或者等于堆元素个数，则搜索失败，返回<em>nil</em>；</li>
<li>判断当前元素是否比索引i所对应的元素有更高的优先级，如果是，则所搜索的元素不可能在堆的更低的索引；</li>
<li>如果所搜索的元素和索引i所对应的元素相等，则待删除元素所在的索引就是i；</li>
<li>递归的搜索左子树从索引i开始的元素；</li>
<li>递归的搜索右子树从索引i开始的元素；</li>
<li>如果上述过程全部搜索失败，则整个搜索失败。</li>
</ul>
<h2 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h2><p>至此，已经有足够的工具针对堆进行各类操作了，但是还有一个问题就是，如果使用已存在的数组构建一个堆？在开始定义堆数据结构的时候，我们使用了一个非常简单的构造器，对其进行改造如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">sort</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>, <span class="type">Element</span>) -&gt; <span class="type">Bool</span>, <span class="params">elements</span>: [<span class="type">Element</span>] <span class="operator">=</span> []) &#123;</span><br><span class="line">    <span class="keyword">self</span>.sort <span class="operator">=</span> sort</span><br><span class="line">    <span class="keyword">self</span>.elements <span class="operator">=</span> elements</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>elements.isEmpty &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: elements.count <span class="operator">/</span> <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span>, through: <span class="number">0</span>, by: <span class="operator">-</span><span class="number">1</span>) &#123;</span><br><span class="line">            siftSown(from: i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器现在能够接收一个额外的参数，如果传入一个非空的数组，将会使用该数组构建堆，为了使得堆满足堆属性，从第一个非叶节点开始向后循环数组，然后筛选所有父节点。您只遍历了一半的元素，因为筛选叶节点没有点，只有父节点。</p>
<p><img src="/images/Data-Structures-&-Algorithms-in-Swift/15/build-heap-with-array.png"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example(of: <span class="string">&quot;building a heap with array&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> heap <span class="operator">=</span> <span class="type">Heap</span>(sort: <span class="operator">&gt;</span>, elements: [<span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>heap.isEmpty  &#123;</span><br><span class="line">        <span class="built_in">print</span>(heap.remove()<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">---Example of building a heap with array---</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h2><ul>
<li>对于堆的各类操作，有着不同的时间复杂度，具体如下：<br>  <img src="/images/Data-Structures-&-Algorithms-in-Swift/15/heap-time.png"></li>
<li>堆数据结构非常适合维护优先级最高或最低优先级的元素。</li>
<li>每次从堆中插入或删除项时，都必须检查它是否符合优先级的规则。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">1</a></li><li><a class="pagination-link" href="/tags/Swift%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="Robin&#039;s Wo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Robin&#039;s Wo</p><p class="is-size-6 is-block">Robin</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·西安</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">58</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zycslog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zycslog"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/zh_robin"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Data-Structures-Algorithms-in-Swift/"><span class="level-start"><span class="level-item">Data Structures &amp; Algorithms in Swift</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"><span class="level-start"><span class="level-item">开发知识</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%8A%80%E6%9C%AF%E4%BA%BA%E7%94%9F/"><span class="level-start"><span class="level-item">技术人生</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="level-start"><span class="level-item">数据科学</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%AF%8F%E6%97%A5%E9%9A%8F%E6%83%B3/"><span class="level-start"><span class="level-item">每日随想</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AB%AF%E6%B5%8B%E8%AE%A1%E7%AE%97/"><span class="level-start"><span class="level-item">端测计算</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E5%B0%8F%E8%AE%B0/"><span class="level-start"><span class="level-item">读书小记</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">49</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.williamlong.info/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">月光博客</span></span><span class="level-right"><span class="level-item tag">www.williamlong.info</span></span></a></li><li><a class="level is-mobile" href="https://zhangferry.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">zhangferry</span></span><span class="level-right"><span class="level-item tag">zhangferry.com</span></span></a></li><li><a class="level is-mobile" href="https://xcanoe.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">轻舟</span></span><span class="level-right"><span class="level-item tag">xcanoe.top</span></span></a></li><li><a class="level is-mobile" href="https://iosdevweekly.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">iOS Dev Weekly</span></span><span class="level-right"><span class="level-item tag">iosdevweekly.com</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.jpg" alt="Robin&#039;s Wo" height="28"></a><p class="is-size-7"><span>&copy; 2022 Robin</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zycslog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>